[
{"details": ["\n    Name: audio", "\n    Created: Apr  1, 2010", "\n    Updated: Aug 26, 2017", "\n        SVN Updated: May 12, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Audio Codec(ADPCM 1-Bit) \r\n", "The code is ready for Altera Cyclone-II DE1 Starter board and it is tested, you can modify codes and use them in any project. \r\n", "\r\n", "Core Description: \r\n", "Sampling Frequency: 44100Hz \r\n", "Channels: Stereo \r\n", "Bit-rate: 1 Bit Per Sample(So it is: 44.1 * 2 = 88.2kbps) \r\n", "Compression Ratio: 16:1 \r\n", "\r\n", "VHDL code consists: \r\n", "1-bit ADPCM Decoder(x2), I2S Driver(x1), I2C Driver(x1), Flash Memory Driver(x1), Keyboard Driver(x1), LED Bar(x1), Volume and Config Engine(x1). \r\n", "\r\n", "Codec(Encoder/Decoder) is available in Win32 application that you can use it to encode PCM RAW wave files, then burn the *.DJ file into the flash, make sure the flash is already clear(you can use the EDK control panel to clear and program the flash) and run the code on FPGA. \r\n", "\r\n", "There is no patent or copyright, it's free for everyone to use in any project. \r\n", "\r\n", "(if you need the Encoder in VHDL, contact me by e-mail.) \r\n", "\n        "]},
{"details": ["\n    Name: cfft", "\n    Created: Oct 29, 2002", "\n    Updated: Feb 14, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 10 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is synthesizeable radix 4 complex fft processor. Input data width and points are configurable. Output data width = Input data width + 2. Some necessary limited and shift have been done at every butterfly.\r\n", "\r\n", "A sample implementation of a 1024 point 12 bit FFT runs at about 97MHz in a Spartan2e100 -6 device and occupies 1,271 LUTs (about 52%) and 1,144 registers (about 47%) of the device.\r\n", "\r\n", "\r\n        ", "\n            - Data width configurable\r\n", "- Point configurable\r\n", "- Input data during data output\r\n", "- Simulation result has compare with Matlab result\r\n", "\r\n        ", "\n            - Design is available in VHDL from OpenCores CVS via cvsweb or via cvsget \r\n", "- ...\r\n        "]},
{"details": ["\n    Name: pyramid_unit", "\n    Created: Jul 10, 2003", "\n    Updated: Jul 17, 2003", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            ", "\r\nThis is a brief overview of  the article about the series of multiplication algorithms. For comparison and estimation of proposed algorithms please refer to the full article... ", "\r\n\r\n", "\r\nOperation of multiplication is very important in microelectronics. Each modern microprocessor has this operation within its instruction set, and advanced microprocessors have special multiplication units, that perform multiplication during 1 synchronization period(cycle). Especially valuable multiplication is in DSP processors, where it is practically main operation. Performance of any DSP processor is defined with delays in it MAC (multiply and accumulate) unit. So efficiency of multiplication is very important.\r\n\r\n", "\r\n", "\r\nThe idea of algorithms is as follows. Unsigned multiplicands A and D may be represented in following form: A*D = (B * 2", " + \u00f3) * (E * 2", "  + F), where n \u2013 any number that is satisfied with following conditions:\r\n", "\r\n", "\r\nHave a look at basic formula A*D = (B * 2", "  + \u00f3) * (E * 2", "  + F). In case  n=m-1, C and D have dimension of one bit. This basic formula is applied recursively to\r\nall further multiplicands. As a result dimension of multiplicands is decreased by one at every iteration. That is why the algorithm was named as \u201c", ". \r\n\r\n", "\r\n", "\r\nModified \u00abpyramid\u00bb algorithms is differ from prototype with value of n = m-2 and with dimension of operands C \u00c9 D equal to 2 bits. As may be seen  Modified pyramid algorithm implementation such small change gives valuable results improvement for area allocation.\r\n        ", "\n            ", "\r\nThe algorithm was written in VHDL, synthesized within Synopsys Design Compiler on 0.35u CMOS library. The data of the allocation areas are given only for a combinational part of algorithms.", " ", "\r\n", "\r\nThe algorithm was written in VHDL, synthesized within Synopsys Design Compiler on 0.35u CMOS library. The data of the allocation areas are given only for a combinational part of algorithms.", " ", "\n            These cores are developed and provided by ASIC reseach department member of DeverSYS Corp., Vladimir V.Erokhin. More usefull fundamental (and not only) ", " IP Cores can be found at DeverSYS web ", ".\n        "]},
{"details": ["\n    Name: serial_div_uu", "\n    Created: Apr  1, 2003", "\n    Updated: Dec 29, 2015", "\n        SVN Updated: Aug 19, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The serial_divide_uu is a Verilog coded module that performs binary division.  It is fully parameterized, and works in a serial fashion.  The number of clock cycles required to complete a divide operation is equal to the number of bits in the quotient plus one.\r\n", "\r\n", "This module has been tested and debugged in actual hardware on a Xilinx XC2S200E FPGA.  It was used to divide pulse width by period in a pulse-width-modulation measurement application (ADXL202E 2-axis MEMS accelerometers.)\r\n", "\r\n", "The widths of the signals are configurable by parameters, as follows:\r\n", "\r\n", "M_PP = Bit width of the dividend\r\n", "N_PP = Bit width of the divisor\r\n", "R_PP = Remainder bits desired\r\n", "S_PP = Skipped quotient bits\r\n", "\r\n", "The skipped quotient bits parameter provides a way to prevent the divider from calculating the full M_PP+R_PP output bits, in case some of the leading bits are already known to be zero.  This is the case, for example, when dividing two quantities to obtain a result that is a fraction between 0 and 1 (as when measuring PWM signals).  In that case the integer portion of the quotient is always zero, and therefore it need not be calculated.\r\n", "\r\n", "For those who have the luxury of many clock cycles to use up, this module can provide division results of arbitrary precision.\r\n        ", "\n            - Fully parameterized Verilog code, tested and debugged\r\n", "- No testbench\r\n", "- Calculates roughly one bit of output per clock cycle.\r\n", "- Parameter \"HELD_OUTPUT_PP\" allows user to trade off extra flip-flops for the ability to hold the stable output of the previous divide, during the next divide operation.\r\n", "- Useful for DSP systems.\r\n", "\r\n        ", "\n            - Try it out, this module works. \r\n", "- Code is very well commented, with a description of operation in the header, which suffices for documentation. \r\n", "- Thanks to David Sala for writing and submitting a VHDL testbench and VHDL version of this code. \r\n", "\r\n", "\n        ", "\n            David Sala has gracious translated this module into VHDL code, and provided a testbench for it.  This should improve this project and make it accessible and useful to more people.  Thanks David!\n        "]},
{"details": ["\n    Name: pairing", "\n    Created: Jan 17, 2012", "\n    Updated: Apr 18, 2017", "\n        SVN Updated: Mar  4, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Tate Bilinear Pairing core is specially designed for running Tate bilinear pairing algorithm for hyperelliptic curve $y^2=x^3-x+1$ defined over $GF(3^m)$, where $m=97$ and $GF(3^m)$ is defined by $x^97+x^12+2$.\r\n", "\r\n", "Generally speaking, The Tate bilinear pairing algorithm is a transformation that takes two points on an elliptic curve and outputs a nonzero element in the extension field $GF(3^{6m})$. Details of the algorithm is in the document. \r\n", "\r\n", "The core is written in Verilog 2001, and it is carefully optimized for FPGA. For example, input signals are synchronous and sampled at the rising edge of the clock. Output signals are driven by flip-flops, and not directly connected to input signals by combinational logic. There is no latch, and only one clock domain in entire core.\r\n", "\r\n", "The core runs at 131MHz on the Xilinx Virtex-4 XC4VLX200-11FF1513 FPGA board. It computes one Tate bilinear pairing within 75,839 clock cycles, which is 0.76 milliseconds @ 100MHz clock.\r\n", "\r\n", "The core uses 49205(27%) LUTs, 35381(39%) slices, 31425(17%) flip-flops of the XC4VLX200-11FF1513 FPGA board. \r\n", "\r\n", "The core is an open source Tate Bilinear Pairing core, under the license of LGPL version 3.\n        ", "\n            ", "\n        ", "\n            - Tate bilinear pairing for hyper-elliptic curve $y^2=x^3-x+1$\r\n", "- The irreducible polynomial is $x^97+x^12+2$\r\n", "- Input length is 4*194 bits and output length is 1164 bits\r\n", "- Fully synchronous design \r\n", "- Fully synthesize-able\r\n", "- ONLY ONE clock domain in entire core\r\n", "- NO latch\r\n", "- All output signals are buffered\r\n", "- Vendor independent code\n        ", "\n            - The core is ready and available in Verilog from OpenCores svn\r\n", "\n        ", "\n            - Increase the degree of the irreducible polynomial for improving the security level\r\n", "- Use a better algorithm for the final exponentiation in $GF(3^{6m})$\n        ", "\n            https://www.linkedin.com/in/homerhsing/\n        "]},
{"details": ["\n    Name: single_clock_divider", "\n    Created: Apr 23, 2004", "\n    Updated: Sep 28, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            \r\nThis is a brief overview of the article about ", " unsigned integer division algorithm. For comparison and estimation of proposed algorithms please refer to the full article... ", "\n        ", "\n            Now two division algorithms are wide spread in computing: restoring and non-restoring algorithms. They consider that both algorithms may be used in sequential calculation scheme, when one digit of the result is achieved during one clock. However there are no principle objections against getting all digits of the quotient and the remainder during one clock. So the author tried to develop such kind of algorithm.\n        ", "\n            These cores are developed and provided by ASIC reseach department Leader of DeverSYS Corp., ", ". More useful fundamental (and not only) ", " IP Cores can be found at DeverSYS web ", ".\n        ", "\n            Restoring algorithm is seemed to be sequential in nature because during remainder restoring there is positive feedback (A=A \u2013 B + B at the same cycle). To avoid the feedback it is necessary to insert register for intermediate result storing. \r\nThus, non-restoring algorithm was chosen as basic for one-clock division algorithm.\r\n", "\r\nRecursive approach was chosen due to it provides compact and transparent description. It is easy to see that synthesis result of the description is sequence of adders.\n        "]},
{"details": ["\n    Name: ternary_adder", "\n    Created: Apr  3, 2013", "\n    Updated: Jan 14, 2015", "\n        SVN Updated: Apr  5, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            This IP core provides resource efficient ternary adders, i.e., adders with three inputs performing s = x + y + z, for the Altera and Xilinx platforms. \r\n", "Resource efficient means that they need exactly the same resources on modern FPGAs as two-input adders, but are slightly slower.\r\n", "\r\n", "A complete description can be found in the ternary adder documentation: ", "\r\n", "\r\n", "Note that the used method for the Xilinx ternary is patented (US patent no 7,274,211). Hence, only private, research or non-commercial use is allowed with this implementation!\n        "]},
{"details": ["\n    Name: reedsolomon", "\n    Created: Jun 15, 2010", "\n    Updated: Jun 16, 2010", "\n        SVN Updated: Jun 16, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project implements a parameterized Reed Solomon decoder for use in OFDM wireless systems. \r\n", "Source code provided in C++ (trunk/cpp-source) and Bluespec(trunk/bluespec-source).\n        "]},
{"details": ["\n    Name: popcount_gen", "\n    Created: Jun 20, 2011", "\n    Updated: Jul 12, 2011", "\n        SVN Updated: Jun 27, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            C code for generating a stand-alone population counter with user-defined size (number of input bits) and latency (number of clock cycles) in VHDL.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: matrix3x3", "\n    Created: Jun 15, 2006", "\n    Updated: Feb 26, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n"]},
{"details": ["\n    Name: tiny_tate_bilinear_pairing", "\n    Created: Apr 19, 2012", "\n    Updated: Apr 18, 2017", "\n        SVN Updated: Nov 14, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Tiny Tate Bilinear Pairing core is for calculating Tate bilinear pairing.\r\n", "In fact it is a special type of Tate bilinear pairing called reduced $\\eta_T$ pairing. \r\n", "\r\n", "Its features are:\r\n", "* super-singular elliptic curve E:y^2=x^3-x+1\r\n", "* the field is the Galois field GF(3^m),m=97 or 593\r\n", "* the irreducible polynomial is x^97+x^12+2 or x^593+x^112+2\r\n", "* the group size is 151 bits or 911 bits\r\n", "* vendor independent code\r\n", "* very low hardware cost (\u22640.2 US dollar) if m=97\r\n", "* released under Apache License v2.0\n        ", "\n            ", "\r\n", "\r\n", "\n        ", "\n            The reduced $\u03b7_T$ pairing is introduced by Barreto et.al.\r\n", "There are at least two related nice papers:\r\n", "[1] P.Barreto, S.Galbraith, C.O hEigeartaigh, and M.Scott. Efficient pairing computation on supersingular abelian varieties. in\r\n", "Designs, Codes and Cryptography. Springer Netherlands, Mar. 2007, vol. 42(3), pp. 239\u2013271.\r\n", "[2] J.Beuchat, N.Brisebarre, J.Detrey, E.Okamoto, M.Shirase, and T.Takagi. Algorithms and arithmetic operators for computing the \u03b7_T pairing in characteristic three. in IEEE Transactions on Computers, Special Section on Special-Purpose Hardware for Cryptography and Cryptanalysis, 57(11):1454-1468, 2008.\n        ", "\n            Low secure level core\r\n\r\n", "\n            Low secure level core\r\n\r\n", "\n            The low secure level core computes one Tate pairing in 1.05 milliseconds if with a 50MHz clock.\r\n", "\r\n", "The high secure level core computes one Tate pairing in 20.0 milliseconds if with a 50MHz clock.\n        ", "\n            Xilinx Spartan 3 XC3S200 FPGA is enough for the low secure level core.\r\n", "The price of that FPGA is less than 0.2 USA dollar per piece in 2012.\n        ", "\n            ", "\n            This core follows the idea in the academic paper of Mr.Beuchat et.al. \r\n", "This core uses 20% less FPGA slices, 50% less RAM memory than Mr.Beuchat et.al.\r\n", "But this core is slower than Mr.Beuchat et.al.\n        ", "\n            https://www.linkedin.com/in/homerhsing/\n        "]},
{"details": ["\n    Name: vhdl-pipeline-mips", "\n    Created: Apr  8, 2010", "\n    Updated: Dec  1, 2016", "\n        SVN Updated: Apr 10, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL Implementation of a basic Pipeline MIPS processor. It has a translator of MIPS assembler code and implement the division algorithm restoring.\n        "]},
{"details": ["\n    Name: pat-processor", "\n    Created: Dec  2, 2017", "\n    Updated: Dec  3, 2017", "\n        SVN: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: pid_controler", "\n    Created: Sep 20, 2010", "\n    Updated: Sep 20, 2010", "\n        SVN Updated: Oct 13, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: lzrw1-compressor-core", "\n    Created: Apr  5, 2013", "\n    Updated: Dec 19, 2013", "\n        SVN Updated: Apr  7, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This IP core allows lossless data compression based on the Lempel-Ziv-Ross-Williams-1 algorithm. Its focus is on high throughput (of uncompressed data) at the expense of an somewhat lower compression ratio. One byte of uncompressed data can be processed at every second clock\r\n", "cycle. A software decoder (decompressor) written in java is included. \r\n", "The core is fully pipelined to allow high clock speeds. 66MHz can easily be achieved on a Spartan6\r\n", "FPGA. This results in a maximum compression throughput of almost 32MBytes/sec.\r\n", "It uses a Wishbone compliant slave interfaces to receive uncompressed data and configuration information. A second Wishbone (master) interface is used by the included DMA unit to directly transfer the compressed data to RAM or another Wishbone slave.\r\n", "The project includes a file based test bench which compresses externally generated input files. The compressed file can be verified with an included java tool. Both the VHDL and java code have been tested with an Spartan6 FPGA and several 100MB of hardware generated random data.\r\n", "The core occupies ~500 Spartan6 slices using 1605 FF/LUT pairs of which 44% are fully used.\n        "]},
{"details": ["\n    Name: video_dithering", "\n    Created: Jun 10, 2012", "\n    Updated: Jun 29, 2013", "\n        SVN Updated: Jun 29, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The core supplies post-processing for a video signal.\r\n", "It reduces the color width while dithering the image to keep the impression of more colors than really exist.\r\n", "This reduces banding effects and enhances the quality for the viewer.\r\n", "\r\n", "The used method is \"Sierra Lite\".\r\n", "\r\n", "The core is configurable (at compile/synthesis time) in:\r\n", "- resolution\r\n", "- input color width\r\n", "- output color width\r\n", "\r\n", "It uses very few ressources. \r\n", "Common Full HD Dithering (1920*1080 @ 60hz @ 6 bit from 8 bit source)\r\n", "used with many LCD Displays possible on cyclone 2:\r\n", "- 120 LE\r\n", "- 8kbit Memory (2 M4K Blocks)\r\n", "- timing met (~125 Mhz required, ~140 Mhz possible)\r\n", "\r\n", "Tested in simulation:\r\n", "bmp read -> processing -> written back to bmp\r\n", "\r\n", "Tested on hardware using Altera/Terasic DE1:\r\n", "- Cyclone 2\r\n", "- 640 * 480 @ 60hz\r\n", "- Reduction from 8 bit per color to 3 bit per color\n        ", "\n            Simulation\r\n", "----------\r\n", "\r\n", "1. Compile both files, containing dither entity and testbench.\r\n", "2. Run all\r\n", "3. Testbench will stop automatically when the whole image is processed\r\n", "4. View Output.bmp for result\r\n", "\r\n", "Note: for some reason MS Paint doesn't like the output.bmp\r\n", "Just use another programm, e.g. FireFox, IrfanView, MS VisualStudio...\r\n", "\r\n", "you should also try:\r\n", "- exchange the image in input.bmp\r\n", "- change reduced bits per pixel\r\n", "\r\n", "\r\n", "Implementation\r\n", "--------------\r\n", "- The core needs an image stream with 1 pixel(RGB) each clock.\r\n", "- You can disable the core if the stream is stopped for some reason.(e.g. VGA offscreen)\r\n", "- The core needs the x position of the current sample. \r\n", "- You should NOT input the same x position twice in a row\r\n", "- Always increase x with each clock cycle or turn the core off.\r\n", "- y change is automatically recognized\r\n", "- x must increase\r\n", "- y can increase or decrease, result may look slightly different but is same quality\n        "]},
{"details": ["\n    Name: cryptopan_core", "\n    Created: Feb 16, 2007", "\n    Updated: Feb 26, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            A hardware implementation of Crypto-PAn[1]. The core makes use of a fully pipelined 128-bit AES (Rijndael) cipher engine as the underlying pseudorandom function, supports online key changes, and is capable of line rates exceeding gigabit ethernet.\r\n", "\r\n", "[1] Blake, A. and Nelson, R. 2008. Scalable Architecture for Prefix Preserving Anonymization of IP Addresses. In Proceedings of the 8th international Workshop on Embedded Computer Systems: Architectures, Modeling, and Simulation (Samos, Greece, July 21 - 24, 2008). M. Berekovi\u0107, N. Dimopoulos, and S. Wong, Eds. Lecture Notes In Computer Science, vol. 5114. Springer-Verlag, Berlin, Heidelberg, 33-42. DOI= ", " \r\n", "\n        ", "\n            Crypto-PAn features:\r\n", "- One to one mapping from original IP address to anonymized IP address\r\n", "- Prefixes are preserved. That is, if two original IP addresses sharea a k-bit prefix, their anonymized mapping also share a k-bit prefix. \r\n", "- Consistency is maintained across traces. That is, the same IP address in differant traces is mapped to the same anonymized IP address, if the secret key used is the same. \r\n", "\r\n", "Core features:\r\n", "- Fully pipelined \r\n", "- AES(Rijndael) engine capable of 32Gbit/s throughput on Virtex-4.\r\n", "- Supports online secret key changes.\r\n", "- Compatiable with Jinliang Fan's C+++ reference implementation. That is, using the same secret keys, IP addresses will map to the same anonymous IP addresses.\r\n", "- Capable of anonymizing traces at line rates above gigabit ethernet.\r\n", "\r\n", "\n        ", "\n            Verified in hardware on XCV4FX60 FPGA.\n        "]},
{"details": ["\n    Name: erp", "\n    Created: Sep 17, 2004", "\n    Updated: Feb 26, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            An implementable and enhancable RISC Core developed in Verilog HDL, tested on Xilinx IIE Spartan FPGA.\n        ", "\n            - feature1\n", "  - feature1.1\n", "  -feature1.2\n", "-feature2\n        ", "\n            -Currently present Verilog Module is implementable, and also enhancements could be made as desired\r\n", "- status2\n        "]},
{"details": ["\n    Name: fast_log", "\n    Created: Oct 10, 2009", "\n    Updated: Jan 28, 2011", "\n        SVN Updated: Aug  3, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A fast (single-cycle) base-2 log function, based on the description at ", "\r\n", "\r\n", "Need an electronic design solution? Visit ", "\r\n", "\r\n", "First uploaded version is in Verilog, with pipelining to maximize the clock frequency. An example implementation: It takes less than 2% of the smallest CycloneIII, and runs at 250MHz on the IOs. Probably even higher if internal-only. It even fits in a mid-sized CPLD!\r\n", "\r\n", "Second version strips outs the pipelining registers. Simpler if you don't need the throughput. This one clocks in at 14ns propagation delay pin-pin on the same CycloneIII. Not a bad speed for a logarithm, right? :-)  (BTW, the syntax here requires System Verilog)\r\n", "\r\n", "The third version is similar to the first, except the fractional LUT has been expanded for higher accuracy and resolution.\r\n", "\r\n", "If you use any of these, please write and tell me about it!\r\n", "\r\n", "p.s., check out my antilog project too - combine them for square-root\r\n", "\n        "]},
{"details": ["\n    Name: wf3d", "\n    Created: Sep 30, 2015", "\n    Updated: Oct 29, 2016", "\n        SVN Updated: Nov  4, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            WF3D is a real-time 3D graphics rendering IP Core.", "\r\nThe IP Core reads 3D triangle vertices from memory, then transforms them into 2D space, ", "\r\nand writes 2D triangle\u2019s edge line to memory. Note that this IP Core only supports Wire-Frame 3D graphics.", "\r\nIn other words, the IP Core does not have traditional 3D graphics rendering features, ", "\r\nsuch as polygon filling, texture mapping, lighting, etc.", "\r\nInstead of lacking these features, this IP Core has several advantages, ", "\r\nsuch as small logic consumption and low-bandwidth memory access.", "\r\n\r\n"]},
{"details": ["\n    Name: verilog_vga", "\n    Created: Oct 14, 2015", "\n    Updated: Oct 15, 2015", "\n        SVN Updated: Oct 15, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A simple VGA controller written in Verilog. I just add a pixel handler for simplicity. \n        "]},
{"details": ["\n    Name: video_stream_scaler", "\n    Created: Feb 21, 2011", "\n    Updated: Sep  8, 2017", "\n        SVN Updated: Feb 25, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Video Stream Scaler scales streaming video up or down in resolution. Bilinear and nearest neighbor resize\r\n", "modes are supported.\r\n", "\r\n", "This core provides run-time adjustment of input and output resolution, scaling factors, and scale\r\n", "type. Compile time adjustment of maximum resolutions and data width.\n        ", "\n            FPGA: Altera Cyclone III 3C120\r\n", "Configuration: 10 bits per pixel, 1 color channel, RFIFO size of 3\r\n", "\r\n", "Logic Cells: 571\r\n", "Registers: 237\r\n", "M9ks: 9\r\n", "9x9 multipliers: 3\r\n", "18x18 multipliers: 8\r\n", "\r\n", "\r\n", "Greater than 108MHz (SXGA 60Hz) maximum clock rate on Altera Cyclone III 3C120, speed grade 7, 19% total logic element utilization.\n        "]},
{"details": ["\n    Name: opb_vga_char_display_nodac", "\n    Created: Oct  9, 2007", "\n    Updated: Oct 17, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is an OPB-compatible VGA character display for the Spartan 3E development board, which does not contain DACs.\r\n", "\r\n", "The core is very small, requiring only 3 BRAMs and 533 slices.\r\n", "\r\n", "All access is through write character commands, similar to an LCD display. 3-bit color is supported, as well as inverted characters.\r\n", "\r\n", "Current resolution is 640x480, 75x55 characters\n        ", "\n            - Ease of use\r\n", "  - Includes write string function\r\n", "  - Individual characters can also be written\r\n", "- Small footprint\n        ", "\n            - status1\n", "- status2\n        "]},
{"details": ["\n    Name: lq057q3dc02", "\n    Created: May 21, 2007", "\n    Updated: Apr 12, 2015", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Driver for Sharp LQ057Q3DC02 320x240 QVGA LCD.  Driver accurate to datasheet specifications.  Will also work for LQ057Q3DC12 (Pb-free version).\n        ", "\n            - Fully parameterizable and easily adapted to larger LCD screen by simply changing counter register sizes and generic timing parameters.\r\n", "\r\n", "- All-digital interconnect.  No digital to analog converter required.  Simply attach the output ports of the top-level entity to the data connector on the LCD.\r\n", "\r\n", "- Includes specific files for the Xilinx Virtex-II Pro development board available at ", "\r\n", "\r\n", "- C application provided to generate the necessary BRAM COE files for Xilinx CoreGen tool.\r\n", "\r\n", "- Java application provided to generate the expected image that should appear on the screen using the provided COE files.\n        ", "\n            - Design Complete and FPGA Proven\n        "]},
{"details": ["\n    Name: video_systems", "\n    Created: Mar 18, 2002", "\n    Updated: Aug 27, 2008", "\n        SVN Updated: Jun 23, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The 'Video Compression Systems Project' was started with the idea to provide readily available blocks for compression systems. Which, combined toghether, form a complete compression standard.\r\n", "\r\n", "Examples of popular standards are:\r\n", "- MPEG (MPEG-1, MPEG-2, MPEG-4) and H.264\r\n", "- H.310, H.320 etc. (video conferencing)\r\n", "- JPEG & MJPEG\r\n", "- etc.\r\n", "\r\n", "All aspects of a standard are covered. The links on the top of this page provide access to the blocks needed to build a complete system.\r\n", "\n        ", "\n            - Finished cores:\r\n", "- - 8x8 fully pipelined parallel DCT. Provides a DCT result every clock cycle.\r\n", "- - QNR. Quantization & Rounding Unit.\r\n", "- - Run-Length-Encoder.\r\n", "- - Huffman Encoder / Decoder.\r\n", "- - A base profile H.264 encoder\r\n", "\r\n", "- Developers wanted.\n        "]},
{"details": ["\n    Name: fbas_encoder", "\n    Created: Feb 16, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This part was completely redesigned due to variant output inpedances of different CPLD/FPGA and to reduce the moving pattern from older versions.\r\n", "The two transistors are used for impedance transformation so the output inpedance has not more much effect\r\n", "to the result. In the upper part the luminance signal is generated and in the lower part the chrominance\r\n", "signal. The two 1,2KOhm resistors on  fbh and fbl pin sets the chrominance output to\r\n", "a defined level. The chrominance signal is mixed with the luminace signal by an simple capacitor, this is\r\n", "also used in cheap s-video to FBAS adapters. So this works, it should be easy to create s-video by\r\n", "splitting this connection, but this feature is untested.\n        ", "\n            The design written in VHDL fits in a cheap XC9536 CPLD if only PAL or NTSC signals are generated. \r\n", "Walking pattern visible on some TV at older versions of the design are minimized. The design is more easy\r\n", "expandable but by the cost of an increased amount of external hardware. For some cases ther are ready-to-use\r\n", "jedec files in the jedec folder.\r\n", "\r\n", "For a german version have a look at my homepage ", "\r\n", " \n        ", "\n            7.2.2007 the first public version (0.21)\r\n", " \r\n", " * PAL and version NTSC for 16, 20, 32 and 40 MHz clock frequency\r\n", "\r\n", "9.3.2007 version (0.31) \r\n", "\r\n", " * give up the way with a long ROM table in favor of an mixed signal generation\r\n", " * a more clearly design and improved image quality\r\n", "\r\n", "\n        ", "\n            The luminance signal generation is the same as generate B/W only signals. It uses a little table to calculate\r\n", "the different levels. This component is located in file luma_gen.vhd. In some cases it is also possible to generate the luminance signal directly by the rgb source without using this component. For example, if your MCU is already generating an BAS signal you can add the chrominance signal in the simple way of a capacitor.  \n        ", "\n            To get a chip, who's working a little bit of additional logic (glue) is necessary. \r\n", "The rgb signals are stored in regsters to get a more synchronous design and to avoid glitches by different\r\n", "input delays. Also 2 threestate outputs for the chrominance-signals (burst and colour) and if needed, a\r\n", "clock divider for the CPU/MCU clock. The luminance signal generation is clocked only by the CPU clock because faster clocking has no advantage and provides undesirable noise.  \r\n", "The cgsel signal can used as an fourth bit to select one of 8 grey levels or with an external switch. '0' selects\r\n", "colour mode and '1' selects greylevel mode. With the cg\\_pnsel signal it is possible to switch between PAL ('0')\r\n", "and NTSC ('1') without any hardware changes. If only PAL or NTSC is needed, feeding this signal with statically '0' or '1' results in decreasing the amount of logic cells. \r\n", "\n        ", "\n            There are many usefull addresses on the Internet and so I only want to tell briefly the most important to know \r\n", "about the PAL system. Horizontal timing and vertical timing are identical to the black and white BAS signal \r\n", "as much as possible. The main difference is the colour carrier signal which is used to encode the additional\r\n", "information.\r\n", "To avoid moires on black'n white pattern the colour carrier has a crooked frequency. \r\n", "Namely the horizontal frequency of 15,625 hertz * 283.75 plus the half vertical frequency (25 hertz). \r\n", "With it one comes on 4,433,618.75 hertz. To generate this we can use a quartz oscillator or find a way to use \r\n", "the system clock from teh rgb source (e.g. microcontroller). This can be done by using DDS (Direct Digitally Synthesis) \r\n", "and a error of just abovementioned 25 hertz must be accepted, otherwise we need very wide counters to the signal production.\r\n", "With a clock frequency of 16 MHz we need such a counter (accumulator register) with 12-bit width. \r\n", "Every clock the counter adds 1135 (283.75 * 4) and so we get the (approximate) value of the colour carrier.\r\n", "With 20 MHz clock speed this would be theoretical 908, a 10-bit-wide counter should be also enough with addition of 227.\r\n", "\r\n", "To identify a colour signal and to synchronise the quartz oscillator in the TV, the normally quadrature-modulated \r\n", "colour carrier will be sent unmodulated shortly after the synchronous impulse for approx. 10 periods. This is named\r\n", "as the burst. If burst is sent the phase changes from line to line between -135 and +135 degrees.\r\n", "However, after my experiences 8 periods are also sufficient. The amplitude of the Bursts amounts to 0,15V exactly 50% \r\n", "of the maximum amplitude with maximum colour saturation. For the basic colours a saturation of about 50% is \r\n", "completely sufficient but its also possible to create a table with another saturation. The FBAS (CVBS) signal consists\r\n", "of three signals:\r\n", "\r\n", " * the luminance signal Y = 0,299*R + 0,587*G + 0,114*B\r\n", " * the U colour signal U = 0,493 * (B-Y)\r\n", " * the V colour signal U = 0,877 * (R-Y)\r\n", " \r\n", "The Y signal will transfer directly, the U and V signals modulates the colour carrier by quadrature-modulation.\r\n", "In brief the U signal is multiplied by the cosinus wave of the colour carrier and the V signal with about\r\n", "0 or 180 degrees of the sinus wave of the colour carrier. Besides, the tone is encoded in the phase and the colour\r\n", "saturation in the amplitude of the modulated colour carrier. In the last stage the three signals will be added and \r\n", "during the synchronous impulses it must be set to 0 V. \n        ", "\n            After some projects of rgb colour video output with AVR microcontrollers there was the question\r\n", "about FBAS (cvbs) signal generation on a simple and easy way. For example, to be able to feed a \r\n", "modulated HF signal into an aerial arrangement.\r\n", "Because a microcontroller is rather inexpedient for it on account of the necessary processing speed,\r\n", "the decision fell in favour of a CPLD. Of course there is for such things also special-IC's,\r\n", "but I did not want to choose this way. As result there is a simple design which also fits in a XC9536 from Xilinx.\r\n", "The encoder components can be also integrated into other designs, provided, the regulations of the LGPL are kept.\r\n", "\r\n", " * the colour carrier frequency is generated from the system clock of 16 or 20 MHz\r\n", " * inputs: hsync, vsync and rgb\r\n", " * 8 basic colours / 8 grey steps eligible\r\n", " * the same hardware can be used for PAL and NTSC\r\n", "\r\n", "the following image shows a \"screenshot\" of a test program. Because of the spectral sensitivity of my digicam the colours which contains blue are brighter as viewed by eyes.\n        ", "\n            Due to the complex logic, the timing in chroma-path is a little bit critical and limits clock speed.\r\n", "For correct results for 32MHz a 7ns CPLD is needed, for 40MHz a 5ns one. So fast spikes are filtered\r\n", "by lowpassing at the output, a 15ns Device works well in all cases. For better timing more macrocells\r\n", "(38-40) are necessary to flatten the design. Another way is to store stages of the chrominance signal\r\n", "generation in stages (pipelining). This causes in delay between chrominance and luminance signals which\r\n", "should not be visible on TV. Or, the luminance signal must also beeing delayed. For PAL and a little bit\r\n", "less of image quality the 16- and 20MHz versions are an good alternative. \r\n", "\n        ", "\n            And now te big question, how can we fit these functions in a small CPLD. \r\n", "The colour carrier and the Burst signal do the least problems, the modulation and mixture with the Y signal \r\n", "is less trivial. After some experiences with long ROM tables including the first official version 0.21 I\r\n", "decided this was not a good way. Poor image quality and the need for an external script were the reasons\r\n", "for searching another way. With the first attempts appeared that it is possible theoretically to generate\r\n", "a FBAS (CVBS) signal, while rebuild the signal path digitally. But, the logic expenditure is rather high. \r\n", "The new way I've found is to generate chrominance and luminance signals digitally and add them on an\r\n", "analog way after lowpassing. So it's possible to limit the bandwidth of the chrominance and the luminance\r\n", "signals separately.\n        ", "\n            FILE: chroma_gen.png\n", "DESCRIPTION: chroma generation component\n", "\n        ", "\n            FILE: luma_gen.png\n", "DESCRIPTION: luma generation component\n", "\n        ", "\n            FILE: main.png\n", "DESCRIPTION: \n", "\n        ", "\n            FILE: connect.png\n", "DESCRIPTION: wiring diagram\n", "\n        ", "\n            The DDS synthesis and burst generation are like the older versions, but the signal generation is completely\r\n", "redesigned. The component which does this is located in the file chroma\\_gen.vhd.\r\n", "The necessary phase shift is calculated of the 4 MSB of the carrier signal, rgb and burst. The resolution\r\n", "is limited to 4 bits resulting in phase steps of 22,5 degrees.\r\n", "\r\n", "-burst ha a phase of +135 and -135 degrees, equivalent shift vallues are 6 and 10 (16-6)\r\n", "-because of V=0 on blue colour the phase shift in this case is 0 deg n odd and even lines.\r\n", "-the phase shifts of the other colours can be determined by the colour circle, the value is changing between n and 16-n between the lines.\r\n", "-in the case of NTSC generation the phase shift of burst and colour does not alter between the lines        \r\n", "\r\n", "The necessarey phase shift is been calculated by a little table and was added to the colour carrier\r\n", "value to get the phase of the modulated carrier. For simplification only the MSB of the  addition was\r\n", "used to generate a rectangular signal. For black, white and grey levels the chrominance signal is switched\r\n", "off, for the burst signal a output to generate a reduced amplitude is activated.\r\n", "This concept is easy expandable to generate more colours in higher phase resolution and/or multiple\r\n", "carrier levels.\r\n", "In the result of problems with XST and configurations (ignored by 7.1) in file main.vhd the component \r\n", "declaration is followed by the selected architecture. For different clock speeds there are exists 4 architectures, clock16, clock20, clock32 and clock40. \r\n", "\r\n", "The testing of the image quality is mostly subjective by using a 5\\\" LCD-TV (the only i can use to thest NTSC). At PAL modes the quality is better than at NTSC modes, but this is more problem of the TV standards. The 16- and 20MHz verions are highly unuseable for NTSC generation because of \\\"blowing\\\" from coloured to non coloured areas in the image. Better lowpassing of the chrominace signal should help but is not tested.\r\n", "\n        ", "\n            FILE: fbas-enc_scrs1.jpg\n", "DESCRIPTION: \n", "\n        "]},
{"details": ["\n    Name: vga_lcd", "\n    Created: Sep 25, 2001", "\n    Updated: Sep 21, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The OpenCores VGA/LCD Controller core is a WISHBONE revB.3 compliant embedded VGA core capable of driving CRT and LCD displays. It supports user programmable resolutions and video timings, which are limited only by the available WISHBONE bandwidth. Making it compatible with almost all available LCD and CRT displays\r\n", "\r\n", "The core supports a number of color modes, including 32bpp, 24bpp, 16bpp, 8bpp gray-scale, and 8bpp-pseudo color. The video memory is located outside the primary core, thus providing the most flexible memory solution. It can be located on-chip or off-chip, shared with the system\u2019s main memory (VGA on demand) or be dedicated to the VGA system. The color lookup table is, as of core version 2.0, incorporated into the color-processor block.\r\n", "\r\n", "Pixel data is fetched automatically via the Wishbone revB.3 Master interface, making this an ideal \u201cprogram-and-forget\u201d video solution. More demanding video applications like streaming video or video games can benefit from the video-bank-switching function, which reduces flicker and cluttered images by automatically switching between video-memory pages and/or color lookup tables on each vertical retrace.\r\n", "The core can interrupt the host on each horizontal and/or vertical synchronization pulse. The horizontal, vertical and composite synchronization polarization levels, as well as the blanking polarization level are user programmable. \r\n", "\r\n        ", "\n            FILE: block_diagram.gif\n", "DESCRIPTION: \n", "\n        ", "\n            ", "\n            - VGA/LCD core v2.0 is ready and available in verilog from OpenCores CVS via cvsweb or via cvsget.\r\n", "- Low level abstraction layer available in C from CVS.\r\n", "- Character simulation software is currently under development.\r\n        ", "\n            LeonardoSpectrum synthesis results for Altera devices. Aimed at 100MHz clock operation (wishbone clock & pixel clock), area optimezed.\r\n", "\r\n", "- FLEX: EPF10K50E-1: 1112lcells, 16080mem_bits@82MHz wishbone, 100MHz pixel clock\r\n", "- ACEX: EPF1K50-1: 1113lcells, 16080mem_bits@85MHz wishbone, 107MHz pixel clock\r\n", "- APEX: EPF20K60E-1: 1142lcells, 16080mem_bits@47MHz wishbone, 119MHz pixel clock\n        "]},
{"details": ["\n    Name: mpeg2fpga", "\n    Created: Aug 25, 2017", "\n    Updated: Aug 29, 2017", "\n        SVN Updated: Aug 25, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            This project is an ", " decoder. The decoder converts\r\nan MPEG2 stream into a RGB video output. To get a functioning decoder, you will need to add at\r\nleast the following additional components:\r\n", "The input of the decoder is a MPEG2 stream. This could be\r\nstreaming video over ethernet, a tv or satellite tv tuner, or a\r\nfile on flash memory.", "The output of the decoder is a Red/Green/Blue (RGB) video\r\nsignal. This can be connected to a VGA, DVI or HDMI video\r\noutput.", "The decoder also needs a memory controller and RAM as a\r\nscratchpad memory, to store decoded video images.", "Lastly, if your project includes a small micro controller, you\r\ncan use the On Screen Display (OSD).", "What this decoder does not do:", "Tested & Verified on Xilinx ML505 board.", "\r\n", "Contains testbenches based on iVerilog and GTKWave.", "\r\n", "For more in-depth information, see the ", "."]},
{"details": ["\n    Name: npigrctrl", "\n    Created: Apr 28, 2008", "\n    Updated: Jul 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The design provides basic video function.\n        ", "\n            - Configurable resolution up to 1600x1400\r\n", "- Configurable pixel width 16,32 bit per pixel\r\n", "- Configurable Burst Size and NPI width\r\n", "- Stride support\r\n", "- Direct memory access through Xilinx NPI channel\r\n", "- Support Spartan3x family, Virtex4, Virtex5\r\n", "- Demo design and bitstream available for EUS FS, ML403, ML405 and ML505\n        ", "\n            - Resolutions: 640x480x32/16; 800x600x32/16; 1024x768x32/16; 1600x1200x16\r\n", "- Tested platforms Spartan3E, Virtex4, Virtex5\r\n", "- Design is available in VHDL - XPS core\n        ", "\n            - Docs\r\n", "- Add virtual DMA engine\r\n", "- Add multilayer support with an alpha-blending\r\n", "- Accelerator pipe\r\n", "- Graphical Library Support (Allegro and AGG)\n        ", "\n            ", "\r\n", "\r\n", "\n        ", "\n            ", " The ML405 board AGG demo example that demonstrates clipping to multiple rectangular regions. The example is rendered at PPC. The resolution is 1280x1024x32bits without HW accelerator. ", "The demos can be downloaded at:", " After download unpack the file, initiate FPGA by downloading bitstream and download demo software by XMD:"]},
{"details": ["\n    Name: motion_estimation_processor", "\n    Created: Aug 27, 2009", "\n    Updated: Jan  6, 2015", "\n        SVN Updated: Oct 11, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            High-definition programmable and configurable motion estimation processor for H.264, VC-1 and AVS video codecs. \n        ", "\n            The LiquidMotion LMx1 processor is a reconfigurable ASIP (Application Specific Instruction Set Processor) designed to execute user-defined block-matching motion estimation algorithms optimized for hybrid video codecs such as MPEG-2, MPEG-4, H.264 AVC and Microsoft VC-1.  The core offers scalable performance dependent on the features of the chosen algorithm and the number and type of execution units implemented. The ability to program the search algorithm to be used, and to reconfigure the underlying hardware that it will execute on, combines to give an extremely flexible motion estimation processing platform. \r\n", "A base configuration consisting of a single 64-bit integer pipeline, capable of processing 1080p HD video at 30 frames per second using a hexagonal motion estimation search followed by a square refine (as used in the opens-source h.264 encoder x264) with 1 reference frame and 16x16 block size can be implemented in 2,300 FPGA logic cells. In contrast, a complex configuration including support for motion vector candidates, sub-blocks, motion vector costing using Lagrangian optimization, four integer-pel execution units and one fractional-pel execution unit plus interpolation will need around 14,000 logic cells. At least one integer-pel execution unit must always be present to generate a valid processor configuration but the others units are optional, and are configured at synthesis time.\r\n", "\n        ", "\n            \u2022\tIntuitive and easy programming using a c-like syntax of user-defined block matching motion estimation algorithms.\r\n", "\u2022\tHighly configurable architecture enables the designer to optimize the hardware for the selected algorithm.\r\n", "\u2022\tBinary compatibility so that once an algorithm has been compiled it can be executed by any hardware configuration.\r\n", "\u2022\tSupport of advance features such as rate distortion optimization using Lagrangian techniques, sub-partitions and fractional pel searches\r\n", "according to the codec standard. \r\n", "\u2022\tEfficient evaluation of multiple user-defined motion vector candidates transparently to the rest of the algorithm. \r\n", "\u2022\tToolset available to enable the efficient exploration of the large design space and the generation of the RTL configuration file for the hardware processor library.\r\n", "\n        ", "\n            \u2022\tVideo coding (H.264, MPEG-4, MPEG-2, VC-1, AVS)\r\n", "\u2022\tVideo enhancement applications such as frame rate conversion, de-interlacing, super-resolution and video \r\n", "      stabilization.\r\n", "\n        ", "\n            A toolset has been developed that enables the   algorithm designer access to the hardware features without any knowledge of the processor microarchitecture.  The toolset IDE is a fully integrated environment composed of a compiler, assembler, cycle accurate model and RTL export.  The Cycle Accurate Model includes a full implementation of the x264 encoder (open-source h.264) so the designer can quickly evaluate the effects of different motion estimation algorithms in terms of PSNR and bit rate. The algorithm designer can create a new algorithm for the required application using typical C constructs such as for, while loops and if-else constructs. The compiler automatically recognises the search points that correspond to fractional-pel searches and generates the correct instructions.\r\n", "Parallelism is extracted by the compiler by coding  search patterns composed of a variable number of search points in a single instruction. The hardware analyses the instruction and distributes the load to the available execution units. Using the cycle accurate model the designer can quickly explore the performance of many configurations in terms of frame per second throughput, compressed video bit-rate and PSNR, hardware complexity and power/energy consumption.\r\n", "The impact of changes in the original search algorithm can be  evaluated before exporting the selected configuration hardware file and program binary. The final implementation can then be generated by processing the configuration file and the rest of the RTL processor description with standard tools such as Synplicity and/or Xilinx ISE. \r\n", "\n        ", "\n            Toolset (compiler, cycle accurate model and analysis tools) available at ", " VHDL configurable processor description, VHDL testbench, FPGA prototype implementation using the PCI bus also available together with the original design team. The cycle accurate simulator supports all the features. The open-source RTL version is free for academic and research purposes and currently supports a single integer pipeline with 16x16 macroblocks. See it working at ", " . The commercial version RTL supports all the features\n        "]},
{"details": ["\n    Name: mkjpeg", "\n    Created: Mar  7, 2009", "\n    Updated: Jan 28, 2018", "\n        SVN Updated: Oct  3, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 17 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            31 MAY 2017\r\n", "License type changed from LGPL to MIT License.\r\n", "\r\n", "21 AUG 2011\r\n", "New revision 70. contains new BUF_FIFO contributed Ahmet Tekyildiz which needs circa 9.5 line buffer but achieves performance very close to old design with ~16 lines (8 extra lines). So it heavily reduces on-chip RAM utilization without performance sacrifice.\r\n", "Also this version contains nearest integer rounding in DCT-2D instead of truncation when bit growth/precision is reduced. Truncation caused 8x8 block artifacts easily visible in very high quality modes (>95% quantization tables). Rounding alleviates this problem.\n        ", "\n            Warning! WebSVN does not work correctly for project, use link below to download latest rev:\r\n\r\n\u2022       ", "\r\n\r\n\r\n\r\n\u2022\tEV_JPEG_ENC core is intended to encode raw bitmap images into JPEG compliant coded bit stream. JPEG baseline encoding method is used.\r\n\r\n\r\n\u2022\tLICENSE: GNU LGPL v3.0\r\n\r\n\n        ", "\n            \u2022\tJPEG baseline encoding JPEG ITU-T T.81 | ISO/IEC 10918-1\r\n", "\u2022\tStandard JFIF header v 1.01 automatic generation\r\n", "\u2022\tColor images only (3 components, RGB 24 or 16 bit, YUV input)\r\n", "\u2022\tTwo programmable Quantization tables\r\n", "\u2022\tHardcoded Huffman tables (luminance and chrominance)\r\n", "\u2022\t2.3 to 2.7 clock cycles per one input 24 bit pixel @ 50% Quality\r\n", "\u2022\tOPB programming and data Host interface\r\n", "\u2022\t4:2:2 subsampling\r\n", "\u2022\tSource code target independent, synthesizable RTL VHDL code\r\n", "\u2022\tDetailed documentation\n        ", "\n            Example throughput\r\n", "\r\n", "Measured from JPEG encoding start till encoding done:\r\n", "\r\n", "\u2022\tInput image 640x480 24 bit RGB color. New sample loaded every cycle until FIFO full.\r\n", "\u2022\tQuantization tables at 50% quality setting\r\n", "\u2022\t7.3 ms processing time @ 100 MHz clock\r\n", "\u2022\t1000/7.3=136 frames per second @ 100 MHz\r\n", "\u2022\tInput file size = 921 kB. Output file size = 44 kB (depends on image)\r\n", "\r\n", "Compression stats (from JPEGSnoop software):\r\n", "\u2022\tCompression Ratio: 21.31:1\r\n", "\u2022\tBits per pixel:     1.13:1\r\n", "\r\n", "\r\n", "100 MHz is achievable under Stratix II S90 for example. Optimization set to performance.\n        ", "\n            \u2022\treplace OPB interface used for programming with PLB or WishBone\r\n", "\n        ", "\n            ", "\n        ", "\n            Here is a quite detailed low level design document for the Core:\r\n", "\r\n\n        ", "\n            EV_JPEG_ENC is software released under Lesser GPL license and can be used freely for commercial and noncommercial purposes under NO WARRANTY. \r\n", "\r\n", "\n        ", "\n            Device Utilization Summary for Stratix II S90 (mkjpeg revision 57)\r\n", "\r\n", "6135 ALUTs\r\n", "3095 registers\r\n", "3858 ALMs\r\n", "4    DSP9\r\n", "55   M4K\r\n", "1    MRAM\r\n", "   \r\n", "Performance: above 100 MHz\r\n", "\r\n", "Build configured for maximum image width 640 pixels and highest performance and memory usage (settable in JPEG_PKG.VHD)\n        "]},
{"details": ["\n    Name: interface_vga80x40", "\n    Created: Nov 16, 2007", "\n    Updated: Jul 11, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This VHDL macro is a Text Mode Monochrome Video Display Adapter for VGA monitors. It can be used as a peripheral for a soft-processor, external microcontroller or other non-programmable hardware. It's not much better than the original IBM MDA card appeared in 1981 ;-)\n        ", "\n            - resolution is 80x40 characters, dot resolution is 640x480 pixels at 60Hz so the core needs a clock signal of 25MHz. I prefer 80x40 instead the classical 80x25, in my opinion, the latter is an annoyance.\r\n", "- monocrome, it hasn't \"attribute\" memory to store the color of each character. The unique output color is selectable among 8 different colours\r\n", "- the video text buffer is an external memory (or BRAM inside the FPGA) of 80\u00d740 = 3200 bytes. The character at (column, row) = (0, 0) is at the RAM address 0, the character at (79, 39) is at 3199. \r\n", "- 8-bit ASCII codes (iso-latin-0 or other that you prefer)\r\n", "- the ROM that store fixed-width bitmap font is also external, the bitmap can be changed modifying the COE file. The COE file provided is iso-8859-15 (also called iso-latin-0), is very similar to the iso-8859-1 but with the Euro (\u20ac) symbol added.\r\n", "- hardware cursor, with two different shapes; with enable/disable control.\r\n", "- simple IO interface. Three registers\r\n", "  -  CRX. Position (column) for HW cursor\r\n", "  - CRY. Position (row) for HW cursor\r\n", "  - CTL. Control register for de/activate the HW cursor, change its shape, de/activate VGA signal, output colour, etc. \r\n", "- uses 100 slices in a Xilinx Spartan-3.\r\n", "- the design is vendor-agnostic. You can use it in Xilinx/PicoBlaze, Altera/NIOSII or with other non-programmable hardware. \n        ", "\n            You can find the documentation for this macro in the downloads section and also at ", ". \r\n\r\n\r\n\n        ", "\n            See \"Downloads\" in the menu bar. There is VHDL design files plus documentation.\n        "]},
{"details": ["\n    Name: jpeg", "\n    Created: Jan  3, 2005", "\n    Updated: May  9, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This project features a complete JPEG Hardware Compressor (standard Baseline DCT, JFIF header) with 2:1:1 subsampling, able to compress at a rate of up to 24 images per second at the maximum resolution 352x288 (on XC2V1000-4 @ 40 MHz).\r\n \r\nIMAGE RESOLUTION IS LIMITED TO 352x288. It takes an RGB input (row-wise) and outputs to a memory the compressed JPEG image with headers.\r\n\r\nA testbench has been made that takes a bitmap image from your computer and writes a compressed JPEG file by simulating the code.\r\n\r\nIn order to be able to run the project you must first generate the RAM/ROM cores and the DCT2D core with Xilinx CoreGen. The configuration values are listed at the bottom of the file compressor.vhd.\r\n\r\nIf you run into any problems downloading the files from the cvs please check that you are downloading them in binary form. For any questions my email is:\r\n victor.lopez [(at)] ono [(dot)] com\r\n\r\nPLEASE NOTICE THAT THIS CORE IS LICENSED UNDER http://creativecommons.org/licenses/by-nc-sa/3.0/ (Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported). That means you may use it only for NON-COMMERCIAL purposes.\r\n\r\n", "\r\n\n        ", "\n            - JPEG (ISO standard compliant)\r\n", "  - Baseline DCT\r\n", "  - Huffman Encoding\r\n", "  - JFIF Header\r\n", "  - Three quantization (compression) levels\r\n", "\r\n", "- Hardware resources\r\n", "  - Xilinx Coregen DCT core (2D Forward DCT, needs to be generated)\r\n", "  - Total BlockRAMs: 11\r\n", "  - Total LUTs: 3969 (38% of XC2V1000-4)\r\n", "  - Clock Freq: 41.2 MHz for XC2V1000-4\r\n", "  \n        "]},
{"details": ["\n    Name: lcd1", "\n    Created: Jun 17, 2008", "\n    Updated: Sep 12, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Simple memory mapped, character type dot matrix LCD controller for interfacing the Samsung's KS0073.\r\n", "The controller supports the 40SEG extension driver providing a 4-line x 20 character display. It uses a memory mapped 4x20x8 bit matrix, transformed in real-time to the display.\r\n", "It completely takes the responsibility for sending the appropriate sequences of commands to the KS0073. The higher layer needs only to take care of the content of the matrix. This makes its implementation as a microcontroller peripheral unit very comfortable.\r\n", "\n        ", "\n            - generic parameterizable features\r\n", "  - Timing parameters \r\n", "  - cursor modes \r\n", "- additional files and scripts\r\n", "  - testbench written in VHDL\r\n", "  - Makefile for\r\n", "    - synthesis with XST (Xilinx) \r\n", "    - simulation with Modelsim (Mentor Graphics)\r\n", "\r\n", "\n        ", "\n            - The project is completed, but further improvements are always welcome. \r\n", "- The project is written after only 3 months of VHDL experience, so even though verified, extra caution is required when using it in serious projects.\r\n", "\n        "]},
{"details": ["\n    Name: mb-jpeg", "\n    Created: Jun 12, 2006", "\n    Updated: Aug 25, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            - Baseline JPEG encoder\r\n", "- Baseline JPEG decoder (Not ready yet)\n        ", "\n            This is an open source JPEG codec, including both encoder and decoder (decoder is not ready yet), for embedded systems. It can be fully synthesized and implemented on FPGA. There is also a four-processor design based on it ", "\r\n", "\r\n", "Different to a fully hardware implementation, this JPEG codec is designed based on Xilinx Microblaze processor with customized hardware accelerators. It is expected to achieve high flexibility, low complexity at little cost of size and performance. We aim to archive real time motion JPEG codec on a Xilinx Spartan X3S1000 equivalent FPGA (including I/O and memory controller). **\r\n", "\r\n", "You can open the project with Xilinx EDK7.1 or higher and synthesize by Xilinx ISE7.1. * The verification hardware platform I use is Xilinx XUP board with a Xilinx XC2V30P on it. It provides necessary peripherals such as CF card for image storage and video output. The board can be obtained at the cost of 300 euro if you are in a university. Simulation is not tested yet.\r\n", "\r\n", "The code here includes two parts, a JPEG codec library and a test bench. The library includes both hardware and software. The test bench is to read a BMP file from CF card, drive JPEG code library to compress it and write the JPG file back to CF card. You can also make your own design to play with camera and video output based on it.\r\n", "\r\n", "The JPEG codec library can also be used as a library or IP core for image processing and video compression applications, for instance, MPEG codec. The IP cores can be integrated immediately. It is actually part of my master thesis project and I try to write down in detail how I design and how to use it. Enjoy!\r\n", "\r\n", "* Some intermediate version can only be open and synthesized by Xilinx EDK 8.1 and ISE 8.1, as indicated respectively.\r\n", "** X3S1000: 1M Gates, 1920 CLBs, 432Kbits BRAM, Current implementation: 3460 CLBs, 589Kbits BRAM\r\n", "\r\n", "*** Call for Participation ***\r\n", "The accelerator is not done yet. It would be a nice project for university students or engineers who is interested in FPGA design. Please drop me an email if you like to join.\r\n", "\r\n", "\n        ", "\n            For encoder\r\n", "1. Setup the testbench and development environment\r\n", "1.1 Simple environment with CF card and without external memory *\r\n", "1.2 Full environment with CF card and external memory *\r\n", "2. Port reference code to microblaze \r\n", "2.1 Port code to XUP2PRO platform and microblaze processor *\r\n", "2.2 Elaborate code for memory and platform independance *\r\n", "2.3 Elaborate code for multiprocessor support\r\n", "2.4 Elaborate code for multitask OS support\r\n", "2.5 Elaborate code for speed\r\n", "3. Design a simple FSL accelerator to evaluate the FSL design flow \r\n", "3.1 Design a FSL accelerator for MAC operation *\r\n", "4. Design DCT FSL accelerator\r\n", "4.1 Update Fast DCT algorithm ( 4.2 Design Accelerator\r\n", "5. Design color conversion accelerator\r\n", "6. Design vlc accelerator\r\n", "7. Port code into and optimize for different platforms\r\n", "7.1 Port to Xilinx Spartan III board\r\n", "7.2 Add Subsampling support *\r\n", "8. Experiment for Motion JPEG streaming\r\n", "9. Start to design MPEG codec... :)\r\n", "\r\n", "A project to design multiprocessor system on FPGA is based on this design. It  can be found at ", "\r\n", "\r\n", "For decoder, it is roughly the same.\r\n", "\r\n", "* Done\r\n", "\r\n", "\n        ", "\n            1. 2006/07/05 Step 1.1 - Setup the testbench and development environment/Simple environment with CF card and without external memory (Sunwei) CVSTag: STEP1_1 (EDK/ISE8.1)\r\n", "\r\n", "2. 2006/07/18 Step 2.1 - Port reference code (Joris van Emden) to Microblaze and XUP2PRO board (Sunwei) CVSTag: STEP2_1b (EDK/ISE8.1)\r\n", "\r\n", "You can download this bitstream to an Xilinx XUP2PRO board with CF card and it can compress image01.bmp on CF card to image01.jpg and write back to CF card. Due to current implementation limit, the BMP file size can not exceed 64KB for this version of bitstream. It is fixed later.\r\n", "\r\n", "3. 2006/07/20 Step 3.1 - Design a FSL accelerator to do MAC operation (Sunwei)  (EDK/ISE8.1)\r\n", "\r\n", "4. 2006/07/28 Step 2.2 - Elaborate code for memory and platform independance. \r\n", "The code is elaborated and memory usage is reduced. The code can also be compiled and run on PC without any modification. (Sunwei) CVSTag: STEP2_2b (EDK/ISE8.1)\r\n", "\r\n", "The code size is reduced 30% and data size 50%. Now with the same capacity to V0.1 code it need only 32KB code and 32 KB data memory for microblaze processor on FPGA, compared to 64KB code plus 64KB data in V0.1 design. The software code is platform independant and can be compiled on PC as well.\r\n", "\r\n", "5. 2006/09/15 Step 7.2 - 4:2:0 Subsampling support. The compression ratio is doubled. (Marcel) CVSTag: STEP7_2 (EDK/ISE8.1)\r\n", "\r\n", "1) 4:2:0 Subsampling is supported and the compression efficiency is doubled.\r\n", "2) Reduce file system resource usage. For xilfatfs, CONFIG_BUFCACHE_SIZE 2560 (default 10240), CONFIG_MAXFILES 2 (default 5), CONFIG_WRITE true (default false)\r\n", "\r\n", "6. 2006/11/04 Step 1.2 - Add external memory support (Sunwei) CVSTag: STEP1_2c\r\n", "\r\n", "The BMP file buffer is set to external memory and limitation is as large as 256MB if you use 256MB memory module. Code and data except for BMP file buffer is still in on-chip memory.\r\n", "\r\n", "\r\n", "\n        ", "\n            Bitstreams are in CVS/bitstreams directory (", " To download a bitstream to Xilinx XUP2PRO board, you can use impact -batch download_XUP2PRO.cmd in EDK shell. Please note that the bit file to download is set in cmd file for the latest version. If you need to download an old version, it is necessary to modify cmd file.\r\n", "\r\n", "Source files can be downloaded from the 'Downloads' tab (", "\r\n", "\r\n", "1. V0.1 2006/07/19 (CVSTag Step2_1b)\r\n", "2. V0.11 2006/07/28 (CVSTag Step2_2b)\r\n", "3. V0.2 2006/09/15 (CVSTag Step7_2)\r\n", "\r\n", "\n        ", "\n            There is a brief description of the project (", "\r\n", "\r\n", "and my master paper\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: nova", "\n    Created: Apr 21, 2008", "\n    Updated: Jun  3, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Nova is a low-power realtime H.264/AVC baseline decoder of QCIF resolution, targeting mobile applications. It is a dedicated, full hardwired and self-contained ASIC design without utilizing any GPP/DSP cores. It has been successfully verified on Xilinx Virtex-4 FPGA and 0.18um ASIC chip. The measured power consumption is 293uW@1V for 30fps QCIF decoding.\r\n", "\r\n", "From  April 30 2008, Ke Xu has the Copyright for nova. If you have interests of continuing to develop this core or implementing in commercial product, please drop me an email (eexuke@yahoo.com) for discussion.\n        ", "\n            1.RTL coded in Verilog-HDL.\r\n", "2.Support real-time H.264/AVC baseline decoding of QCIF resolution. Can be extended to higher resolutions via minor modifications.\r\n", "3.Extensively pipelining & parallelism are utilized to improve the performance and reduce power.\r\n", "4.Hybrid and self-adaptive pipeline architecture to avoid unnecessary stall cycles and to improve performance:\r\n", "-Self-adaptive pipeline for both intra and inter prediction.\r\n", " -4\u00d74/16\u00d716 hybrid pipeline.\r\n", " -1\u00d74 pixel column-level parallelism. \r\n", "5.Low cost intra prediction unit:\r\n", "-Self-adaptive pipeline.\r\n", "-Hierarchical memory organization to reduce external memory access.\r\n", "-\u201cSeed\u201d method for plane mode computation.\r\n", "-Exploring data reuse between 1\u00d74 columns.\r\n", "-Multi-function Processing Elements for all intra prediction modes processing. \r\n", "6.Optimized motion compensation (inter prediction) unit:\r\n", "-Self-adaptive pipeline.\r\n", "-Hierarchical memory organization to reduce external memory access.\r\n", "-\u201cVariable-block-shape\u201d to reduce redundant memory access and improve throughput.\r\n", "-On-chip reference pixel buffer to explore reference pixel reuse.\r\n", "-Pipelined and parallelized luma interpolator, consisting of 9 horizontal 6-tap filters, 4 vertical 6-tap filters, and 4 bilinear filters.\r\n", "-Innovative chroma interpolator utilizing smallest number of adders.\r\n", "7.High performance deblocking filter:\r\n", "-Innovative 5-stage pipeline architecture with data/structure hazards carefully managed.\r\n", "-Single-port SRAM based, no dual/two-port SRAM required.\r\n", "-204cycles/MB throughput with max. frequency of 200MHz (0.18\u00b5m process). Can deliver up to 980kMB/s throughput.\r\n", "8.Manually inserted latch-based clock gating to reduce power.\r\n", "9.Low-power, low-cost design:\r\n", "-Requires only ~1.5MHz for QCIF 30fps real time decoding.\r\n", "-Only 169k logic gates.\r\n", "-Measured power consumption as low as 293\u00b5W@1V in 0.18um process.\r\n", "\n        ", "\n            ----------------\r\n", "2009-08-11\r\n", "----------------\r\n", "For better understanding of nova design, you can refer to the following documents:\r\n", "1) Ke Xu, \"Power-efficient Design Methodology for Video Decoding\", PhD thesis, The Chinese University of Hong Kong, 2007.\r\n", "2) Ke Xu, T. M. Liu, J. I. Guo, C. S. Choy, \u201cMethods for Power/throughput/area Optimization of H.264/AVC Decoding\u201d, Journal of Signal Processing Systems, 2009, DOI 10.1007/s11265-009-0408-6. \r\n", "3) Ke Xu, C. S. Choy, \u201cA 5-stage Pipeline, 204 Cycles/MB, Single-port SRAM Based Deblocking Filter for H.264/AVC\u201d, IEEE Transactions on Circuits and Systems for Video Technology, vol. 18, issue 3, pp. 363 \u2013 374, 2008.\r\n", "4) Ke Xu, C. S. Choy, \u201cA Power-efficient and Self-adaptive Prediction Engine for H.264/AVC Decoding\u201d, IEEE Transactions on VLSI Systems, vol. 16, issue 3, pp. 302 - 313, 2008.\r\n", "5) Ke Xu, C. S. Choy, C. F. Chan, K. P. Pun, \u201cPower Efficient VLSI Realization of Complex FSM for H.264/AVC Bitstream Parsing\u201d, IEEE Transactions on Circuits and Systems, Part II, vol. 54, issue 11, pp. 984 \u2013 988, 2007. \r\n", "6) Ke Xu, C. S. Choy, C. F. Chan, K. P. Pun, \u201cPriority-based Heading One Detector in H.264/AVC Decoding\u201d, EURASIP Journal on Embedded Systems, vol. 2007, Article ID 60834.\r\n", "7) Ke Xu, C. S. Choy, \u201cLow-power H.264/AVC Baseline Decoder for Portable Applications\u201d, International Symposium on Low Power Electronics and Design, pp. 256 - 261, Sept. 2007, Oregon, USA.\r\n", "\r\n", "You may send me an email to ask for my PhD thesis, while you can find other documents by Google or from IEEE website.\r\n", "\r\n", "----------------\r\n", "2009-04-04\r\n", "----------------\r\n", "The design of a multi-standard (MPEG-2/H.264/VC-1, may even include Chinese AVS) decoder which supports QCIF to HDTV 1080p resolution is launched. The decoder is based on original nova core and is scheduled to complete at the end of 2009 (or early 2010). Any interests of license this high-performance/low-cost/low-power IP, please contact me at eexuke@yahoo.com for more details.\r\n", "\r\n", "----------------\r\n", "2008-05-02\r\n", "----------------\r\n", "Specification, test files added.\r\n", "\r\n", "----------------\r\n", "2008-04-30\r\n", "----------------\r\n", "Verilog source code updated. Detailed specifications, documents, and test files to be updated soon.\n        "]},
{"details": ["\n    Name: vgafb", "\n    Created: Aug  6, 2010", "\n    Updated: Aug  7, 2010", "\n        SVN Updated: Aug 24, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\r\n", "\r\n", "\n            "]},
{"details": ["\n    Name: color_converter", "\n    Created: Aug 28, 2006", "\n    Updated: Feb 23, 2015", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: vhld_tb", "\n    Created: Mar 27, 2007", "\n    Updated: Sep  4, 2014", "\n        SVN Updated: Aug 19, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            The VHDL test bench is a collection of VHDL procedures and functions which allow the user to create their own scripting instructions for test stimulus.  The stimulus script or test case contains the instructions in a regular ASCII text file. The function of the instructions is coded in VHDL as part of the test bench.  The test bench VHDL package contains procedures to create instructions, read, parse and execute the test script (stimulus file, test case, script).\r\n", "\r\n", "-------------------------------------------\r\n", "June 10, 2009\r\n", "This update of the Overview page was to clean up the duplicate text.  An update fixing a current bug report, and request will happen shortly.\r\n", "\r\n", "--------------------------------\r\n", "June 20, 2009\r\n", "Commit fix to variable addition/validation bug  here: ", "\r\n", "Update example to match the package version     here: ", "\r\n", "\r\n", "----------------------------------------\r\n", "April 19, 2014\r\n", "Commit the VHDL Test Bench Package as is released on my privet download site.\r\n", "This includes one minor fix, and one upgrade to enable an undefined number of parameters for a command.\r\n", "Also, another example and a code snips file with more examples and code to copy.\r\n", "Open Office does not enable the output of PDF files (my latest version ..), so only Open Office output is\r\n", "included for the documentation.  Details of the changes are document.\r\n", "\r\n", "The ttb_gen_gui tool has also been updated to enable more VHDL syntax parsing.  Multi pin definitions\r\n", "on a single line are now supported.\r\n", "\r\n", "----------------------------------------\r\n", "Aug. 19 2014\r\n", "Change licensing of the VHDL Test Bench Package to BSD-2 clause\r\n", "Remove duplicate copies of package files from packet_gen example\r\n", "Remove old versions of ttb_gen application, rename most recent version to ttb_gen_gui\n        ", "\n            I have started a Blog at this link:\r\n", "\n        "]},
{"details": ["\n    Name: prbs_suite", "\n    Created: Apr 15, 2011", "\n    Updated: Dec  3, 2011", "\n        SVN Updated: Jul 18, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: bw_tiff_compression", "\n    Created: Nov 28, 2013", "\n    Updated: Jan 20, 2014", "\n        SVN Updated: Jan  7, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project considers a hardware implementation of the CCITT group 4(also known as fax4 or tiff) compression algorithm written in vhdl. The design as it is available compresses camera data into tiff format and transmits over RS232 to a graphical client application developed in C++,Qt that stores the received tiff stream into a file and displays the image. The design is developed and tested on the Digilent Nexys2-1200(spartan-3E) and Atlys(spartan-6) board in combination with the Aptina MT9D131 Image Sensor Headboard.\r\n", "\r\n", "Future extensions: Region of interest coding and change coding.\n        "]},
{"details": ["\n    Name: jtag_stapl_player", "\n    Created: Mar 28, 2015", "\n    Updated: Apr  3, 2015", "\n        SVN Updated: Mar 30, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Converts Raspberry Pi into a JTAG programmer (STAPL protocol). Supports two JTAG chains through 26-pin RPi GPIO P1 connector. The TCK rate is ~1MHz. Works reliably for distance up to 1m, with LVDS level converter tested successfully for distance up to 15m. \r\n", "Ported from Actel STAPL Player v1.1, which is based on JAM STAPL Player v2.2.\n        "]},
{"details": ["\n    Name: uart2bus_testbench", "\n    Created: Jan 24, 2016", "\n    Updated: Jun 22, 2017", "\n        SVN Updated: Jul 22, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Uart2BusTestBench is implemented using Universal Verification Methodology to perform the functional verification to the RTL design released by Moti Litochevski and Steve MULLER (check this ", " ). ", " ", "\r\n", "\r\n", "\n            ", "\r\n\r\n", "\r\nYou can download The Architecture Specifications from ", "\n        ", "\n            "]},
{"details": ["\n    Name: logicprobe", "\n    Created: Dec 20, 2013", "\n    Updated: Apr 22, 2017", "\n        SVN Updated: Nov 13, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Moved to GitHub.\n        ", "\n            LogicProbe is a very simple logic analyzer which can be run on\r\n", "an FPGA in parallel with the \"device under test\". The analyzer\r\n", "has a width of 128 data channels, and is 512 samples deep. It\r\n", "has a trigger (i.e., it starts catching the channels when this\r\n", "signal got active once), and a sample enable (i.e., it does only\r\n", "sample the channels when this line is 1). It uses the block RAM\r\n", "on the FPGA to store the samples in real-time. When the sample\r\n", "buffer is full, it begins to transmit the samples through a UART\r\n", "(also included in the code) over the serial line to a PC where\r\n", "the sample values are stored in a file. A simple listing program\r\n", "allows to view the samples as hexadecimal values.\r\n", "\n        "]},
{"details": ["\n    Name: pltbutils", "\n    Created: Apr 14, 2013", "\n    Updated: Jan 26, 2016", "\n        SVN Updated: Jan 26, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "PlTbUtils makes it easy to create automatic, self-checking simulation testbenches, and to locate bugs during a simulation.\r\nIt is a collection of functions, procedures and testbench components that simplifies creation of stimuli and checking results of a device under test.", "\r\n", "It is intended that PlTbUtils will constantly expand by adding more and more functions, procedures and testbench components. Comments, feedback and suggestions are welcome to pela.opencores@gmail.com .", "Project web page: ", "\r\nSubversion repository URL: ", "\r\nSubversion export command: ", "\r\n", "See the ", "\n            ", "During a simulation, the waveform window shows current test number, test name, user-defined info, accumulated number of checks and errors. When the error counter increments, a bug has been found in that point in time.", "The transcript window clearly shows points in time where the simulation starts, ends, and where errors are detected. The simulation stops with a clear SUCCESS/FAIL message, specifically formatted for parsing by scripts.", "The testcase code is compact and to the point, which results in less code to write, and makes the code easier to read, as in the following example."]},
{"details": ["\n    Name: highload", "\n    Created: May 13, 2014", "\n    Updated: Feb  4, 2016", "\n        SVN Updated: Feb  4, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            The project is intended for checking FPGA-based device for high consumption power.\r\n", "Number of parameter gives possibility to change number of used LC/DFF, DSP, RAM and I/O.\r\n", "It can operate at 200 MHz in Cyclone 5E FPGA.\r\n", "1 LC core is about 1500 LUT4/FF (with default parameters)\r\n", "1 DSP core is 7 DSP 18*18.\r\n", "Each LC core also demands 4*N RAM blocks (32 bits width).\r\n", "\r\n", "To maximize power consumption:\r\n", "1) Find parameters for maximum FPGA resource usage\r\n", "2) Fed maximum frequency clock to CLK input (directly or via PLL instantiated in top level)\r\n", "3) Fed random data to inputs (lower ADC bits or data from PRBS generator)\r\n", "4) Connect maximal outputs count. Be careful: They are switching simultaneously.\r\n", "\r\n", "**** USE HIGH LOAD PROJECT AT YOUR OWN RISK ****\r\n", "\r\n", "Update of 2016-02-04\r\n", "I found that some compilers have limit to maximal vector size. For example, \r\n", "Vivado crashes with more than 16k bits. I have reached that limit for Kintex \r\n", "Ultrascale devices. So you can use LC_RECURSION parameter to build LC components \r\n", "recursively. It gives possibility to decrease vector size at top level.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: hasm", "\n    Created: Nov 23, 2005", "\n    Updated: Oct 19, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            HASM is a simple instruction simulator for use in the verification of FPGA/CPLD designs that must attach to a processor bus. HASM is meant to attach to a bus model that mimics the device attached to the FPGA or CPLD under test. HASM can be used as though it were a processor within the simulation environment without the tremendous increase in simulation times due to the overhead involved in simulating a real processor. \r\n", "\r\n", "The HASM instruction simulator is comprised of two components: a Windows-based IDE and a VHDL module capable of reading the vector file generated by the HASM IDE. HASM 'programs' are written using assembler-like instructions. These instructions include Calls and Jumps to allow the testbench vector listing to be traversed linearly or recursively. \r\n", "\r\n", "HASM is meant to attach to a bus-specific VHDL core. The HASM VHDL module incorporates a simple, generic bus to ease the creation of the bus-specific module. This generic bus supports single and burst-oriented accesses. In addition, the HASM core contains an interrupt line that causes the HASM core to jump to a user-defined location in the HASM source program.\r\n", "\r\n", "Currently HASM has completed bus models for VME bus, Marvell Discovery Device Bus, Xilinx's IPIF bus, Analog Devices' ADSP-21160 Sharc bus and the 68K-based Motorola QUICC.\n        ", "\n            - Instruction-Based Testbench Vector Generator\r\n", "  - Includes Instructions to Alter Vector Flow:\r\n", "     - Call, Jump, Return\r\n", "  - Comparison Instructions Useful in Verification of DUT responses:\r\n", "     - Compare Less, Compare Greater, Compare Equal\r\n", "  - Single and Burst Oriented Data Transfer Instructions \r\n", "  - Stack Based Instructions\r\n", "     - Push, Pop\r\n", "  - Boolean Instructions\r\n", "     - AND, OR\r\n", "  - Math Instructions\r\n", "     - Add, Subtract\r\n", "  - Interrupt Support\r\n", "     - Single Interrupt Input to HASM Module\r\n", "     - .ORG Directive for Creation of a Interrupt Service Routine in Vector File\r\n", "\r\n", "- Four General Purpose Registers\r\n", "- One General Purpose Register Routed out of HASM Module to be used as GPIO\r\n", "- Internal 256-word Scratch-Pad memory for Burst data Storage and Verification\r\n", "- 8 bit, 16 bit, 24 bit and 32 bit Transactions Alterable by Instruction Modifiers (wr.b, wr.w, rd.b, rd.w)\r\n", "- Currently Executing Instruction Visible within Simulator (allows vector file debug)\r\n", "\r\n", "\n        ", "\n            - HASM Windows GUI Complete\r\n", "- HASM Cycle Simulator Model Complete\r\n", "- Discovery 3 HASM-to-Bus Model Complete\r\n", "- QUICC HASM-to-Bus Model Complete\r\n", "- XILINX IPIF HASM-to-Bus Model Complete\r\n", "- VME Bus HASM-to-Bus Model Complete\n        "]},
{"details": ["\n    Name: workwithfiles", "\n    Created: Dec  9, 2009", "\n    Updated: Jan 14, 2010", "\n        SVN Updated: Jan 14, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            For make stimulus of testbench some times need work with files from VHDL. I think that will be very good if some different stimulus will be in one place. \n        "]},
{"details": ["\n    Name: ezidebug", "\n    Created: Jul 26, 2013", "\n    Updated: Jul 29, 2013", "\n        SVN Updated: Aug 15, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            EziDebug is an easy-to-use versatile logic simulation tool for verification and debugging of digital circuits. It supports inserting scan chains in projects. Furthermore\uff0cmore functions and characteristics will be opened. This manual is intended for users with no previous experience with EziDebug . It introduces you with the basic flow how to set up EziDebug. The example used in this tutorial is a small design written in Verilog and only the most basic commands will be covered in this manual. This manual was made by using Version 1.0 of EziDebug on Windows.\n        "]},
{"details": ["\n    Name: fli", "\n    Created: Oct  4, 2013", "\n    Updated: May 26, 2017", "\n        SVN: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Using ModelSim Foreign Language Interface for c - VHDL Co-Simulation and for Simulator Control on Linux x86 Platform\r\n", "\r\n", "Writing testbenches in VHDL can be very cumbersome. This can be solved by using a programming language with more features that does not need to bother about hardware implementation restrictions. This project demonstrates how plain c can be used for testing. Besides generating Stimuli and Analyze results, optional features, like a control interface and simulation accelerators, have been added to this testbench environment.\r\n", "\r\n", "code can be found on\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: rs232_syscon", "\n    Created: Sep 25, 2001", "\n    Updated: Oct 26, 2017", "\n        SVN Updated: Jul 14, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            rs232_syscon is a synthesizeable soft core that allows debugging of peripherals connected to a Wishbone type of bus. Specifically, it lets the user write and read registers, and send out reset pulses, via an rs232 serial connection to a \"dumb terminal.\" (Such as windows \"hyperterm\"!) It is completely scalable through parameter settings, to accomodate address and data buses of any arbitrary size. Furthermore, the rs232_syscon module can share the Wishbone bus with the master (presumably a processor of some kind). It implements a handshaking protocol with the master to \"request\" the bus. When the master grants access, the rs232_syscon runs bus cycles on its own, to report contents of registers and memory back to the user, in an easy-to-read hexadecimal format. This is very useful when debugging peripherals -- you can set the contents of memory, set up registers, and even use registers to control \"single stepping\" of your target processor. If desired, the rs232_syscon can be the sole master of the Wishbone bus, to perform \"human-speed\" tests on peripherals (set a value, check a result) without having to connect the peripheral to a processor.\r\n", "\r\n", "The \"ack_i\" and \"err_i\" signals of the Wishbone bus are used to determine if the bus cycles are correctly executed. The rs232_syscon module uses a \"watchdog\" timer to determine if \"ack_i\" has arrived too late, and if so, it sends an error indicator back to the host terminal. If \"err_i\" occurs, it also sends back a bus error indicator. The timeout value of the watchdog timer is configurable by parameters to whatever length is needed, and the bus cycles are automatically extended for as many clocks as needed until the \"ack_i\" signal is received. If \"ack_i\" is not used, simply tie it high.\r\n", "\r\n", "The design team of rs232_syscon welcomes any kind of help and feedback on this core. If you are interested in further development of this project, please contact us.\r\n", "\r\n        ", "\n            - This core now supports four basic commands: 'r' (read), 'w' (write), 'f' (fill) and 'i' (initialize = reset).\r\n", "- The read/write/fill commands allow a quantity field, to specify multiple writes or reads (using consecutive addresses).\r\n", "- There are no technology-dependent elements used in this core.\r\n", "- The data bus consists of separate dat_i/dat_o buses.\r\n", "- The core runs at clock speeds above 50MHz on a Lattice LFXP2-5E.\r\n", "- The interface is currently implemented as a large state-machine (no processor is involved.)\r\n", "- The command structure is very simple and \"sparse.\"\r\n", "\r\n", "In the future, a version could be implemented using a small microcontroller core with some integrated software, which would probably be more compact and flexible, with a richer command set. But, since we wanted to use this core to _develop_ microcontroller cores -- well, it was a case of \"which came first, the chicken or the egg?\" We had to start somewhere!\r\n", "\n        ", "\n            - There is a new version of this module which incorporates \"auto_baud_with_tracking\".  It is a feature that allows for any FPGA board clock frequency from 1-100 MHz to be used for different BAUD rates.  There is no calculation needed, it adjusts automatically!\r\n", "- The rs232_syscon module has been used to build and debug a small microcontroller, the \"risc16f84\" project.\r\n", "- A VHDL-2008 version is now available, which shows two asynchronous system controllers, connected to a shared bus through a bus arbiter and bus decoder.  This is a Lattice Diamond project, with simulation included.\r\n", "\n        "]},
{"details": ["\n    Name: wb_lcd", "\n    Created: Mar 13, 2009", "\n    Updated: Mar 14, 2009", "\n        SVN Updated: Jun 14, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            LCD character display controller with Wishbone and memory mapped interfaces. \r\n", "\r\n", "It is compatible with the following parts: Sitronix ST7066U, Samsung S6A0069X or KS0066U, Hitachi HD44780 and SMOS SED1278. \r\n", "\r\n", "It's commonly used to drive several character displays integrated in popular Xilinx development boards such as Spartan 3E Starter Kit from Digilent.\n        "]},
{"details": ["\n    Name: pci_mini", "\n    Created: Feb  5, 2008", "\n    Updated: Aug 17, 2011", "\n        SVN Updated: Jun  1, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a very simple PCI-target to Wishbone-master bridge. \r\n", "PCI-Target only, the bandwidth is quite low, fixed memory-image size (16MB), but it has a very low FPGA logic resource need. \r\n", "This is a single VHDL (old version was verilog) file, so easy to use. \r\n", "\r\n", "The original PCI module is from: Ben Jackson http:www.ben.com/minipci/verilog.php \r\n", "Redesigned for wishbone : Istvan Nagy, Hardware Design Engineer. www.buenos.extra.hu \r\n", "\r\n", "Code variants/versions:\r\n", "----------------------- \r\n", "- Up till v3.3 (verilog) the code was tested on Xilinx Spartan-2/3 FPGAs using XST to synthesise. These versions don't have the automatic read-retry feature implemented, so the software developer has to read every location twice. Files: pci-33.v, sample_timing_constraints.ucf.txt. \r\n", "- V3.4 (verilog) contains modifications to make it work on Actel/Microsemi ProASIC3 FPGAs using Synplify for synthesis, and also implements the automatic read-retry PCI feature. It means that the read transactions are terminated by the target with \"retry\" so next time the host accesses the device with read from the same address will return the right read data and the target terminates with successful access. This effects the software development in a way that we don't have to read every location twice just once. v3.4 was not tested on Xilinx FPGAs. Files: pci_mini-34.v, pci_mini-34_timing_constraints.sdc\r\n", "- v4.0 (VHDL) is completely rewritten from scratch in VHDL. The reason for that was to improve static timing and to avoid strange behaviour of the v3.4 seen on Actel FPGAs with a few certain configurations. For example the input setup time and clock-to-output-delay was reduced from ~10ns to ~3ns. A few features were removed, like address remapping and user-reset-control. This version has to be used with the pci_mini_40_timing_constraints.sdc timing constraints file. This was only tested on Actel ProAsic3 FPGAs.\r\n", "\r\n", "Test results:\r\n", "-------------\r\n", "Tested on hardware: \r\n", "-PCI card (with SP2 FPGA) plugged into an old PC with Pentium-II CPU and VIA VT82C693A+VT82C596B chipset \r\n", "-Custom motherboard designed by me, with the AMD Geode-LX processor, Geode chipset, and a Xilinx Spartan-3 FPGA. \r\n", "-Com-Express carrier board with Intel Atom Z520 processor (on the COMe), and Actel ProASIC3 FPGA (on the carrier). \r\n", "Test software: Hardware-Direct, Read-Write-Everything. \r\n", "FPGA project: a peripheral block, consisting: Wishbone intercon module, CAN controller, some custom peripherals, and the PCI2WB bridge. \r\n", "Although it was working in the 3 test systems, it was not validated against all the specifications of the PCI standard, it means it was not tested with standard compliance test methods (like Agilent PCI excercisers and analyzers). So no guarantee for anything, if you want to use it, you should test it. The 33MHz PCI 2.0 I/O-timing specifications were met (can be seen on the timing reports of the ISE development tool.), guaranteed by the timing constraints in the ucf/sdc files and the development tools. On the Spartan-2 FPGA board, the maximum frequency in the Xilinx-ISE STA result was just a littlebit above the 33MHz target (it was 39MHz) for the whole PCI-wishsbone system (the wishbone system used the PCI clcok too, so it was a single clock-domain synchronous system). The v4.0 on the A3P400 device meets the timing requirements of the PCI-66MHz (post P&R STA report), although it was never tested on 66MHz.\r\n", "\r\n", "Synthesis: \r\n", "----------\r\n", "v3.3: 279 Slices on Xilinx Spartan-3 FPGA. (14.5% logic on SP3-200k)\r\n", "v4.0: 719 Core Cells on Actel ProAsic3 FPGA. (8% logic on A3P400)\r\n", "\r\n", "\r\n", "For simulating the core: generate 2 pci config-write transactions for initializing the bridge: write a base address (multiple of 16MB) to BAR0 at 14h , then enable by writing 7 to address 4h. after this, your transactions (single memory read/write at the address range specified by the base address) will go through the bridge. (devsel timing = \"fast\") \r\n", "\r\n", "My website: www.buenos.extra.hu \r\n", "\r\n", "License: You can use it for anything for free, even to put it into your products and sell those products. thats all. (LGPL) \r\n", "All the files can be found in the SVN view, the web downlaod tab might not contain all project files. \r\n", "\n        ", "\n            - PCI target interface\r\n", "- 16MB memory image\r\n", "- Wishbone master interface\r\n", "- Configurable address translation through a config space user register\r\n", "- Single dword buffering (only 32bit mode is supported)\r\n", "- No burst transactions (mem r/w multiple) supported.\r\n", "- Delayed read request and posted write data transfers. (on v3.3 the reads are not retried automatically, so the user software has to initiate two reads from the same address, for every Dword. v3.4/v4.0 implements auto-retry) \r\n", "- Configurable address translation through a config space user register (v3.3/v3.4 only) \r\n", "- Downstream system control by 8 GPIO signals, throug config space (reset, low power mode..., v3.3/v3.4 only) \n        ", "\n            - finished, tested\n        "]},
{"details": ["\n    Name: dualspartainc6713cpci", "\n    Created: Jul 28, 2005", "\n    Updated: Apr 16, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            A project aimed at providing a DSP/FPGA based development board. \r\n\r\nTesting has begun, so far Power supplies, DSP, FPGAs have been proven to be 100% functional. Testing of the SDRAM and FLASH memories has be started and will require time  for pattern read/write to be completed. \r\n\r\nIf you are interested in this dev kit please contact me by my email address. I will be happy to call/email you back with more details. We have 3 more kits available, but will require assembling (typ. 2 weeks) before they can be shipped. We have not determined a price for kits yet, but reasonable offers will be accepted. \r\n\r\nWe are also working a seconday IDE to the TI CCS to allow lower cost development. This is not a primary task as we have CCS2, but realise that for students/personal use CCS2 is too expensive. We are considering opening a compile farm to allow users to upload a project and receive a compiled a.out file that would be loaded into the Flash via HPI from a PC with download utilities. If you would like to help on this aspect, please contact me by email.\r\n\r\nA datashort is provided at http://www.qortek.com/products.aspx additionally you can contact QorTek for Pricing of Kits. Kit prices are determined to cover parts, pcb and assembly, or partial assembly. Sorry we can't give these away :(\r\n\r\n\r\n", "\r\nSDRAM was tested at full EMIF speed (100Mhz) Initial testing showed no problems.\r\n\r\nEMIF to WB_Master interface implemented. Tested working at 50Mhz, optimitize to work at 100Mhz.\r\n\r\n", "\r\nDSP cards tested in cPCI chassis, and PCI bus testing began!! Working out a few issues between WB master and WB Slave on PCI core.\r\n\r\n", "\r\nDSP and PCI core are talking via WB interface! WB bus speed has been droped to 50MHz due to PCI core timing constraints. A second cPCI communication card developed by QorTek is being programmed with the PCI core and an internal RAM Block for DSP to PCI access testing. \r\n\r\nA few schematic entry errors have been identified and fixed for a REV 1 release. None of the errors are show stoppers! A new release of the schematic will appear soon noting schemitcal errors.\r\n\r\n", "\r\nLots of HDL coding and simulation and in system testing has been done. We are working to release a core for the board to connect the DSP to the PCI Core. \n        ", "\n             - Standalone Operation w/ cPCI Interface\r\n", "   - PICMG 2.0 REV 3.0 ( pending testing ) \r\n", "   - 3U cPCI Card or Standalone operation.\r\n", "   - Daughter Card interface for user defined hardware.\r\n", " - 1 TI TMS320C6713GDP Processor 300MHz\r\n", "   -  ALL GPIOs routed out to Daughter Card and FT256 BGA\r\n", " - 1 Xilinx XC3S1000FG320 BGA ( Main bus interface/arbitrator )\r\n", " - 1 Xilinx XC3SxxxxFT256 (User defined applications )\r\n", "   - All DSP GPIO available, user definable routing to External Interface\r\n", "   - DSP HPI Interface for programming / data exchange\r\n", " - 4 40pin Header Daughter Card interface\r\n", "   - Fully qualified 32bit data/20bit Address bus\r\n", "   - 24 GPIO (SE) or 20 GPIO w/4DP (user definable) 8 Shared with Xinterface\r\n", "   - ALL DSP GPIO Pins available\r\n", " - 1 68Pin (scsi like connector) External Interface/GPIO\r\n", "   - All Signal Routed to FT256\r\n", "   - 48 GPIO SE or 24 GPIO DP\r\n", "   - 1 External Reset thru FPGA\r\n", "   - 1 External Interrupt thru FPGA\r\n", "   - IO Vref, 3.3v, and Ground included.\r\n", " - Multiple Power Supplies for FPGA VCCOs and DSP Core Voltage\r\n", "   - User adjustable. 4A Max (execpt FPGA Vaux)\r\n", "   - DSP Core voltages 1.2, 1.25, 1.4 (support all TI 6713 devices)\r\n", "   - External Interface/GPIO Voltage range 1.2-3.3v in 0.1v increments.\r\n", "   - FPGA Aux 2.5v (1.5A max)\r\n", "   - FPGA Internal 1.8v\r\n", " - Includes Nexus (Altium Designer) JTAG Interface for interface to Nanoboard.\r\n", " - Open to sugestions\r\n", "\r\n", "\n        ", "\n            - Schematic Entry 100% done\r\n", "- PCB Layout/Simulations 95% done\r\n", "- PCB Testing/Assembly 50% done\r\n", "  - PCB Power up testing complete. All Power Supplies working.\r\n", "  - Power routing verified.\r\n", "  - PCB Assembly Started. (Third party assembly)\r\n", "- Software / FPGA code 0% done\r\n", "  - WISHBONE compliant IP Core to Link DSP to PCI Core. 0% Done.\r\n", "  - WISHBONE compliant IP Core to Link Daughter Card IF to DSP/PCI Core.\r\n", "\n        ", "\n            This board is 95% fully assembled.\r\n", "\r\n", "\r\n", "We have begun writing FPGA and DSP code to link the PCI Bridge to the DSP and also allow users to program the DSP from the HPI. \r\n", "\r\n", "More Imganes can be found here (not up to date, yet):\r\n", "\n        ", "\n            http://opencores.org/project,dualspartainc6713cpci,SystemDiagram.jpg\n        "]},
{"details": ["\n    Name: pci32tlite_oc", "\n    Created: Apr 29, 2005", "\n    Updated: Jul  6, 2017", "\n        SVN Updated: Apr 23, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 5 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The PCI32tLite IP core provides the funtionality of a PCI TARGET. The core has been designed to permit interface between a PCI Master and simple WHISBONE Slaves, and fitting into smallest FPGA (about 200 LC's in ALTERA CYCLONE II FPGA).\r\n", "\r\n", "Whisbone databus size and endianess configurable: \"BIG\"/\"LITTLE\",32/16/8 bits.\r\n", "\r\n", "PCI memory or I/O map configurable.\r\n", "\r\n", "Uses BAR0 register; occupies 32Mbytes on PCI memory map or 512Bytes on PCI I/O map.\r\n", "\n        ", "\n            Tested on HW:\r\n", "\r\n", "- ALTERA MAXII Kit.\r\n", "- XILINX Raggedstone1 board.\r\n", "- Other custom HW.\r\n", "\r\n", "PCI32TLITE_OC_HOWTO. Document to evaluate the PCI32TLITE IP Core creating \"maxii_uart\" project:\r\n", "\r\n", "  - Project to create a UART 16550 PCI peripheral using IP Cores from www.opencores.com: \r\n", "    - PCI32TLITE_OC(Peio Azkarate)\r\n", "    - A_VHDL_16550_UART(Howard LeFrevre)\r\n", "    - GH_VHDL_LIBRARY(George Huber and Howard LeFrevre) \r\n", "  - Permits  easy evaluation of the IP on HW.\r\n", "  - Using PCI32TLITE_OC UART with LINUX serial standard driver.\r\n", "\r\n", "\n        ", "\n            R02   2007-09-19:\r\n", "\r\n", "- \"intb\" and \"serr\" signals not defined as TRI. They have to be defined Opendrain in the FPGA (externally to the IP Core).\r\n", "- Small changes due to onalib.vhd improvement.\r\n", "- Removed TIMEOUT. Added wb_rty_i for Target termination with RETRY.\r\n", "- Support Burst Cicles.\r\n", "- Add Whisbone data bus configuration generics: WBSIZE and WBENDIAN\r\n", "- Add wb_adr_o(1..0) signals.\r\n", "- wb_dat_i,wb_dat_o,wb_sel_o size depends on WBSIZE.\r\n", "- Advice: Change WB to/from PCI databus routing for \"BIG\"/16 WB configuration and DWORD PCI transactions (DWORD is not recomended when WB 16 configuration).\r\n", "\r\n", "\r\n", "R03   2008-06-16:\r\n", "\r\n", "- PCI32TLITE_OC_HOWTO Document added and maxii_uart project\r\n", "- Add \"1BARIO\" configuration option for BARS generic.\r\n", "- fix bug with WBENDIAN generic in pciwbsequ.\r\n", "- Change PCI Burts to WB traslation behavior.\r\n", "- Add \"classcode\" generic.\r\n", "- Change BAR0 reset state to \"0\".\r\n", "- Fix pcidmux bug for LITTLE/8 configuration.\r\n", "\r\n", "\r\n", "R04 Next release.Not ready yet.\r\n", "\r\n", "- Add \"pci_\" prefix to PCI Bus signals names.\r\n", "- Change \"rst\" signal name to \"pci_rst\". And change from active High to active Low. Allowing straight-forward connection of the PCI32TLITE Core to PCI bus (without inverter on rst).\r\n", "- Add PCI Can Controller project. Uses PCI32TLITE (Peio Azkarate) and CAN (Igor Mohor) IP Cores from Opencores.\r\n", "- Add Linux driver for PCI Can Controller project.\r\n", "- Add basic Linux driver for PCI32TLITE IP Core.\r\n", "- Some suggestion or wishes contact me. Thanks.\r\n", "\n        "]},
{"details": ["\n    Name: pcie_sg_dma", "\n    Created: Aug 24, 2011", "\n    Updated: Mar 26, 2012", "\n        SVN Updated: Mar 26, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This package involves a PCIe Scatter-Gather DMA engine for Virtex5 and Virtex6.\r\n", "\r\n", "The design implements MAC, Physical (Xilinx Hard and Soft IP Cores) and Transaction Layer (Custom Core) of PCIe. \r\n", "\r\n", "It holds 3 BAR\u2019s, BAR[0], BAR[1] and BAR[2], as its memory space.  Registers are accessed via BAR[0], including the system registers, DMA channel registers and some other control and status registers.  Block RAM are assigned to BAR[1]. BAR[2] contains the FIFO data ports, both write and read. FIFO control and status registers reside in BAR[0]. All 3 applied BARs are accessible with PIO operation (PIO to the FIFO can only access 32 bits of the 64-bit bus).  DMA can only target on BAR[1] and BAR[2], 64-bit full bus.\r\n", "\r\n", "The design was split into two projects: one for Virtex5 (in \"Trunk\" folder) and the other for Virtex6 (in \"branches\" folder).\r\n", "It was fully tested on:\r\n", " - AVNET Virtex5 PCIe Development Board\r\n", " - Xilinx Virtex6 ML605 Development Board \r\n", "\r\n", "Simulation is provided in Verilog HDL for both platforms.\r\n", "\r\n", "The design is composed by some Xilinx IP Cores. Both the VHDL code and the CoreGen .xco file are provided. To change or upgrade them, a valid license for the cores from Xilinx Inc. should be available. The PCIe core is the 1.6 version in ISE12.3 and 1.7 versione in ISE 13.3. The old 1.3 version is also provided.\r\n", "\r\n", "The DMA throughput depends on OS, machine, implementation and packet size:\r\n", "On a Dell Precision T5500 with Linux Debian 2.6.32 64bit we measured:\r\n", "\r\n", "Virtex5 board:\r\n", " - PCIe gen1.0 x4: write: up to 700 MB/s - read: up to 380 MB/s\r\n", "\r\n", "Virtex6 board:\r\n", " - PCIe gen2.0 x1: write: up to 426 MB/s - read: up to 417 MB/s\r\n", " - PCIe gen1.0 x4: write: up to 828 MB/s - read: up to 524 MB/s\r\n", "\r\n", "Another Virtex5 board DMA performance test under Linux achieves\r\n", " - PCIe Gen1 x4: write 790 MB/s; read 543 MB/s (FIFO) or 507 MB/s (BRAM).\r\n", "\r\n", "Linux driver are avaible at: ", " (THX to Dr. Guillermo Marcus)\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: pcie_mini", "\n    Created: Apr 23, 2011", "\n    Updated: Dec 16, 2017", "\n        SVN Updated: Jan 10, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            pcie_mini IP core\r\n", "PCI-express to Wishbone Bridge for Xilinx FPGAs.\r\n", "\r\n", "Developer: Istvan Nagy, Bluechip Technology, 2011\r\n", "\r\n", "Very often we want to make a peripheral card or a peripheral block on an x86 motherboard using an FPGA, but not necesserily want to spend a lot of time on developing common blocks (like a PCI-express interface), we want to focus on our own custom logic design instead and use completely implemented IP cores for the common blocks. The \"mini\" in the name doesn't refer to a minicard formfactor, but it just signifies that the core is small and is implemented as a single VHDL file. This is a simple implementation of a PCI-Express target to Wishbone master bridge. \r\n", "\r\n", "The Xilinx Series-5/6 FPGAs have a built-in PCI-Express Endpoint Block, however it does not contain the packet encoding/decoding logic. This IP core (pcie_mini) implements the missing parts of the Xilinx core and also adds a Wishbone back-end interface. Strangely the Xilinx PCIE-EP handles packet encoding/decoding for configuration accesses, but not for memory accesses. This core interfaces the Xilinx PCIE-EP with its Transaction (TRN) interface. The Xilinx Series-7 FPGAs have a more complete PCIE-EP, but they also support using the TRN interface, but unfortunatelly they only support 64-bit/128bit parallel buses at the moment (November 2011), which would require a redesign of the pcie_mini_core. The user has to use the Xilinx Coregenerator to generate a PCIE-EP wrapper (xilinx source files) for the chosen target FPGA device. pcie_mini still needs the Xilinx PCIE Endpoint block and the GTP transceivers.\r\n", "\r\n", "This core works with a fixed 256Mbytes memory window, only BAR0 is implemented. It was tested with 32/16/8-bit single memory read and write transactions. The data fields in the PCIe packets get endianess-swap by the core, to match the internal 32-bit bus layout with the 32bit variable view in the test software.\r\n", "The core was tested on a x1 PCIe card (custom designed card having Spartan-6 LX45T FPGA on it) with nVidia chipset on the test motherboard, ISE 12.1, RW v1.4.9 (debug program) and Windows-XP (on Windows-7 accessing the core with a debug program without an installed driver is not possible). The wishbone addresses are byte addresses just like the PCI-express addressing. The Wishbone byte enables are derived from the PCIe packets. \r\n", "The output address of the core contails the 2 LSBs as well. The TLP logic is capable of handling up to 1k bytes (256 DWORDs) payload data in a single PCIe transaction, and can handle only one request at a time. If a new request is arriving while processing the previous one (e.g. getting the data from a wishbone read), then the state machine will not process it immediately, or it will hang. So the user software has to wait for the previous read completion before issueing a new request. The multiple data DWORDs in a single TLP generate separate Wishbone transactions. Theoretical Performance: WishBone bus: 62.5MHz, 32bit, 2clk/access -> 125MBytes/sec. Consecutive single write test showed 15.625 MBytes/sec bandwidth, read performance is expected to be a lot lower due to the turnaround time of the read transactions. The maximum data throughput could be achieved when using the maximum data payload size (1kBytes), although it was not tested in lack of such test software. The core uses INTA virtual wire to signal interrupts. It uses a 100MHz ref clock. The The generated Xilinx core had to be edited manually to support 100MHz, as per Xilinx AR#33761.\r\n", "\r\n", "Implementation tips:\r\n", "-make use of the attached UCF file and edit it,\r\n", "-Synthesis-KeepHierarchy=Yes, \r\n", "-Translate-AllowUnmatched_XX_Constraints=Yes\r\n", "-If there are timing errors we still might want to procees to be able to analyze the violation details. For this, we have to set the windows env.variable XIL_TIMING_ALLOW_IMPOSSIBLE to 1.\r\n", "-In the synthesis properties, pack IOB registers = off, Set the \"FSM Encoding Algorithm\" to \"user\". \r\n", "-To make the FPGA-chip to configure in 500ms, set the bitgen option \"config rate\" to 33 (MHz).\r\n", "\r\n", "Resource utilization:\r\n", "(The pci_mini with the xilinx PCIE-EP wrapper files together)\r\n", "540 Slice registers,\r\n", "779 Slice LUTs,\r\n", "10 BRAMs (RAMB16BWER, 22kBytes total)\r\n", "3 BUFGs\r\n", "1 PLL\r\n", "\r\n", "Files (browse CVS):\r\n", "-xilinx_pcie2wb.vhd - this is the pcie_mini IP core\r\n", "-blk_mem_gen_v4_1.vhd and .ngc - this is an internal BlockRam for the pcie_mini\r\n", "-pcie*.vhd and gtpa1*.vhd - these are the wrapper files from the Xilinx CoreGenerator. The user might have to re-generate them in case of using a different FPGA device (these were generated for the XC6SLX45T-2FGG484) or different settings like SS-VID.\r\n", "-pcie_mini_constraints.ucf - example constraints for the core to be included in your chip-level project. It has to be edited by the user.\r\n", "\r\n", "Project Status: \r\n", "All 3 revisions can be found inside the \"\\pcie_mini\\trunk\\main_sources\" directory.\r\n", "(v1.1) Tested and working with 32/16/8-bit single memory reads and writes, also fast consecutive single reads/writes. \r\n", "(v1.2) interrupt fix by Stephen Battazzo\r\n", "(v1.4) 64-bit read fix, support for unaligned 32-bit read, and custom BAR0 address space size. Compatibility for MSI and Legacy interrupts by Scott Cogan, FRIB\r\n", "\r\n", "Test hardware: \r\n", "Custom designed x1 PCIe data acquisition card having Spartan-6 LX45T FPGA on it, nVidia chipset on the test motherboard, ISE 12.1, RW v1.4.9 (debug program) and Windows-XP. The card has its own DDR2 memory and peripherals (200MSPS ADC, DSP, communications interface) that all access to the same DDR2 memory. The PCIe accesses were all accessing either internal control registers or the on-board memory.\r\n", "\r\n", "To-do:\r\n", "-Write a test program to generate bulk/burst read/write transactions where the TLP payload size >> 1 (eg 16Bytes or 1024Bytes). If someone could write such a program, then we could progress with the development to the high bandwidth bulk data transfer support.\r\n", "\r\n", "License: LGPL, you are free to use it and to build it into your products.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: pci", "\n    Created: Sep 25, 2001", "\n    Updated: Jul  4, 2006", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n"]},
{"details": ["\n    Name: wisbone_2_ahb", "\n    Created: Aug  6, 2007", "\n    Updated: Apr 19, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            \n        ", "\n            -  AHB 2.0 compliant\r\n", "-  Wishbone B.3 compliant\r\n", "-  WISHBONE Burst NOT SUPPORTED\r\n", "-  Fully synthesisable\r\n", "-  Synchronous\r\n", "-  Verilog RTL\r\n", "-  Includes a Verilog Testbench with 9 Testcases\n        ", "\n            -  RTL : Complete\r\n", "-  Testbench : Complete\r\n", "-  Document : Complete\n        "]},
{"details": ["\n    Name: system6801", "\n    Created: Aug 22, 2003", "\n    Updated: Mar 10, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            A Wishbone SoC of a 6800/01 CPU based project\n        ", "\n            - Motorola 6800/01 'instruction set' CPU CORE (Object code compatable)\r\n", "- RMCA01 - Relocatable Macro Cross Assembler included (Shareware by M. Hasenfratz)\r\n", "- Tested on Altera Apex20K, Cyclone and Stratix developement boards (NIOS Kits) \r\n", "- All system components have Wishbone Interfaces:\r\n", " - 6800/01 CPU (Core by John Kent)\r\n", " - miniUart/ACIA\r\n", " - miniUart/SCI\r\n", " - Timer / Counter\r\n", " - Programmable I/O (PIO)\r\n", " - 128byte RAM  [Note: uses Altera LPM_RAM encapsulated in WishBone I/F]\r\n", " - 2KB ROM with debug monitor [Note: uses Altera LPM_ROM encapsulated in WishBone I/F]\r\n", " - External SRAM 'wrapper'\r\n", " - External ROM 'wrapper'\r\n", "\r\n        ", "\n            - Wishbone CPU01 CORE, Done\r\n", "- Wishbone miniUart/ACIA (6850 style), Done\r\n", "- Wishbone miniUart/SCI (6801 Serial Communications Interface), Testing\r\n", "- Wishbone Internal Altera LPM_ROM / LPM_RAM 'wrapper', Done\r\n", "- Wishbone External SRAM 'wrapper', Done\r\n", "- Wishbone External ROM 'wrapper', Done\r\n", "- Wishbone PIO (Programmable I/O port), Testing\r\n", "\r\n        "]},
{"details": ["\n    Name: wishbone_out_port", "\n    Created: Jan 27, 2008", "\n    Updated: Jan 29, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Are you using Wishbone, do you need some simple 'slaves' to test your bus with ?\r\n", "\r\n", "Well, the Wishbone spec, appendix B3, has VHDL examples of Wishbone outports, and memories. \r\n", "\r\n", "This is the code from B3 ! saves one copying the PDF each time. \n        ", "\n            - Can be simulated and can be synthesised.\r\n", "\n        ", "\n            Simulated in XST 9.2 sp 4\r\n", "Synthesised to Spartan FPGA.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: mem_ctrl", "\n    Created: Sep 25, 2001", "\n    Updated: Jan 11, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a advanced Memory Controller intended for embedded applications. Some of the features are: \r\n", "\r\n", "- SDRAM, SSRAM, FLASH, ROM and many other devices supported \r\n", "- 8 Chip selects, each uniquely programmable \r\n", "- Flexible timing to accommodate a variety of memory devices \r\n", "- Burst transfers and burst termination \r\n", "- Performance optimization by leaving active rows open \r\n", "- Default boot sequence support \r\n", "- Dynamic bus sizing for reading from Async. Devices \r\n", "- Byte parity Generation and Checking \r\n", "- Multi Master memory bus support \r\n", "- Industry standard WISHBONE SoC host interface \r\n", "- Up to 8 * 128 Mbyte memory size \r\n", "- Supports Power Down Mode \r\n        ", "\n            - May 2002, The core has been verified in hardware. This project is now completed.\r\n", "- 8/2/2001 I have fixed various bugs and made many small changes and am still trying to improve and debug the memory controller further. \r\n", "- New Directory Structure ! We have agreed on a common directory structure at OpenCores. \r\n", "- I will post a message to cores@opencores.org each time I have an update \n        ", "\n            "]},
{"details": ["\n    Name: z80soc", "\n    Created: Apr 16, 2008", "\n    Updated: Jun 24, 2016", "\n        SVN Updated: Jun 24, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            System on chip, based on T80 core.\r\n", "\r\n", "This project is a SOC designed for Altera DE1 development board and the Diligent Spartan 3E, and provide access to leds, switches, buttons, IO pins, SRAM, VGA, LCD and keyboard using Z80 assembly language.\r\n", "Comes with a reference ROM application that show how to access all resources on the board. Spartan 3E port provides easy access to the LCD (memory mapped, 32 bytes of ram).\r\n", "\r\n", "There are tools included in the project files to convert fonts (psf) to MIF and COE, and convert files containing hex codes in VHDL ROM files, what makes it very easy to generate new roms for the system (requires cygwin on windows or linux/unix shell).\r\n", "\r\n", "Primary home page for this project is:\r\n", "\r\n", "\r\n", "Previous versions can also be found at:\r\n", "\r\n", "\r\n", "More information about development here:  ", "\n        ", "\n            All board resources are accessible from Z80 Assembly programs and also using C language.\r\n", "\r\n", "V0.7.3\r\n", "- Some changes to the memory mapping to have all platforms using the same map\r\n", "- C library added to access all available hardware resources \r\n", "- Documentation online at ", "\r\n", "- Added Altera DE2-115 to list of supported development kits\r\n", "\r\n", "V0.7.1\r\n", "- Main change is support for C with release of a basic C library interface with the board resources\r\n", "- Bugfixes in the video design and support for 80x60\r\n", "\r\n", "V0.7\r\n", "- Video layout can now be up tp 80x40\r\n", "- Characters are stored im RAM and can be redefined by the user\r\n", "\r\n", "Features:\r\n", "\r\n", "DE1:\r\n", "- Memory\r\n", "  - 24 Kb RAM (external SRAM) for main memory\r\n", "  - 03 Kb RAM for video memory (display up to 80x40)\r\n", "  - 02 Kb RAM for characters (256 chars), can be redefined by user\r\n", "  - 16 Kb ROM \r\n", "- VGA video out in text mode configurable up to 80x40\r\n", "- PS/2 keyboard input\r\n", "- Seven segment display\r\n", "- 8 Green leds\r\n", "- 8 Red leds\r\n", "- 8 Switches\r\n", "- 4 Push buttons\r\n", "- 36 IO pins (gpio0)\r\n", "- 36 IO pins (gpio1)\r\n", "\r\n", "Spartan 3E:\r\n", "- Memory\r\n", "  - 24 Kb RAM for main memory\r\n", "  - 03 Kb RAM for video memory (display up to 80x40)\r\n", "  - 02 Kb RAM for characters (256 chars), can be redefined by user\r\n", "  - 16 Kb ROM\r\n", "  - 32 Bytes RAM for LCD video memory\r\n", "- VGA video out in text mode configurable up to 80x40\r\n", "- PS/2 keyboard input\r\n", "- LCD display \r\n", "- 8 Green leds\r\n", "- 4 Switches\r\n", "- 5 Push buttons\r\n", "- Rotary Knob\r\n", "\n        ", "\n            - All features listed are now functional\r\n", "\r\n", "- Future improvements under way:\r\n", "    - (done) Video 80x40\r\n", "    - Serial communication\r\n", "    - Monitor program\r\n", "\n        ", "\n            For a detailed list of changes and features, see file RevisionHistory.txt and README file.\r\n", "\r\n", "2010/02/26 - V0.7\r\n", "Modified RAM layout to accomodate new features\r\n", "Characters definition are now in RAM and can be redefined by the user\r\n", "Video screen can now be configured up tp 40 rows by 80 columns\r\n", "Characters can have double pixels (useful when width is less than 40 chars)\r\n", "Memory cores was redefined, RAM is now 24K\r\n", "\r\n", "2008/05/24 V0.6\r\n", "Modified RAM layout to support new and future improvements. \r\n", "Added ports 0x90, 0x91, 0x92 for vram write\r\n", "Changed ROM to support 14 bit addresses (16 Kb)\r\n", "\r\n", "2008/05/14\r\n", "Added support for the Rotary knob on Spartan 3E.\r\n", "Modified the ROM to move LCD text using the Rotary knob.\r\n", "\r\n", "2008/05/12\r\n", "Fixed bug in memory access for S3E. ROM now is almost the same as DE1.\r\n", "\r\n", "2008/05/05\r\n", "Spartan 3E port released, with support for the LCD display.\r\n", "\r\n", "2008/05/01\r\n", "Added Caps lock support. Upper and lower case characters are now supported for keyboard input.\r\n", "\r\n", "2008-04-19 \r\n", "Added complete character set (video out only)\r\n", "Changed ROM program\r\n", "\r\n", "2008-04-16\r\n", "Release of Z80SoC-0.5-DE1-Beta\n        "]},
{"details": ["\n    Name: ac97", "\n    Created: Sep 25, 2001", "\n    Updated: Jul 11, 2011", "\n        SVN Updated: Jul 12, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a AC 97 Controller Core. It provides a an interface to an external AC 97 Audio Codec. This allows the implementation of CD quality Audio Input/Output. \r\n        ", "\n            - AC97 Revision 2.2 Compliant \r\n", "- Variable and Fixed Sample Rate Support, up 48 kHz \r\n", "- 16, 18 and 20 bit Sample Size Support \r\n", "- 6 Channel Surround Sound Support \r\n", "- Stereo Input channel Support \r\n", "- Mono Microphone Channel Support \r\n", "- External DMA Engine Support \r\n", "- WISHBONE SoC host Interface \r\n        ", "\n            - 8/2/2001 New Directory Structure ! We have agreed on a common directory structure at OpenCores. \r\n", "- The AC97 Core is Done ! \r\n", "- I will post a message to cores@opencores.org each time I have an update \n        ", "\n            - 8/2/2001 RU New Directory Structure Update\r\n", "- 19/5/2001 RU First Release\r\n", "- 11/5/2001 RU Added link to the spec.\r\n", "- 3/5/2001 RU Initial web page \n        ", "\n            "]},
{"details": ["\n    Name: ata", "\n    Created: Sep 25, 2001", "\n    Updated: May  6, 2015", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            ATA (AT attachment) interface core, also known as the IDE (Integrated Drive Electronics) interface.\r\n", "The ATA interface provides a simple interface to (low cost) non-volatile memories, like harddisk drives, DVD players, CD(ROM) players/writers and CompactFlash and PC-CARD devices.\r\n", "\r\n        ", "\n            - Three cores are available in VHDL and Verilog from OpenCores CVS via cvsweb or via cvsget. \r\n", "- ToDo: \r\n", "  - Write documentation \r\n", "  - Start development of OCIDEC-4, featuring UltraDMA support\r\n", " \n        ", "\n            The development of a range of software and function backward compatible cores with a growing set of features. Software can detect which version of the core is implemented by reading the Device-ID and Revision-Number from the status register, thus making it possible to use a single device driver to handle all cores. This gives designers/system integraters the ability to trade off complexity/resource usage to available feature set/performance. All cores are designed according to the latest ATA/ATAPI specs.\r\n", "\r\nCurrently three cores are available:\r\n", "\r\n", "Device", "OCIDEC-1", "Features", "Smallest core.", "\r\nPIO transfer support only.", "\r\nSingle timing register for all accesses to the connected devices.", "Intended use", "Single PIO only devices (PC-CARDs, CompactFlash).", "\r\nDesigns requiring ATA capabilities, without the need for a complex feature set.", "Gate usage", "Altera ACEX EPF1k100FC484-1 262lcells@111MHz.", "\r\n", "Device", "OCIDEC-2", "Features", "Small core.", "\r\nPIO transfer support only.", "\r\nCommon timing register for all compatible accesses to the connected devices.", "\r\nSeparate timing register per device for fast DataPort accesses.", "Intended use", "Dual PIO only devices (PC-CARDs, CompactFlash).", "\r\nDesigns requiring fast ATA capabilities, without DMA transfers.", "Gate usage", "Altera ACEX EPF1k100FC484-1: 439lcells@111MHz.", "\r\n", "Device", "OCIDEC-3", "Features", "PIO, Single-Word DMA and Multi-Word DMA transfer support.", "\r\nCommon timing register for all PIO compatible accesses to the connected devices.", "\r\nSeparate timing registers per device for fast PIO DataPort accesses.", "\r\nSeparate timing registers per device for DMA transfers.", "\r\nPIO write access ping-pong.", "\r\nWISHBONE Retry cycles for PIO accesses while controller busy.", "Intended use", "High speed ATA devices (Hard disks, CDROMs)", "\r\nDesigns requiring full featured ATA capabilities.", "Gate usage", "Altera ACEX EPF1k100FC484-1 916lcells@84MHz.", "All cores feature a WISHBONE rev.B2 compliant interface, but can be adapted to any other kind of bus.", "\r\nSee the on-line ", " for more information. \r\nNote: This is a preliminary version. Not an official release."]},
{"details": ["\n    Name: wb_dma", "\n    Created: Sep 25, 2001", "\n    Updated: May 22, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a simple DMA/Bridge IP core. It has two WISHBONE interface. It can perform DMA transfers between the two interfaces or on the same interfaces. \r\n", "\r\n", "Some of the main features are: \r\n", "- Up to 31 DMA Channels \r\n", "- 2, 4 or 8 priority levels \r\n", "- Linked List Descriptors support \r\n", "- Circular Buffer support \r\n", "- FIFO buffer support \r\n", "- Software & Hardware handshake support \r\n", "- Automatic Channel Registers Reload support \r\n", "- Fully configurable \r\n", "\r\n", "Please see the spec for more details ! \n        ", "\n            - 8/2/2001 Added another feature: Now you can backoff to the beginning of the current transfers (this is useful for things like Etherenet, where you might have to restart in case of collisions or errors). \r\n", "- New Directory Structure ! We have agreed on a common directory structure at OpenCores. \r\n", "- I will post a message to cores@opencores.org each time I have an update \n        ", "\n            - 8/2/2001 Added another feature, Directory Structure has changed\r\n", "- 6/6/2001 RU Second Release\r\n", "- 19/3/2001 RU Released Code\r\n", "- 16/3/2001 RU Initial web page \r\n        ", "\n            "]},
{"details": ["\n    Name: wb_builder", "\n    Created: Apr 26, 2004", "\n    Updated: Oct  3, 2014", "\n        SVN Updated: Mar 20, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 8 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            - add verilog output\n        ", "\n            - when data bus size is 8 bits the script generates wishbone sel signals which are of no use\n        ", "\n            - GUI for easy startup\r\n", "- supports both shared bus and csorrbarswitch topology\n        ", "\n            - design tested in HDL simulator and in FPGA (ALTERA C12)\r\n", "- current design only support VHDL output\r\n", "\n        ", "\n            The intention is to provide an easy way to create and change a system based on the WISHBONE bus. The user shall be able to try different configurations to achieve an area/performance optimized design.\r\n", "\r\n", "WISHBONE builder is a script which generates a wishbone interconnect matrix in HDL. The user defines the functionallity of the wishbone bus in a text file or via a GUI. The tools then generates the HDL implementation.\r\n", "\r\n", "The core supports both shared bus and crossbar switch implementations.\r\n", "\r\n", "To run the WISHBONE builder you must have installed PERL. A windows executable can be found at ", " In Linux PERL is usually installed with the system. The GUI uses a PERL module called Tk. Tk can be found at CPAN, ", "\r\n", "\n        "]},
{"details": ["\n    Name: wb_conmax", "\n    Created: Oct 23, 2001", "\n    Updated: Feb 10, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a WISHBONE Interconnect Matrix IP core.It can interconnect up to 8 Masters and 16 Slaves \r\n", "\r\n", "Some of the main features are: \r\n", "- Up to 8 Masters \r\n", "- Up to 16 Slaves \r\n", "- 1, 2 or 4 priority levels \r\n", "- Fully configurable \n        ", "\n            FILE: conmax.jpg\nDESCRIPTION: ", "\n\n        ", "\n            - October 2002, Maintenance update: Fixed a typo in parameter passing and in the specification\r\n", "- May 2002. Several users of the core have reported that the core performs as specified. Project is now considered completed.\r\n", "- 10/19/2001 Initial Release.\r\n", "- I will post a message to cores@opencores.org each time I have an update \n        ", "\n            - 10/19/2001 Initial Reslease\n        ", "\n            "]},
{"details": ["\n    Name: simpcon", "\n    Created: Nov 28, 2005", "\n    Updated: Nov 13, 2007", "\n        SVN Updated: Jun  1, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            SimpCon is a specification for a simple and efficient system-on-chip (SoC) interconnect. SimpCon provides single cycle commands and provisions for pipelining of read and write connections. SimpCon is public domain and freely available.\r\n", "\r\n", "Translation to and from Wishbone, the opencores standard interface, are provided.\r\n", "\r\n", "Documentation is in the CVS at ", "\r\n", "\r\n", "A paper published at the Austrochip on SimpCon is available from:\r\n", "\n        ", "\n            - Synchronous interface\r\n", "- Master/Slave connection\r\n", "- Piplined transactions\r\n", "- Low resource usage\r\n", "- Simple to implement\r\n", "\n        ", "\n            - First draft document written\r\n", "- Master implemented for JOP in Cyclone and Spartan-3\r\n", "- Slave for SRAM access (read pipeline level 2)\r\n", "- JOP IO devices connected as SimpCon slaves\r\n", "- Wishbone/SimpCon bridge available\n        "]},
{"details": ["\n    Name: simple_bus_architecture", "\n    Created: Sep  4, 2012", "\n    Updated: May 17, 2017", "\n        SVN: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            You can download the official library repository from: ", "\n        ", "\n            The Simple Bus Architecture (SBA) is an architecture made up software tools and intellectual property cores (IP Cores) interconnected by buses set through simple and clear rules, that allow the implementation of an embedded system (SoC); additionally, basic templates are provided to achieve a rapid design. Its structure gives it an inherent educative value. The VHDL code that implements this architecture is highly portable. \r\n\r\n", "\r\n\r\nThe master core developed as special state machine, has the ability to perform basic data flow and processing, similar to microprocessor but without the high consumption of logic resources of it.\r\n\r\n", "\r\n\r\nThe SBA is an application and simplified version of the Wishbone specification. The SBA implements the minimum essential subset of Wishbone signals interface, and can be easily connected with simple Wishbone IP Cores. The SBA defines three types of cores: masters, slaves and auxiliaries. Several slaves IP Cores were developed following the SBA architecture, many of them to implement virtual instruments.\r\n\r\n", "\r\n\r\n\n        "]},
{"details": ["\n    Name: opb_wb_wrapper", "\n    Created: Sep 12, 2004", "\n    Updated: Sep 12, 2004", "\n        SVN Updated: May 19, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            OPB Bus to WISHBONE bus and WISHBONE bus to OPB bus interface wrappers.\r\n", "\r\n", "The Interface wrappers are provided as a plug-in for Xilinx EDK. To install, untarr the dowloadable archive in $EDK_ROOT/hw/XilinxProcessorIPLib/pcores/.\r\n", "You have to restart XPS to see the new wrappers.\r\n", "\n        ", "\n            ", "\n            This project is Done\n        "]},
{"details": ["\n    Name: system09", "\n    Created: May 16, 2003", "\n    Updated: Oct  9, 2011", "\n        SVN Updated: Jan  3, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 8 reported / 7 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            6809 System On a Chip that emulates the SWTPc 6809.\r\n\r\nIt has been ported to a variety of FPGA boards including the XESS XSA-3S1000, BurchED B5-X300 and Digilent Spartan 3 Starter board.\r\n\r\nThe System09 project page with revision history can be found at ", ".\r\n\r\nSystem09 runs the Flex9 disk operating system for the 6809 which can be found at the ", ". The Flex disk operating system and most of the associated software has been placed in the public domain. The source code for Flex9 can be found in the CVS repository.\r\n\r\nI have included ROMs for the ", " for the 6309/6809.\r\n\n        ", "\n            - 6809 instruction compatible\r\n", "- 6850 compatible ACIA/UART (57.6 KBaud)\r\n", "- Hardware Trap Logic\r\n", "- Dual 8 bit I/O port\r\n", "- Simple timer\r\n", "- 80 x 25 character Video Display with colour attributes\r\n", "- Compact Flash interface\r\n", "- PS/2 Keyboard Interface\r\n", "- SYS09BUG Monitor ROM with Video driver\r\n", "- Dynamic Address Translation supports up to 1Mbyte of RAM\r\n", "- Fits in 300KGate Spartan IIe\r\n", "- Uses Xilinx Block RAM for monitor ROM and VDU memory.\r\n", "- Optional NOICE ROMs\r\n", "\n        ", "\n            - Implemented on XESS XuLA-200 using ISE 12.4.\r\n", "- Implemented on Terasic DE1 board using Altera Quartus II.\r\n", "- Implemented on XESS XSA-3S1000 + XST-3.0 running Flex9 from IDE drive / CF card\r\n", "- Implemented on Digilent XC3S200 Starter Board with RAM disk\r\n", "- Implemented on BurchED B5-X300 FPGA Board running Flex9 from CF.\r\n", "- Limited Implementation on Digilent XC3S500E starter board using Block RAM.\r\n", "- Runs the SYS09BUG Monitor ROM with Video Display drivers.\r\n", "- Runs the Flex9 Disk operating system from RAM Disk, IDE Drive or Compact Flash\r\n", "- Also run NOICE Monitor for the 6809\r\n", "- Implemented with WebPack ISE 7.1i for upward compatibility.\r\n", "\n        "]},
{"details": ["\n    Name: wb_conbus", "\n    Created: Apr 15, 2003", "\n    Updated: Aug  3, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a WISHBONE Interconnect ShareBus IP core.It can interconnect up to 8 Masters and 8 Slaves \r\n", "\r\n", "Some of the main features are: \r\n", "\r\n", "Up to 8 Masters \r\n", "Up to 8 Slaves \r\n", "Only 1 priority level processed in a round robin way\n        ", "\n            - feature1\n", "- feature2\n        ", "\n            - 4/19/2003 Initial Release\r\n", "\r\n        "]},
{"details": ["\n    Name: oberon_sdram", "\n    Created: Feb 10, 2017", "\n    Updated: Feb 12, 2017", "\n        SVN Updated: Feb 12, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Project Oberon ", " modified to use SDRAM instead of static RAM\r\n", "Static RAM is old technology in FPGA world, and 1MB 32bit SRAM is hard to find on FPGA dev boards.\r\n", "I upgraded this great project with a cache memory, which is able to interface SDRAM and DDRAM.\r\n", "I uploaded the project archives for FleaFpga and for PapilioPro.\r\n", "I will also provide DE2-115 and Nexys4 versions.\r\n", "\n        "]},
{"details": ["\n    Name: nocem", "\n    Created: Apr  4, 2007", "\n    Updated: Feb  1, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            A Network on Chip Emulation Tool, NoCem is a body of VHDL code configurable by a toplevel package file that can create a variety of Network on Chips on parameters of datawidth, virtual channel implementations, topology, and in-network buffering lengths. Once parameterized, the resulting NoC is generated automatically with heavy use of VHDL generics and generate statements.\r\n", "\r\n", "author - Graham Schelle\n        ", "\n            - synthesizable VHDL code for network on chip creation\r\n", "  - FPGA implemented\r\n", "  - tested/verified\r\n", "- virtual channel implementation option\r\n", "- processor bridge for Xilinx Microblaze or PowerPC \n        ", "\n            - Initial addition of codebase and documentation\r\n", "- Fully verified\r\n", "- Published at WARFP2006\r\n", "\n        "]},
{"details": ["\n    Name: next186mp3", "\n    Created: Feb 27, 2015", "\n    Updated: Mar 10, 2015", "\n        SVN Updated: Mar 10, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is an evolution of my previous project, Next186SoC PC, able to play MP3 files in real time (any bitrate).\r\n", "It is written in Verilog, and it contains all the features of Next186SoC PC, plus a few more.\n        ", "\n            This is a PC SoC able to run 16bit DOS. It features the following elements:\r\n", "- a 80186 compatible CPU, running at 40MIPS (Netx186)\r\n", "- 16KB of cache: 4-way set associative\r\n", "- SDRAM interface (up to 64MB of SDRAM supported, through EMM and XMM)\r\n", "- High Memory Area (HMA) useable in DOS\r\n", "- Text mode, EGA(320x200x16), VGA(640x480x16, 320x200x256, ModeX), VESA(640x480x256)\r\n", "- a sound queue (16KB), able to deliver CD quality stereo sound (44100Hz) at 2 digital pins (pulse density modulation over a RC integrator: 1Kohm + 10nF). For the best sound quality I recommend a high impedance (>10Kohm) low pass filter (I use a 4th order low pass active Butterworth filter). The sound interface is also compatible with Disney Sound source and with Covox Speech thing, which provides improved sound for some DOS games.\r\n", "- a 32bit DSP coprocessor, able to assist the main CPU at MP3 decoding (and not only) - it takes only 5-7% LUTs of the SoC, plus 4x18bit multipliers\r\n", "- SD card interface (in SPI mode). FAT16 formatted disks are limited at 2GB. In order to use SD cards of up to 32GB, I used FreeDos 16bit, which supports FAT32.\r\n", "\r\n", "My current implementation is done on a Spartan6XC6SLX9 (Papilio Pro), it is running at 80Mhz (40Mips), have 8MB of SDRAM running at 140Mhz.\r\n", "The DSP is running at the bus speed of 80Mhz.\r\n", "It uses ~4200xLUT6 (from 5700 available) and 5x18bit multipliers (from 16 available).\r\n", "For the interface, I extended Arcade Mega Wing to 18bit VGA DAC, and I added a SD card interface.\r\n", "\r\n", "Without the DSP, the Next186 CPU is able to provide 50% of the required power for decoding a MP3 file. With the DSP coprocessor, it provides ~150%.\r\n", "\n        ", "\n            The DSP have 2K instructions of 16bits, and 256x32bit registers.\r\n", "Each instruction can address 2 registers from a 64 registers page. The 64reg pages can be mapped over the 256 registers.\r\n", "The DSP is based on a two stage exposed pipeline, executes one instruction/clock and it is able to execute code in parallel with the main CPU. More than that, the main CPU is able to transfer data to/from DSP registers while the DSP is running, allowing more parallelization.\r\n", "The DSP can do 32bit operations (additions, subtractions, multiplications, shift right, 16bit packing, logical operations). It have no jump, looping, subroutine call capabilities. \r\n", "The instruction set is detailed in the Verilog DSP32.v file.\r\n", "\r\n", "The MP3 decoding code occupies under 1K instructions.\r\n", "\n        "]},
{"details": ["\n    Name: i2c_wb_wrapper", "\n    Created: Nov  3, 2008", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n        ", "\n            Short: virtually convert an I2C slave into a WISHBONE slave\r\n", "\r\n", "This is a wrapper for the I2C controller core by Richard Herveille (", " which transparently converts a WISHBONE transaction into an I2C operation.\r\n", "\r\n", "Example: a WB read/write of the WB address 09h of this core would schedule and execute the (long) list of commands needed to make an I2C read/write of reg 09h of an I2C device connected to the I2C controller core in OpenCores, and return the result transparently into the WB bus.\r\n", "\r\n", "IMPORTANT: The current wrapper is for 16 bits I2C slaves, that is I2C reads and writes are composed of two bytes.\n        ", "\n            - WISHBONE wrapper for the \"I2C controller core\" by Richard Herveille\r\n", "- Fully transparent I2C  WISHBONE operation\r\n", "  - A WB read/write of address X becomes an I2C read/write of reg. X and the I2C slave's response is sent back to the WB bus.\r\n", "- Designed for 16 bits I2C slaves\r\n", "- FPGA proven and works perfect (if you run into problems: take into account this I2C controller's bug solution: ", " )\r\n", "- Limitations: the I2C slave's address is fixed, so that it may be used to control only one slave (can be overriden with minor modifications).\n        ", "\n            - 03/11/2008: Project created on OpenCores\n        "]},
{"details": ["\n    Name: minsoc", "\n    Created: Sep 18, 2009", "\n    Updated: Apr 20, 2013", "\n        SVN Updated: May 12, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 7 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "The Minimal OpenRISC System on Chip is a system on chip (SoC) implementation with standard IP cores available at OpenCores. This implementation consists of a standard project comprehending the standard IP cores necessary for a SoC embedding the OpenRISC implementation OR1200.", "This project idea is to offer a synthesizable SoC which can be uploaded to every FPGA and be compatible with every FPGA board without the requirement of changing its code. In order to deliver such a project, the project has been based on a standard memory implementation and the Advanced Debug System, which allows system debug and software upload with the same cables used for FPGA configuration.", "The adaptation of the project to a target board is made in 2 steps maximum. First, the \u201cminsoc_defines.v\u201d file has to be adjusted, generally one has to only uncomment his FPGA manufacturer and FPGA model definitions. After that, a constraint file for your specific pinout has to be created. Constraint files for standard boards can be found in the backend directory of the project.", "Furthermore, the project offers working testbench and firmwares for its SoC. The current testbench can be run out of the box using Icarus Verilog v. 9.1. The firmwares are nearly the same of those of orpsocv2. The differences are for now, that the known UART \"hello world\" example now runs with interrupts and a new Ethernet example has been added to it.", "To complete, an on-chip memory instance is provided to embed the CPU's firmware. The size of this memory can be adapted defining its address width inside of the same minsoc_defines.v file, affecting simulation and synthesis equally. This enables the customization of the SoC to the available resources of the target FPGA, for general purposes, or to the memory amount required by the target firmware, for custom implementation, e.g. ASIC.", "An overview about the complete SoC and its external connections is on Figure 1.", "\r\n", "\r\n", "\n            -or1200 OpenRISC implementation\r\n", "\r\n", "-Resizable onchip memory\r\n", "\r\n", "-System frequency selection\r\n", "\r\n", "-JTAG debug featuring a multitude of cables\r\n", "\r\n", "-Start-up option to automatically load your firmware on start-up from an external SPI memory\r\n", "\r\n", "-UART and Ethernet modules\r\n", "\r\n", "-FPGA generic and specific code (Xilinx & Altera) for memory, clock adaptation (PLLs and DCMs) and JTAG Tap\r\n", "\r\n", "-System configuration in a single definition file\r\n", "\r\n", "-Example firmwares using UART and Ethernet\r\n", "\r\n", "-Testbench included, for the simulation of exacly your configured system\n        ", "\n            All minsoc FPGA generic features have been simulated and proven to work. \r\n", "\r\n", "The FPGA generic features have been tested on an FPGA implementation and are working. These comprehend the FPGA generic only modules, start-up, Ethernet, UART and or1200 OpenRISC; and the generic JTAG tap and the generic clock divider. Both, JTAG tap and clock divider, can optionally be FPGA specific. On the other hand, the generic memory cannot be implemented in an FPGA generic way, because the synthesizer does not allocate them to RAMs, consuming then all FPGA flip-flops. \r\n", "\r\n", "The FPGA specific features, onchip memory, clock frequency adaptation and JTAG taps have to be tested for different FPGAs. Xilinx implementations differs in both instantiation and implementation for all modules. Altera differs perhaps in implementation, but the modules can be instantiated equally. A specific implementation of a clock frequency adaptation PLL for Altera has been recently added by Javier Almansa.\r\n", "\r\n", "Test of FPGA specific features requires feedback from users, for now we have positive results from the following configurations:\r\n", "-Xilinx, Spartan 3E (Spartan3E Starter Kit)        (Thanks to Bakiri Mohammed)\r\n", "-Xilinx, Spartan 3A (Spartan3A 1800 DSP Kit)\r\n", "-Xilinx, Virtex 4 (ML405 board)                    (Thanks to Ravi Kumar)\r\n", "-Xilinx, Virtex 5 (ML505 board)                    (Thanks to Evangelos Logaras)\r\n", "-Altera, Cyclone II                                (Thanks to Nathan Yawn)\r\n", "-Altera, Cyclone II (DE2-70 board)                 (Thanks to Alex Parrado)\r\n", "-Altera, Cyclone III                               (Thanks to Davide Catani)\r\n", "-Altera, Cyclone IV (Bemicro SDK board)            (Thanks to Jean-Christophe Ricard)\r\n", "-Altera, Stratix II                                (Thanks to Alex Parrado)\r\n", "\r\n", "For now no configurations have been proven not to work. \n        ", "\n            Information regarding the usage of MinSoC can be found in our wiki: ", "\r\n", "\r\n", "There, you will find guidance to retrieve and install the required tools, simulate and synthesize the design, and to run and debug the first firmware on your FPGA. \r\n", "\r\n", "If you can improve the wiki, feel free do so. It is public. Update pages, create new ones and add links to them. This allow for quality as you find errors, correct the language or give hints to users doing the same thing as you. \n        ", "\n            If you have problems implementing the design or information regarding new tested platforms, want to contribute with a ucf file or are interested in implementing something for the project, contact our discussion group.\r\n", "\r\n", "Send an email to: minsoc@googlegroups.com\r\n", "\r\n", "This discussion group together with the wiki are the places for decision and planing of MinSoC's development. You can check latest maintainer's ideas and plans under: ", "\n        "]},
{"details": ["\n    Name: robust_axi_fabric", "\n    Created: Mar 23, 2011", "\n    Updated: Jun 12, 2015", "\n        SVN Updated: Jul  3, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Generic AXI interconnect fabric. It is a multi-master, multi-slave non-blocking AXI fabric with round-robin arbitration. Builds Verilog AXI interconnects according to input parameters: master number, slave number, AXI IDs, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded from ", "\n        ", "\n            Generic AXI master stub \r\n", " \r\n", "\r\n", "Generic AXI slave stub \r\n", "\n        "]},
{"details": ["\n    Name: next186_soc_pc", "\n    Created: Jun 10, 2013", "\n    Updated: Jan 25, 2018", "\n        SVN Updated: Jan 25, 2018", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 4 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            PC AT SoC based on Next186 core. CPU runs at up to 80 MHz (80 MIPS), up to 64MB of RAM, HMA available.\r\n", "Able to run DOS6.22, FreeDos, Windows3.0, GeOS.\r\n", "Able to run DOS 8086, 80186 applications (most of 80286 applications/games are running ok). May run real mode 32bit 386 applications with a 32bit software extender (see EMU386).\r\n", "Video modes available: 80x25x256 text, 320x200x256 MCGA, 640x480x256 VESA VBE mode 101h, 640x480x16 VGA planar, 320x200x16 EGA planar, ModeX support.\r\n", "PS2 8042 controller for keyboard and mouse.\r\n", "Simplified 8259 PIC, 8253 timer.\r\n", "44100Khz stereo sound, compatible with Disney Sound Source. \r\n", "32bit DSP - allows real time mp3 play (mp3 player sources provided).\r\n", "8bit GPIO. \r\n", "UART 8250 - COM1. \r\n", "Bootstrap and BIOS ASM code provided.\r\n", "Besides the FPGA board, a SD HC card is required for the hard disk implementation.\r\n", "The system is able to run Windows3.0 in real mode.\n        ", "\n            CPU: Next186 core, (C) Nicolae Dumitrache, available on OpenCores.\r\n", "VGA: A custom VGA core which implements the text mode 3h 80x25x256, the MCGA graphic mode 13h 320x200x256, VESA graphic mode 101h 640x480x256, mode 12h 640x480x16 planar, mode 0dH 320x200x16 planar, ModeX. Unlike the standard VGA, the mode 13h can support 8 hardware pages.\r\n", "TIMER: a simplified 8253\r\n", "PIC: a simplified 8259 programmable interrupt controller\r\n", "Kb, Mouse: a simplified 8042 PS2 controller\r\n", "Hard Disk - a SD HC 4GB external memory card is used as HD. For simplicity, I access it in SPI mode, being able to get a transfer rate up to 2 MB/s. All the transfer work is done by the CPU, with a minimal hardware interface.\r\n", "RS232 - 8250 compatible COM1.\r\n", "Speaker sound, Disney Sound Source and 44100Khz stereo custom output.\r\n", "Reset button\r\n", "NMI button (useful for debugging, see Turbo Debugger)\r\n", "HALT LED\r\n", "No DMA is necessary, as Next186 CPU is able to transfer up to 33MB/s with REP MOVSW.\r\n", "\r\n", "More details are commented in the Verilog sources and in the BIOS code.\r\n", "\r\n", "As for the IP cores, I used:\r\n", "2KB FIFO (32bit in, 16bit out, independent clocks) for VGA\r\n", "MIG memory interface\r\n", "4KB true dual port 8bit SRAM for text mode font\r\n", "2KB true dual port 8/32bit SRAM for 256bit VGA DAC color palette\r\n", "16KB true dual port 32bit SRAM for CPU cache\r\n", "DCM and PLL\r\n", "\r\n", "The CPU clock is independent from DDRAM clock. The bus interface between CPU and the cache memory is 32bit width and it is working at double the CPU frequency.\n        ", "\n            The system have no ROM, only 64MB of dynamic RAM and 4KB of code/data cache (8 lines of 256 bytes). In order to be able to boot, the cache is preloaded with the bootstrap code and marked as \"dirty\". At the first flush, the cache content will be transferred to RAM.\r\nThe bootstrap code tries to load the BIOS (8KB) from the latest 16 sectors of the SD card, at 0F000h:0E000h. If the SD card is not present, or BIOS is unavailable, the bootstrap code waits on RS232 (115200bps) an executable, loads it at 0f000h:100h and executes it.", "\r\n", "\r\n", "'\n        ", "\n            The memory is split as follows:", "\r\n640KB low DOS memory", "\r\n512KB video memory (which can be mapped over segments 0a000h and 0b000h) ", "\r\n224KB upper memory, available to DOS through the XMM manager", "\r\n32KB ROM area, from which only the latest 8KB are actually used by the BIOS code.", "\r\n64KB HMA", "\r\n512KB available for the old INT15h extended memory mechanism", "\r\n", "\r\nThe rest up to 64MB is available as extended memory (XMM), and in my DOS configuration, is used as follows:", "\r\n2MB for smartdrv (increases a lot the disk access)", "\r\n28MB RAM disk (not really necessary, as the SD hard disk + smartdrv is fast enough, but 64MB RAM is too much for DOS) ", "\r\n16MB EMM (I use a LIMulator for 286)", "\r\n15MB XMM", "\r\n", "\r\nThe RAM is accessed in parallel by the CPU and the VGA. VGA uses a 2KB FIFO and have priority over CPU when the FIFO is empty. ", "When the FIFO is not empty, the CPU have priority.", "\r\nThe RAM is divided in 64Kb pages. Each page can be mapped over each of the first 16 64Kb segment addresses. This mechanism is used for accessing the video memory in mode 13h (8 pages) and mode 101h VESA, and also for the extended/expanded memory access. ", "\r\n", "\r\n", "\r\n", "\n        ", "\n            I provided in the package the assembler source code for the boot loader and for the BIOS.\r\n", "The BIOS code is quite small, taking only 8KB beginning with 0f000h:0e000h. All the rest of the RAM upper memory is available for DOS.\r\n", "The VESA VBE interface and all required paged memory access code for XMM is contained inside the BIOS.\r\n", "A RS232 communication application executable is also provided (SerialComm.exe). It can be used to transfer applications or files from a PC to the Next186 SoC through a serial link.\r\n", "\r\n", "Lately I installed GEOS (Geoworks Ensemble v2.0 and Breadbox Ensemble v4.1.2). With 16MB XMS swap space, almost 900KB global heap (in the first megabyte), and a CPU ~80 times faster than standard XT, it's working like a charm in VESA 640x480x256 colors.\n        ", "\n            Borland C++ v2.0, Turbo Pascal v7.0", "\r\n", "\r\n", "\r\nIndy MCGA, Prince of Persia 2 MCGA", "\r\n", "\r\n", "\r\nWordPerfect 6.0 VESA 640x480x256, BattleChess4000 VESA 640x480x256", "\r\n", "\r\n", "\r\nGeoWorks Ensemble 2.0 VESA 640x480x256, Breadbox Ensemble v4.1.2 VESA 640x480x256", "\r\n", "\r\n", "\r\n\r\n\r\n\n        ", "\n            I uploaded the latest port of Next186 SoC, on the Valentin Angelovski's tiny but great FleaFPGA board (Lattice MachXO2-7000H, 32MB SDRAM, ", " )\r\n", "It is working at 100Mhz SDRAM, 50Mhz bus, 25Mips) ~20000 Dhrystone 2.1\r\n", "It takes ~95% FPGA area.\r\n", "\r\n", "\n        ", "\n            Some new features added to the newest ports:\r\n", "- 16KB cache\r\n", "- 44100Khz stereo sound, compatible with Disney Sound Source\r\n", "- 32bit DSP - allows real time mp3 play (mp3 player sources provided in the project archives)\r\n", "- 8bit GPIO\r\n", "- UART 8250 - COM1\r\n", "- Full projects with pre-built images available for download (some images were obtained by manually overclocking the PLLs after build).\r\n", "\r\n", "Ported on the following FPGA platforms:\r\n", "\r\n", "- Papilio Pro(Spartan6 xc6slx9-2)  - runs at 98Mhz bus, 49Mhz CPU, 144Mhz(288MB/s) SDRAM (8MB), 90Mhz DSP, 4700LUT6 (82% from 5720), VGA18bit\r\n", "\r\n", "- Pipistrello(Spartan6 xc6slx45-3) - runs at 105Mhz bus, 52.5Mhz CPU, 200Mhz(800MB/s) DDRAM (64MB), 100Mhz DSP, 5060LUT6 (18% from 27288), HDMI\r\n", "\r\n", "- FleaFPGA (Lattice MachXO2-7000HE) - runs at 50Mhz bus, 25Mhz CPU, 100Mhz(200MB/s) SDRAM (32MB), no DSP, 6541LUT4 (95% from 6864), VGA12bit\r\n", "\r\n", "- DE2-115 (Altera EP4CE115F29C7) - runs at 105Mhz bus, 52.5Mhz CPU, 135Mhz(540MB/s) SDRAM (64MB), 97Mhz DSP, 9248LE (8% from 114480), VGA24bit\r\n", "\r\n", "- Nexys4 (Artix7 xc7a100t-1)  - runs at 160Mhz bus, 80Mhz CPU, 110Mhz(220MB/s) CellularRAM (16MB), 150Mhz DSP, 4656LUT6 (7% from 63400), VGA12bit\r\n", "\r\n", "- DE0-Nano (Altera EP4CE22F17C6N) - runs at 100Mhz bus, 50Mhz CPU, 147Mhz(294MB/s) SDRAM (32MB), 100Mhz DSP, 13691LUT4 (61% from 22320), VGA18bit, Adlib - requires interface similar with Papilio Pro one\r\n", "\n        ", "\n            An Adlib/OPL3 implementation was added on Nexys4 version.\r\n", "\r\n", "- Nexys4 (Artix7 xc7a100t-1) - runs at 160Mhz bus, 80Mhz CPU, 110Mhz(220MB/s) CellularRAM (16MB), 150Mhz DSP, ~6100LUT6 (9% from 63400), VGA12bit\r\n", "The 160Mhz/150MHz FPGA image is obtained from the 120MHz/120MHz image by overclocking the routed design DCMs.\r\n", "\r\n", "The OPL3 engine takes around 500LUT6, and the interface between the Next186 CPU and OPL3 is done with a NextZ80 CPU (~800LUT6).\r\n", "The OPL3 engine drives 18 channels and 36 operators and needs at least 45Mhz clock. The 2-nd part of 4 operator channels is simplified, and the OPL3 rhythm is not yet implemented. \r\n", "The access ports are 0x388 (bank 0 address), 0x389(bank 0 data), 0x38A(bank 1 address), 0x38B(bank 1 data). No delay is required between writes.\r\n", "\r\n", "All supported DOS games and applications should be able play Adlib music with this Next186 SoC version.\r\n", "\r\n", "I want to give credit to the MAME emulator developers. The MAME OPL3 emulator was the starting point for this Verilog implementation.\r\n", "\n        ", "\n            You need an ESP8266 board, programmed with the following SLIP Router firmware:\r\n", "\r\n", "and configure it with your ssid/password.\r\n", "\r\n", "Connect ESP8266 to the RS232 external interface of Next186SoC (TX_EXT, RX_EXT).\r\n", "COM1 port is multiplexed with the internal RS232 (usually embedded on dev board) and the external RS232. In order to use the external RS232 you need to write 1 to port 1 (use debug.exe, or make a simple .com executable):\r\n", "\r\n", "mov al, 1\r\n", "out (1), al\r\n", "\r\n", "\r\n", "Install Kermit\r\n", "\r\n", "and use SLIP8250.COM packet driver inside (in autoexec.bat):\r\n", "\r\n", "lh slip8250 0x60 SLIP 4 0x3f8 115200 16384\r\n", "\r\n", "Install Arachne 16bit DOS browser, configure it with the IP addresses and start browsing (you will need few MB of XMS free in order to work well, otherwise Arachne will sometimes crash on bigger pages). The screen can be configured in VGA640x480x16 or VESA640x480x256.\r\n", "You can also use telnet from the Kermit package.\r\n", "\r\n", "You can write your net apps with WATTCP library, but take care that it uses for DNS query an invalid source port address (997). The ESP8266 DNS firmware requires a port bigger than 1024, so if you are using a precompiled executable made with WATTCP you net to patch it (search for 0x03e5 - usually you will find a mov ax,0x03e5 - and replace it with 0x23e5).\n        "]},
{"details": ["\n    Name: m16c5x", "\n    Created: Nov  1, 2013", "\n    Updated: Nov 10, 2014", "\n        SVN Updated: Dec  6, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project demonstrates the use of the P16C5x soft-processor core, found elsewhere on opencores.org, in a system-on-chip. The project targets a small FPGA, the Xilinx XC3S50A-4VQ100I. The project integrates the P16C5x PIC-compatible processor core an SPI Master module, SPIxIF, a Synchronous Serial Peripheral (SSP) slave module, SSP_Slv, an SSP UART, SSP_UART, and an inferred 4096 x 12 Block RAM program memory. (The SPIxIF, SSP_Slv, and SSP_UART modules are all modules that can be found on opencores.org.)\r\n", "\r\n", "The P16C5x module is a PIC-compatible processor core that supports the 12-bit base architecture of the Microchip PIC16 product line. It extends the base architecture by supporting an additional address line into program memory. The base architecture does not implement the PA[2] program bank register in the STATUS register. The P16C5x module implements that bit, and adds an additional bit to the two-level stack so that a complete 4096 x 12 program space is available.\r\n", "\r\n", "For compatibility with readily available PIC-compatible tools from Microchip, third-party vendors, and open-source suppliers, the P16C5x core has been parameterized such that the core's reset vector is set to be compatible with the corresponding vector of the PIC16C57/PIC16C59 microcomputer. The internal register/RAM memory map of P16C5x core has been set to be compatible with that of the PIC16C57 microcomputer: (1) I/O ports A, B, C are implemented; and (2) internal RAM is set for 72 bytes. (It is possible to increase the size of internal memory to support the banked switched memory of the PIC16C59, but the size of the FIFOs used for the UART may have to be changed to support the additional processor core RAM in the small FPGA chosen as the target for this project. Changing the FPGA to an XC3S200A-4VQ100I is possible, and that choice would allow the increase of the processor memory, and enable the use of Block RAMs for the UART FIFOs, and adding a second SSP_UART module to the M16C5X soft-microcomputer.)\r\n", "\r\n", "Unlike a Microchip PIC16C57/PIC16C59 microcomputer, the I/O ports are not built into the M16C5x's P16C5x soft-core processor module. Instead, the P16C5x soft-core provides a parallel data bus with one-hot control signals for writing the three TRIS write-only registers and the three output data registers and reading the three input data registers. This allows the core's integrator the flexibility to create custom peripherals which are tightly integrated with the processor core in a manner that reduces the number of instructions needed to access the custom peripherals.\r\n", "\r\n", "In the M16C5x, the SPI master interface module is integrated into the core using the TRIS C register as a write-only register. The SPI transmit and receive data registers are mapped to the Port C data output and data input registers, respectively. Furthermore, to take advantage of the capability of the SPIxIF module to operate with FIFOs connected, two 16x8 distributed RAM FIFOs are attached to the SPIxIF as the transmit and receive data ports. This allows the P16C5x processor core the opportunity to process other (beyond the scope of the demonstration) I/O or perform other computational functions while an SPI transaction is automatically fulfilled by the SPI master peripheral.\r\n", "\r\n", "Beyond the testing performed with the simulator and various test benches, the M16C5x has been tested in a working board using the XC3S50A-4VQ100I FPGA. A simple test program was written using MPLAB (8.91) that simply converts lower case ASCII alpha characters into upper case characters, and vice versa. After configuring the SPI master and the SSP UART, it simply polls the UART, transforms the data, and writes it back to the UART. Even with all of this activity on the internal SPI bus, the M16C5x is able to process data at rates to 921.6 kbaud without errors or dropouts.  \r\n", "\r\n", "In the target FPGA, the smallest and lowest speed grade part in the Spartan 3A FPGA family, the M16C5x easily reports post synthesis speeds in excess of 57 MHz, and maps, places, and routes (with only simple period constraints) with reported and verified post-PAR performance better than 60 MHz. Since the core is a single cycle core, this is a substantial improvement over the capabilities of the equivalent Microchip products which are 5 MHz (effective instruction rate) devices.\r\n", "\r\n", "A final component of the M16C5x project is the demonstration of the use of the Xilinx tool, Data2Mem, that allows specially formatted ASCII hexadecimal files to be written into the block RAMs of the device during the generation of the configuration images, i.e. directly inserted by BitGen. This allows a third party developer to write/modify the contents of the M16C5x program memories without requiring the resulting data to be loaded into the Block RAMs through re-synthesis and MAP/PAR operations. The resulting improvement in the turn around time for non-RTL modifications, i.e. firmware-only mods, is dramatic and far less error prone.\r\n", "\r\n", "The TCL script included in the RTL source directory allows the integrator of this core to take advantage of this capability. (This capability is likely available from any FPGA vendor supporting soft-core processors. It is expected that Altera (NIOS-II) and Lattice (Mico-32) toolsets provide the same type of capability, but no verification has been performed to verify that these toolsets support this capability in their base (free) configurations.) The project provides a Block Memory Map (BMM) file, sets the mapper and the configuration bitstream generator (BitGen) to support use the BMM file. The project also provides a Windows executable (and its source code) for a simple filter/console program that converts Microchip MPLAB Intel Hex output files into Data2Mem-compatible MEM files.\n        ", "\n            This core has been used with MPLAB and the CCS C compiler tools. A utility for converting from Intel Hex to Xilinx MEM files has been provided as part of this SoC project.\n        ", "\n            The data provided in this section represents the synthesis/PAR results of building the project for a XC3S50A-4VQ100I FPGA to achieve best performance. Thus, synthesis is performed with speed as its primary objective; resource sharing is used, but register balancing (forward and backward) is allowed. Mapping is performed with an area objective to compress the resulting image as much as possible. Simple timing constraints are applied for the three internal clock domains, with the primary objective being to achieve a minimum operating speed of 60 MHz for the P16C5x core, 66.667 MHz operation for the SPI Master (internal SPI bus), and 100 MHz for the SSP UART. The UART, although capable of operating at higher speeds, is fed a 29.4912 MHz reference clock. \r\nModule Level Utilization"]},
{"details": ["\n    Name: axi_dma", "\n    Created: May 17, 2017", "\n    Updated: Jun  4, 2017", "\n        SVN: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            An AXI DMA fits the peripheral (such as I2S, UART, SPI\u2026.) it needs DMA capability in SoC; the DMA will move data between the peripheral and system memory for efficient data transfer, also saving CPU computing power.\n        ", "\n            -\tAXI compliant; 32-bit data width.\r\n", "-\tBi-directional; independent read/write channel, and also read/write channel can be executed in parallel.\r\n", "-\tByte addressable; DMA starting address and transfer length could not have to be a multiple of 4.\r\n", "-\tMaximum burst length is 8 words, and burst access won\u2019t cross 8-word boundary.\r\n", "-\tOutstanding transaction support.\r\n", "-\tResponse error/time-out support.\r\n", "-\tAPB interface for register programing\r\n", "-\tPeripheral interface protocol: AXI stream\r\n", "\r\n", " \r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: gecko3", "\n    Created: Sep 23, 2008", "\n    Updated: Mar 16, 2012", "\n        SVN Updated: Apr 20, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            ", "The GECKO system is a general purpose hardware/software co-design environment for real-time information processing and/or system-on-chip (SoC) solutions. The GECKO system supports a new design methodology for system-on-chips, which necessitates co-design of software, fast hardware and dedicated real-time signal processing hardware.", "This is now the third generation of these boards, so the current project is called GECKO3.", "All GECKO3 system components can be stacked together, as they all have a common backbone bus connector and all have the size of a credit card.\r\n\r\n\r\n\r\n", "Information about the whole Project, all related modules, software support, tutorials and much more can be found on the project wiki:", "\r\n", "Get the nice ", " in pdf format with all important information about our project.", "\n            ", "The GECKO system comprises hardware modules that can be readily interfaced. The GECKO3main module is the main experimental platform, offering the necessary computing power for processing intensive real-time algorithms as well as the necessary flexibility for control intensive software tasks.", "Different GECKO3 modules are available to adapt the GECKO3main to the needs of different applications. An optional board, the GECKO3interface, houses a 160 x 128 pixel graphical color OLED display and a keyboard.", "The autonomous GECKO3EDU robot is a composition of different modules with sensors, motors and mechanical housing. It is used for educational purposes. One of its modules, the GECKO3power board, provides the necessary power supply and, in addition, houses H-bridges to control the robot\u2018s motors, on-board ultrasonic sensor for measuring distances to obstacles and line sensors for line-follower applications. The GECKO3 robot is the mechanical vehicle for the robot with 2 or 4 small motors and a 3900 mAh Li-Ion battery pack.", "\r\nFor autonomous robots, various sensor capabilities are crucial. The GECKO3sensors board therefore houses a variety of sensors like two-dimensional magnetic field sensor for compass application, a two-dimensional acceleration sensor, digital video camera for image processing as well as a bluetooth wireless communication device.", "To support autonomous navigation in outdoor environments, the robots can use the GECKO3gps module to quickly add a high sensitivity GPS receiver with an on-board antenna. The module is GALILEO aware.", "\n            ", "\r\n", "\r\nThe GECKO3main includes fully populated GECKO3 system bus connectors. The module can be stacked with any other GECKO3 module and also with other GECKO3main modules. We provide a fast and collision free development environment because none of the I/O Pins on the System Bus are shared with on-board peripherals.", "\r\nMatlab and Labview can access the GECKO3main through the VISA API (Virtual Instrument Software Architecture) using the Instrument Control Toolbox in Matlab. The VISA API can also be used from other environments calling Windows DLLs. On Linux you can use normal file I/O with the USB-TMC driver instead of the proprietary VISA driver. The USBTMC Driver is included in every Linux Kernel >2.6.28, and you can also compile it yourself for older kernels. We use this system not only to configure the FPGA during development and for data communication, but also to configure the FPGA in stand-alone mode.", "\r\n", "\n            ", "\r\nAll parts of this project (including text, photograph and any other original works), unless otherwise noted is licensed under a Creative Commons License (by-nc-sa)", "For more information check out the ", " page in our wiki."]},
{"details": ["\n    Name: cpu_lecture", "\n    Created: Jan  4, 2010", "\n    Updated: Apr 13, 2011", "\n        SVN Updated: Apr  1, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a lecture about designing a SoC in VHDL.\r\n", "\r\n", "Everything runs under Linux - no more Windows!\r\n", "\r\n", "Check it out and then start at the file named index.html.\r\n", "\r\n", "Enjoy!\n        "]},
{"details": ["\n    Name: s6soc", "\n    Created: Mar 22, 2016", "\n    Updated: Mar  9, 2017", "\n        SVN Updated: Mar 28, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "This CMOD-S6 SoC grew out of the desire to demonstrate that a useful ", "\r\nsoft core implementation could be made in a very small space.  In particular, one of the purposes of the ZipCPU was to be able to operate successfully in a very area-challenged environment.  The ", ", as sold by ", ",provides this environment for this project.\r\n\n        ", "\n            ", "For those not familiar with the ", ", it is a Soft Core CPU designed specifically for small area implementations.  The CPU is a full 32-bit CPU, designed as a RISC load/store architecture, having a full set of thirty-two 32-bit registers (of which 16 may be used at any one time), and has a single wishbone bus for both instructions and data (Von Neumann architecture).  The particular implementation of the ZipCPU used for this SoC project is not pipelined, nor does it have either instruction or data caches--they simply wouldn't fit within the FPGA.  Still, a CPU is a CPU and this CPU will execute the instructions given to it faithfully.\r\n    \r\n\n        ", "\n            ", "A SoC is really a soft core CPU combined with a bus, giving the CPU access to a variety of peripherals.  In this case, the CMOD-S6 SoC offers the user with the following peripherals:\r\n", " The second timer has been swapped for a watchdog timer since 1) that's what I found most useful, and 2) without the autoreload logic it used fewer resources.\r\n        ", " In the end, I may not need this configuration port.  Using Digilent's JTAG controller, I can load whatever configuration I need into the device by force.  Hence, all that is necessary to switch configurations is to plug the device in and switch.  To make matters worse, when the JTAG controller is plugged in, I can't test the internal configuration port.  So it may take a while before I know this port actually works.\r\n", "  The real-time clock was removed to make room for 32x32 bit multiplies within the ZipCPU.  If I get more free space again, I'll bring it back, but it doesn't seem all that likely.\r\n", " The real-time clock has been replaced with software functionality as part of the O/S.  As long as scheduling doesn't get so tight that the real-time clock task doesn't run every second, it should be able to set and maintain time.\r\n", "\n            ", "This board will be proven with the (imaginary) task of implementing a security light.  The light works in this fashion: when someone presses the doorbell (pressing one of the on-board buttons), the system will then play a doorbell sound on the audio port, and turn on the outdoor lights for a half an hour.  Further, the keypad will allow a user to set the current time, and set times when the outdoor lights should not be turned on (i.e., during the daytime).  Finally, the GPIO pins will be used to control a 2-line display that will show either a blank screen (if not being used), the time of the last doorbell press, or a menu driven screen for use with the keypad.\r\n", "\r\n", "The UART will be used primarily as a debug port, both to output current status (ala debug by printf), as well as to allow access to a second S6 configuration which can be used for programming the flash.\r\n", "\r\n", "\n        ", "\n            ", "20160523: I am going to place this project down in my \"done\" category of projects.  It currently does all that I have asked of it and all that I intended the project to do.  Please feel to write if you have comments, thoughts, or questions.\r\n", "20170126: Resurrected from \"DONE\" to add the 8-bit byte ZipCPU functionality into the processor\r\n", "20170309: All of the prior ZipOS functionality now works (again), using the new ZipCPU supporting 8-bit bytes.\r\n", "Due to errors with the SVN server, the most up-to-date version resides on ", ".\n        "]},
{"details": ["\n    Name: async_sdm_noc", "\n    Created: May  9, 2011", "\n    Updated: Jun  8, 2011", "\n        SVN Updated: May 31, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            \r\n", "Asynchronous Spatial Division Multiplexing Router for On-Chip Networks\r\n", "\r\n", "Version: 0.2 \r\n", "\r\n", "On-chip networks or networks-on-chip (NoCs) are the on-chip communication fabric for\r\n", "current and future multiprocessor SoCs (MPSoCs) and chip multiprocessors (CMPs).\r\n", "Compared with synchronous NoCs, asynchronous NoCs have following benefits:\r\n", "  * Tolerance to all kinds of delay variations caused by process, power and temperature\r\n", "    variations.\r\n", "  * Low transmission latency.\r\n", "  * Zero dynamic power when idle.\r\n", "  * Unified sync/async interface and easy clock domain integration.\r\n", "\r\n", "Most NoCs use the wormhole flow control method. Many complex flow control methods are\r\n", "built upon the wormhole method, such as virtual channel (VC), TDMA, and SDM. VC is the\r\n", "most utilized flow control in both sync and async NoCs. However, it is found VC\r\n", "compromises the throughput performance of asynchronous NoCs. This project provides a new\r\n", "asynchronous router structure which use SDM rather than VC. It has been shown that SDM\r\n", "achieve better throughput than VC in the same router configuration.\r\n", "\r\n", "This project provide a reconfigurable asynchronous SDM router which can be configured\r\n", "into a basic wormhole router or an SDM router with multiple virtual circuits in every\r\n", "direction.    \r\n", "\r\n", "Features:\r\n", "  * 5-port router for mesh network (0 south, 1 west, 2 north, 3 east, 4 local)\r\n", "  * The dimension order routing (XY routing)\r\n", "  * Available flow control methods: wormhole, SDM, VC\r\n", "  * Reconfigurable number of virtual circuits, buffer size, data width\r\n", "  * Fully synthesizable router implementation\r\n", "  * SystemC testbench provided\r\n", "\r\n", "Languages:\r\n", "  * Routers are written in synthesizable SystemVerilog\r\n", "  * Test benches are provided by SystemC \r\n", "\r\n", "Software requirements:\r\n", "  * The open source Nangate 45nm cell library\r\n", "  * Synopsys Design Compiler (Synthesis)\r\n", "  * Cadence IUS -- NC Simulator (for SystemC/Verilog co-simulation)\r\n", "\n        "]},
{"details": ["\n    Name: axi4_tlm_bfm", "\n    Created: May 27, 2013", "\n    Updated: Feb 23, 2018", "\n        SVN Updated: Mar 29, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "This project implements the AXI4 transaction-level model (TLM) and bus functional model (BFM) in VHDL. Currently, only the AXI4-Stream Master protocol is supported, but I also have plans to support AXI4-Lite and the full AXI4 protocols.\r\n", "\r\nThis enables sub-components of an SoC system to easily communicate with one another through the AXI4 bus. Communications is achieved simply by having a procedure-call statement in your sub-component. The high-level transactions encapsulate the AXI4 protocol details in a lower-level layer known as the bus functional model. This separation between the high-level and low-level implementations results in a more modular and manageable design.\r\n", "\r\nI have included OS-VVM verbatim from their website, so you will need to ", " (you may uncompress using GUI as well):", "\r\n", "\r\n", "\r\nI do not adapt nor make any changes to the OS-VVM packages. To find out more about the cool features of OS-VVM, or to contribute to the project, visit the ", ".\r\n", "\r\nAfter unpacking OS-VVM, we can now simulate the design with Mentor Graphics Questa/ModelSim. Simply ", " into the ", " folder, and execute ", " from the Unix prompt:", "\r\n", "\r\n", "\r\nIf you have ModelSim/QuestaSim installed, the GUI will appear immediately after you run the script.\r\n", "\r\nCurrently, I provide only the simulation script for Linux/Unix. Email me at ", " if you need help with simulating this project on Windows, and I will send you separate instructions.\r\n", "\r\nI tried simulating this on Synopsys VCS-MX, but the tool didn't like the VHDL-2008 constructs I was using very much. If you are using this simulator, or any other simulator, kindly let us know.\r\n", "\r\nAltera and Xilinx tools failed to synthesise this core as is, as they do not yet support many of VHDL-2008 and VHDL-2002 language constructs. However, I believe Synopsys Synplify should be able to synthesise this. If you are using Synplify, or any other synthesis tool, let us know how well this core works with your toolchain.", "\r\n[Note: if this core synthesises well with Synplify, it could very well work for Lattice FPGAs without much hassle. Let us know if you would like to try this on Lattice, so I can post up your results here.]\r\n", "\r\nUpdate [11 Sept 2013]:", "\r\nDesign debugged on Altera Quartus. I had to hack Quartus synthesis by changing some VHDL-2008 constructs to VHDL-93. Design verified on an Altera FPGA, and hardware measurements matches well with ModelSim simulations. To use the synthesis sources, look under the ", " folder. You can run the Quartus synthesis flow by supplying the following at the Unix prompt (assuming you are in \"", "\"):", "\r\n", "\r\n", "\r\nHere's an explanation of what the synthesis script (", ") does:\r\n", "\r\n- Runs the whole Quartus synthesis, place-and-route, and design assembly flow.\r\n", "\r\n- Programs your board. You may need to change your cable name to the one that's connected to your machine. Enter \"", "\" to find out your cable name.\r\n", "\r\n- Brings up the Quartus SignalTap II Embedded Logic Analyser's GUI for signal acquisition and viewing.\r\n", "\r\nI have tested this to be working on an Altera DE2-115 kit, the Nios II Embedded Evaluation Kit (NEEK), and also the Altera-Arrow BeMicro Kit. Essentially, this design should work on any other Altera board as well. You just need to assign a clock and reset, and perhaps tweak the SignalTap II core for other boards (if needed), and you're set.", "\r\n\r\nNote that although I used the NEEK, I did not use Nios (or any processor) in this design. You could however use this core to interconnect between processors and other peripherals that are AXI4-Stream compliant. The place-and-route results above was taken from the compilation on the BeMicro Kit (which uses the Cyclone IV E FPGA).\r\n", "\r\nI am trying to make this core to be as vendor independent as possible. To do this, I plan to write a script that works around several vendor tools, including conversion of some VHDL-2008 language constructs to VHDL-93 synthesisable forms. If you'd like to volunteer writing this script (or like to help in any other way), feel free to let me know, and we'll see how we could collaborate.\r\n", "\r\nStay tuned for our Xilinx Vivado version of this core.\r\n", "\r\nComments and feedback are surely appreciated and welcomed. Feel free to write to me (daniel.kho@opencores.org / daniel.kho@tauhop.com).\r\n", "\n            ", "\r\n", "\r\n- Designed in simple and elegant VHDL-2008, with conversions to VHDL-93 for synthesis.", "\r\n- Transactor and BFM designed using synthesisable VHDL procedures and VHDL records.", "\r\n- I/O ports are grouped into VHDL records.", "\r\n- Very simple to use. For a design unit to communicate with another design unit having the same interface, communications is done via a very simple procedure call. For a Master to send data to the Slave, one would just do the following:", "\r\n\u00a0\u00a0\u00a0\u00a0", "\r\nwhere ", " is the data which the master peripheral wishes to transfer to the slave peripheral.", "\r\n- Functional verification using ", " coverage-driven constrained random verification techniques.\r\n", "\r\n", "\r\n[Note that some of these characteristics reflect the current state of development of this project, and may change as this project evolves.]", "\r\n- Synchronous and pipelined logic, with asynchronous resets.", "\r\n- Huge chunks of combinatorial logic will also be synchronously reset.", "\r\n- Design is very generic, flexible, and scalable. Data widths can be easily adjusted, and the design was created with readability and scalability carefully thought out from the beginning.", "\r\n- Efficient and very small (77 LEs for Altera) AXI4-Stream Master if using a 32-bit data interface.", "\r\n- Quartus reported an Fmax of 277.47 MHz, for a 32-bit data bus under 85C temperature.", "\r\n", "\r\nAs of current status, this is the post-place-and-route summary. To produce similar results, compile this project with SignalTap tester removed, and use 32-bit bus-widths for both the data bus (", ") and the ", " testbench stimulus.", "\r\nNote that these results may be different if you use different bus widths, or Quartus settings, etc.", "\r\n", "\r\n", "\r\nHere are the corresponding timing summaries for the same compilation:", "\r\n", "\r\n", "\n            ", "This core has been verified with ModelSim and Quartus SignalTap II, using basic directed testcases as well as using OSVVM's coverage-driven constrained random verification techniques. I would like to increase the test coverage in future. I also plan to add hardware results from Xilinx ChipScope, as well as simulation results from other simulators as well. If you have simulated or verified this core, please let me know how this core works with your toolchain. I believe Aldec ActiveHDL/Riviera Pro and Synopsys Synplify should have no problems, but I have yet to try them out.\r\n", "\r\nModelSim simulation of AXI4-Stream Master write operations:", "\r\n", "\r\n", "\r\nAcquired measurements from Quartus SignalTap II embedded logic analyser, showing AXI4-Stream Master write operations:", "\r\n", "\r\n", "\r\nI plan to implement AXI4-Stream Slave read operations as well. Currently, the testbench emulates a simple AXI4-Stream slave which responds to write requests from our AXI4-Stream Master, however, it does not latch and save the data. In future, I will design the Slave also as a TLM/BFM model, which will then replace the existing testbench code that emulates the Slave. The Master will connect directly to the Slave, and both Master and Slave models will validate each other. To ensure reliable data transfer, I plan to implement transmit and receive FIFOs, and verify the design with separate clock domains for the Master and Slave. Stay tuned!\r\n", "\n            1. More comprehensive directed, constrained random, and functional coverage testcases.\r\n", "2. Documentation: design specification write-up, verification plan write-up, verification results.\r\n", "3. AXI4-Stream Slave, and optional features defined by AMBA AXI4 specification.\r\n", "4. Verify + debug design on more tools: Cadence (Encounter RTL, ncvhdl, ncsim), Mentor Graphics (Precision RTL), Synopsys (VCS-MX, Design Compiler, Synplify), Aldec (Riviera, ActiveHDL), Xilinx (Vivado, ISE, ISim).\r\n", "5. Bash/Python script to perform automatic VHDL-2008 to VHDL-93 conversion to workaround different tools.\n        ", "\n            Tauhop Solutions - Penang, Malaysia\r\n", "Facebook: ", "\r\n", "site: ", "\r\n", "email: info@tauhop.com\r\n", "tel.: +60 16 333 0498 (daniel)\n        "]},
{"details": ["\n    Name: ahb_system_generator", "\n    Created: Sep 23, 2004", "\n    Updated: Mar 31, 2013", "\n        SVN Updated: Feb  7, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 6 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Category :: SoC\r\n", "Language :: VHDL\r\n", "License :: LGPL\r\n", "Development status :: Production/Stable\r\n", "\r\n", "\n        ", "\n            - AMBAtm specification compliant (rev 2.0)\r\n", "- unified approach to multi-layer, lite and full amba systems\r\n", "- programmable arbiter\r\n", "- \"template\" master with programmable internal fifo and read/write latencies\r\n", "- \"template\" slave with simple default behaviour (i.e. no \"split/retry\" responses)\r\n", "- GUI for start-up\r\n", "- testbench generation specific to the created system\r\n", "- check of connection correctness\n        ", "\n            The intention is to provide an easy way to configure, create and simulate a \"complete\" AHB system.\r\n", "\r\n", "The main block is the \"AHB matrix\", in which every declared master has to be connected to one or more slaves.\r\n", "\r\n", "In order to test the connectivity of the matrix, and to evaluate performance tradeoffs between different architectural choises a configurable arbitration scheme and a \"template\" model of a parametrizable master and slave are provided.\r\n", "\r\n", "A complete testbench is also available to test the main write and read accesses made by every master to the slaves mapped on its address space.\r\n", "\r\n", "AHB system generator is a script which builds via GUI or file all .vhd files required to\r\n", "simulate the system: masters, slaves, arbiters, decoders, master and slave muxes.\r\n", "\r\n", "To run the AHB system generator you must have installed PERL and a GUI PERL module called Tk (see for example ", "\r\n", "\r\n", "This configurator is provided by www.ipdesign.eu\n        ", "\n            - Slave with \"retry\" behaviour with internal fifo\r\n", "- Slave with \"split\"  behaviour with internal fifo\r\n", "- APB slave (simple memory-like interface)\r\n", "\r\n", "More IPs on www.ipdesign.eu:\r\n", "- AHB/AHB bridge\r\n", "- AHB/APB bridge\r\n", "- AHB DMA\r\n", "- WB/AHB bridge\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: zpu", "\n    Created: Jan  2, 2008", "\n    Updated: Sep 14, 2009", "\n        SVN Updated: Sep  8, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Read about some of the professional uses of the ZPU: ", "\r\n", "\r\n", "The ZPU is a small, portable CPU core with a GCC toolchain and eCos RTOS support. \r\n", "\r\n", "The ZPU has a FreeBSD license for the HDL and GPL for the rest. This allows deployments to implement any version of the ZPU they want without running into commercial problems, but if improvements are done to the architecture as such, then they need to be contributed back. \r\n", "\r\n", "One strength of the ZPU is that it is tiny and therefore easy to implement from scratch to suit specialized needs and optimizations.\r\n", "\r\n", "The ZPU is under git version control(opencores will probably get git source control eventually), meanwhile more information, complete source and more examples can be found at ", "\r\n", "\r\n", "Per Jan 1. 2008, Zylin has the Copyright for the ZPU, i.e. Zylin is free to decide that the ZPU shall have a BSD license for HDL + GPL for the rest.\r\n", "\r\n", "Sincerley,\r\n", "\r\n", "\u00d8yvind Harboe\r\n", "General Manager\r\n", "\r\n", "\n        ", "\n            - Small size: 442 LUT @ 95 MHz after P&R w/32 bit datapath Xilinx XC3S400 \r\n", "- Verilog and VHDL implementations available\r\n", "- Wishbone\r\n", "- Code size 80% of ARM Thumb\r\n", "- GCC toolchain(GDB, newlib, libstdc++)\r\n", "- FreeRTOS support\r\n", "- eCos embedded operating system support\n        ", "\n            1. download the latest svn snapshot ", "\r\n", "\r\n", "2. tar -xzvf zpu_latest.tar.gz\r\n", "\r\n", "3. In zpu/readme.txt you find information on how to run a\r\n", "hello world ModelSim example. \r\n", "\r\n", "4. Run the simulation in ModelSim, this outputs a log.txt which prints\r\n", "\"Hello world\".\r\n", "\r\n", "5. Modify hello.c, rebuild and run in ModelSim(also described in readme.txt)\r\n", "\r\n", "Other smoketests:\r\n", "\r\n", "Look in the example/simzpu_small.do simulation file and use zpu_small_core.vhd as the top level file in your synthesis software. You'll then need to pull in zpu_config.vhd, hello_world.vhd, and zpupkg.vhd. You now have a standalone ZPU that can be used to smoketest synthesis and do some crude resource measurements relatively easily in just about any synthesis software. Adjust zpu_config.vhd to use DontCareValue='X' and maxAddrBitBRAM to fit the RAM you want to assign to the ZPU for your synthesis test.\r\n", "\r\n", "Normally such synthesis GUI/IDE's should allow you to pick some FPGA part and choose some default pins for the top level ZPU. This will allow you to run some smoketest on synthesis and get a feel for timing constraints, size, etc. after place and route.\r\n", "\r\n", "This will either \"just work\" as the hello_world.vhd uses inference to implement BRAM's, or you will have to implement a dual port RAM according to the FPGA architecture and synthesis software requirements. You may run into some small hickups with certain synthesis software, such as Synplify where you need to tweak the ZPU code to complete synthesis.\r\n", "\r\n", "If you modify the ZPU, it is possible to run a verification procedure against larger applications to check that the modifications do not introduce subtle bugs.\n        ", "\n            The ZPU source is kept in a git repository rather than CVS(OpenCores.org does not yet support git).\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "The OpenCores CVS server contains a snapshot of the source code before it was moved to git.\r\n", "\n        "]},
{"details": ["\n    Name: yellowstar", "\n    Created: Dec 12, 2001", "\n    Updated: Jul  8, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            FILE: ys_logo.jpg\r\n", "DESCRIPTION: Yellow Star Logo\r\n", "\n        ", "\n            It is capable of executing 32bit instructions based on the MIPS R3000 microprocessor instruction set and has been tested running large blocks of compiled C code.\r\n", "Fully functional and compatible interrupt system. Can handle all exceptions cleanly and correctly.\r\n", "Two 2Kbyte (Data and Instruction) direct mapped caches with coherency.\r\n", "Memory management unit with 64 Entry TLB fully compatible to original design.\r\n", "Designed in Powerview package but can be distributed in hierarchical schematic EDIF\r\n", "Warning: The manual stated instructions SWL, SWR, LWL and LWR which are not implemented. And there are known bugs in the code.\r\n", "For more information go to ", "\r\n", "The processor was created using schematics and there is NO RTL VHDL or Verilog.\n        ", "\n            - 32 entry 32bit Register bank created out of Ram blocks to save space\r\n", "- 5 Stage pipeline\r\n", "- Two 2Kb caches\r\n", "- 64 Entry CAM TLB\r\n", "- Exact exception handling\r\n", "- One coprocessor\n        ", "\n            - Tested running all instructions that are implemented.\r\n", "- Tested and running correctly at 50MHz\r\n", "- Memory menagement and caching buggy\r\n", "- Looking for good schematic entry people to take control of the project\r\n", "- Looking for people to convert the project files to other platforms\n        ", "\n            Free for commercial and non-commercial use as long as the author and warning notices are maintained. \r\n", "\r\n", "This software is provided by Charlie Brej \"as is\" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the author or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute goods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.\r\n", "\r\n", "MIPS(R) and R3000(R) are registered trademarks of MIPS Technologies, Inc. in the United States and other countries.  OpenCores and Charles Brej are not affiliated in any way with MIPS Technologies, Inc.\n        "]},
{"details": ["\n    Name: yacc", "\n    Created: Apr 22, 2005", "\n    Updated: Apr 25, 2005", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            YACC (Yet Another CPU CPU) is MIPS I (TM) subset cpu written in Verilog-2001 HDL. YACC has 5 pipeline and shows 110 DMIPS in stratix2 with synthesized allowable clock of 165MHz. It is independent design of plasma, although YACC uses gcc-elf-mips tools provided by Steve Rhords, author of plasma (Most mips written in VHDL).\r\n", "The core was developed by using my Simulator, with post layout gate simulation, and tested by actual FPGAs, using Xilinx spartan3 starter kit and Cyclone by Altera,running 800 digits of pi calculation ,(255,223) Reed Solomon Error Correction ,and Interactive calculator written by C language.\n        ", "\n            MIPS(R) is a registered trademark and MIPS I(TM) is a trademark of MIPS Technologies, Inc. MIPS Technologies, Inc. does not endorse and is not associated with this project. Tak.Sugawara is not  affiliated in any way with MIPS Technologies, Inc.\r\n", "\n        ", "\n            I have no idea if implementing this core will or will not violate\r\n", "patents, copyrights or cause any other type of lawsuits.\r\n", "\r\n", "I provide this core \"as is\", without any warranties. If you decide to\r\n", "build this core, you are responsible for any legal resolutions, such\r\n", "as patents and copyrights, and perhaps others ....\r\n", "\r\n", "THIS SOURCE FILE(S) IS/ARE PROVIDED \"AS IS\" AND WITHOUT ANY\r\n", "EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\r\n", "LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\r\n", "FITNESS FOR A PARTICULAR PURPOSE.\n        ", "\n            When I was developing VHDL to Verilog translator , I found plasma core in opencores. It is excellent work to learn a lot. After I translated plasma written by VHDL to Verilog HDL almost automatically using my Translator, I stated to design my own CPU per following target spec.\r\n", "\r\n", "-works with free C compiler ->use plasma resources \r\n", "-pretend to be fast (Dhrystone benchmark test requires only 16KB memory! Actually ..) \r\n", "-5 stage pipeline \r\n", "-use dual port memory in FPGA  \r\n", "-works with Altera/Xilinx FPGAs \r\n", "-with minimum logic cells in FPGA \r\n", "\n        "]},
{"details": ["\n    Name: z3", "\n    Created: Nov 28, 2014", "\n    Updated: Nov 30, 2014", "\n        SVN Updated: Nov 30, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            A Verilog implementation of the Infocom Z-Machine V3. The spec the Z3 follows is ", " Specifically version 3, the so called \"Standard\" games. These were released between 1982 and 1987 and covers most Infocom games. Z3 passes the \"CZECH - Comprehensive Z-machine Emulation CHecker\" by Amir Karger. And is known to run at least Zork I, Hitchhiker's Guide to the Galaxy, Planetfall and Curses (by Graham Nelson).\r\n", "\r\n", "The following YouTube video shows it in action: ", "\r\n", "\r\n", "To provide the input/output a terminal is implemented in a BIOS (in Z-machine code) which exists in the ROM above 120Kb. The IO related opcodes (like @print) vector into the BIOS which provides the terminal. A small number of extra op codes were added so the BIOS could interface with an LCD touchscreen and access the top 64Kb of RAM (which shadows the ROM).\r\n", "\r\n", "Save/Restore isn't currently supported (as my hardware hasn't any storage) and is the only notable omission.\n        "]},
{"details": ["\n    Name: y80e", "\n    Created: May 27, 2013", "\n    Updated: May 29, 2013", "\n        SVN Updated: May 28, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Z80/Z180 compatible processor softcore. Based on Y80 project described in the book 'Microprocessor Design Using Verilog HDL' of Monte Dalryple from Systemyde. If you want to understand internals of CPU then this book may greately help you to do it.\r\n", "\r\n", "This CPU supports commonly used Z80 undocumented instructions: operations with halfs of index registers and SLI/SLL (Shift Left Logical). Optionally it supports emulation of R register.\r\n", "\r\n", "Additionally CPU is Z180 compatible. Supported all IO, MLT (implemented via standard Verilog multiplication) and TST instructions.\r\n", "\r\n", "Moreover, it has all non-ADL instructions from Zilog eZ80 CPU:\r\n", "IND2, IND2R, INDM, INDMR, INDRX,\r\n", "INI2, INI2R, INIM, INIMR, INIRX,\r\n", "LD (HL),rr\r\n", "LD (ii+d),rr\r\n", "LD rr,(HL)\r\n", "LD rr,(ii+d)\r\n", "LEA rr,ii+d\r\n", "OUTD2, OTD2R, OTDRX\r\n", "OUTI2, OTI2R, OTIRX\r\n", "PEA ii+d\r\n", "\r\n", "ii - IX, IY\r\n", "rr - BC, DE, HL, IX, IY\r\n", "\r\n", "Compiled for Altera Cyclone III FPGA. It consumes 2557 logical cells.\n        "]},
{"details": ["\n    Name: tg68", "\n    Created: Nov 26, 2007", "\n    Updated: Jun 13, 2012", "\n        SVN Updated: Jun 14, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Only the SVN was updated.\r\n", "I don't know how I can update the latest version download. \n        ", "\n            This is a stable Version of a 68000 compatible CPU. \r\n", "It is an adapted Version to use with the Minimig Core. \r\n", "\r\n", "\"compatible\" means that most of byte and word Instructions are cycle exact but many other Instructions are faster.\r\n", "\"adapted\" means that the synchronous Mode, some bus control signals and the FC Out are missing. They are not needed for the minimig. \n        ", "\n            circa 3600 LC's on a ALTERA Cyclone II,\r\n", "circa 2700 Slices an a XILINX Spartan 3,\r\n", "\n        ", "\n            Tested with the Dennis van Weeren Minimig Core on the C-One Board with FPGA Extender from Individual Computers.\r\n", "Source Code and Bitstreamfiles here:\r\n", "\r\n", "\r\n", "latest bugfix:\r\n", "14.jun.2010 bugfix Movem with regmask=XFFFF and regmask=X0000\r\n", "            Add missing Illegal $4AFC\r\n", "10.feb.2009 shift and rotation opcode\r\n", "21.jan.2009 insert missing RTR opcode\r\n", "\n        "]},
{"details": ["\n    Name: tiny64", "\n    Created: Mar 20, 2004", "\n    Updated: May  7, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            A 64-Bit RISC CPU with minial resource usage. Every opcode is executed in 2 clock cycles.\r\n", "The word size is configurable via XLEN from 32 up to the FPGA limit. The assembler supports also\r\n", "differnet word sizes.\r\n", "Due simplicity TinyX supports no interrupts, cache, MMU, FPU.\r\n", "Interrupts may supported in the future.\r\n", "\r\n", "The assembler syntax is unusual. because jump instructions are coded\r\n", "as MOV to the R7 register.\r\n", "\r\n", "At March 2004 is was tested 32-Bit and 64-Bit in the Xilinx XC2S200 SpartanII.\r\n", "\n        ", "\n            2 clock cycles on all op-codes\r\n", "R7, the PC is equal handled like a normal register\r\n", "\n        ", "\n            March, 24th 2004 beta\n        "]},
{"details": ["\n    Name: ucore", "\n    Created: Nov 20, 2005", "\n    Updated: Aug  4, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n              UCore is a RISC microprocessor compatible of the MIPS32R2 Instruction Set. It can run all the MIPS32R2 instructions except the branch likely instructions. For these instructions are not recommended in the specification. \r\n", "  The processor has 6 pipeline stages: Instruction Fetch (IF), Instruction Decode (ID), Register Fetch (RF), Execution (EX), Memory Access (MEM) and Write Back (WB).\r\n", "  The processor uses synchronous ram as its Register file, data RAM and instruction RAM, which makes it be easily implemented in both FPGA and ASIC, especially in FPGA.\r\n", "  The processor\u0081fs instruction set and privilege resource are designed strictly to the \u0081gMIPS32 Architecture for Programmers\u0081h (Volume I-III\u0081CRevision 2.50) specification from MIPS Technologies Inc. \r\n", "  The processor has been implemented in FPGA and synthesized by Design Compiler using UMC .18 ASIC libraries. When MMU and Caches are disabled, it can run at a speed 150MHz and occupies 3000 LUTs in Xilinx XC2VP30 (using Synplify 8.1 Pro and ISE 7.1i) FPGA; when implemented in Altera EP2C35 (using Quartus 6.0) FPGA, it can run at a speed of 120MHz and occupies 3300 LEs. \r\n", "  When using a MMU with 64 entries of fully associated TLBs, an 8KB data cache and an 8KB instruction cache, it occupies 13300 LUTs and can run at 46 MHz in XCV4LX160 FPGA.\r\n", "  According to the synthesis results of Design Compiler, the speed of the processor is 480 MHz and its power consumption is 197.6mW in Virtual Silicon\u0081fs UMC .18 ASIC libraries, occupying 0.466 square millimeter silicon or 23,000 equivalents gates.\r\n", "  Many programs have been ported to the processor and tested on FPGA. They are uC/OS II, U-Boot, UIP/LWIP, Dhrystone, WEB&NAT server and so on. There are also some small test programs. The first one is an assembly program modified from the Plasma core written by Steve Rhoads, it tests all the instruction of UCore processor. The second and third ones are a 1000bits PI calculation program and a program sorting 10 short integers, which are written in C and compiled using GCC MIPS cross compiler. \r\n", "  Programs used to test the SDRAM, Flash, SRAM, VGA modules and a program used to download Motorola S-record format binary to the chip from UART are developed and tested, too. You can get detailed information from the Makefile locating in the tool dictionary. \r\n", "  I have built a system using the processor core. It contains the UCore, a 32k data/instruction on-chip SRAM, a timer, a UART, a SRAM controller, a SDRAM controller, a Nor Flash Controller, a VGA controller and a MAC controller and packet buffer for it. The system has been tested on Altera\u0081fs DE2 board and a Xilinx XC2VP30 FPGA board at 50MHz. All the programs mentioned in the previous section have been successfully run in FPGA.\r\n", "  I have run the Dhrystone benchmark version 2.1 in the system, and it's score is 141DMIPS when run at 100 MHz.  \r\n", "  I have used GCC 3.2.3 and GCC 4.0.0 cross tool chains to generate the codes, then I translated them to format I need using a Perl script wrote by myself.\r\n", "  The scripts used to build the GNU tool chain is lying in test/utils dictionary, named build-gcc.sh. You can download the GNU tool chain source and use the script to build a cross tool chain of yourself.\r\n", "  I have verified the processor carefully. If anyone finds there are bugs in it, please let me know. I\u0081fll fix it as quickly as possible. My email is whitewill@163.com.\r\n", "  The code can be downloaded from the download section. The URL is ", " It\u0081fs an old version of the system. \r\n", "  The latest version will be uploaded to CVS repository latter.\r\n", "\n        ", "\n            - Fully MIPS32R2 Compatilbe\r\n", "- Verified on many FPGA board\r\n", "- Confiugrable MMU and Cache modules\n        ", "\n            - status1\n", "- status2\n        ", "\n            Empty block\n        "]},
{"details": ["\n    Name: wb_z80", "\n    Created: Mar  4, 2004", "\n    Updated: Jun 25, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            While the greatest percentage of the logic for this processor has been verified, there are still a copule of areas of concern.\r\n", "1) Interrupt testing should be better\r\n", "2) hazard testing should be better.\r\n", "3) There is at present not a written verification plan. \r\n", "\r\n", "Guy Hutchison (see TV80 project) has synthesized an early version of the core in a 130nm TSMC process.  He determined the design to contain about 20k gates and run at about 240 Mhz.   While the speed is somewhat less than \"target\", optomizations of the logic should increase this somewhat.   \r\n", "\r\n", "I have synthesized the present version in Altera tools.  (Stratus II)  Initial resuts indicate 90 Mhz operation.  I hope to be able to improve that significantly with some \r\n", "work on the decoding logic.\r\n", "\r\n", "This machine executes a byte instruction on each clock tick.\r\n", "\r\n", "I have noticed a significant number of downloads of the code.  I do not consider present level of verification sufficient to risk use in an expensive ASIC.  I would like to run a well considered (and well written) \"hazards\" test.  If anyone is interested enough in the core to volunteer help with this area please let me know. \r\n", "\r\n", "10/2/2007  bugs reported by Stephen Warren and Howard Harte have been fixed and the data base has been updated.  We are working on a better hazard test and a complete verification plan.  \n        ", "\n            \n        ", "\n            Design document complete and in CVS\r\n", "RTL  complete and built\r\n", "Testbench complete\r\n", "initial verification phase (complete instruction test) PASSED\n        ", "\n            The purpose of the Wishbone Z80 development is to provide a \u201clow-end engine\u201d (written in verilog) that could logically interface with many of the low-end verilog peripherals available to the community, while providing sufficient \u201chorsepower\u201d to be used effectively with the more interesting \u201chigh end\u201d peripherals. \r\n", "\r\n", "The deign is conceived to operate efficiently with internal static RAM.  Thus, a two stage pipeline is implemented to allow instruction execution at the access rate of a 32 kbyte RAM.  (This could be well over 300 Mhz. depending on implementation technology.)  \r\n", "\n        "]},
{"details": ["\n    Name: t65", "\n    Created: Nov  5, 2002", "\n    Updated: Mar 31, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Configurable cpu core that supports 6502, 65C02 and 65C816 instruction sets.\r\n\r\nA SoC debug system with ROM, RAM and two 16450 UARTs is included in the distribution. It is possible to run the NoICE debugger on this system.\r\n\r\nBatch files for runnning XST and Leonardo synthesis can be found in ", ". Check these scripts to see how to use the included VHDL ROM generators.\r\n\r\nBefore you can run the scripts you need to compile hex2rom and xrom or download binaries from ", ". You must also replace one of the hex files in sw/ or change the batch files to use another hex file.\r\n\r\nBrowse source code ", ".\r\nDownload latest tarball ", ".\r\n        ", "\n            - 6502 NMOS mode is cycle accurate, including dummy read and writes\r\n", "- Decimal mode is supported\r\n        ", "\n            - NMOS 6502 mode supports all documented instructions\r\n", "- 65C02 and 65C816 modes are incomplete\r\n", "- Complete enough to run EhBASIC\r\n", "- The standard 6502 core is cycle accurate and used in a wide number of projects\r\n", "\n        "]},
{"details": ["\n    Name: t80", "\n    Created: Apr 21, 2002", "\n    Updated: Jun  9, 2015", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Configurable cpu core that supports Z80, 8080 and gameboy instruction sets.\r\n\r\nZ80 and 8080 compability have been proven by numerous implementations of old computer and arcade systems.\r\nIt is used in the ", " project, a zx81, zx spectrum, trs80 and Jupiter ACE clone project.\r\nAnd also in the ", " project.\r\n\r\nA Z80 SoC debug system with ROM, RAM and two 16450 UARTs is included in the distribution. It is possible to run the NoICE debugger on this system.\r\n\r\nBatch files for runnning XST and Leonardo synthesis can be found in ", ". Check these scripts to see how to use the included VHDL ROM generators.\r\n\r\nBefore you can run the scripts you need to compile hex2rom and xrom or download binaries from ", ". You must also replace one of the hex files in sw/ or change the batch files to use another hex file.\r\n\r\nThe ", " C compiler can be used with T80. The \"embedded\" configuration can be used with the debug system without modifications.\r\n\r\nBrowse source code ", ".\r\nDownload latest tarball ", ".\r\n\r\nThanks to MikeJ for some serious debugging and to the zxgate project members for invaluable Z80 information.\r\n        ", "\n            - Technology independent\r\n", "- Up to 35MHz clock in Spartan2 -5 using XST synthesis\r\n", "- 10k gates and up to 100MHz in 0.18 CMOS\r\n", "- Supports all undocumented Z80 instructions\r\n", "- Supports all Z80 interrupt modes\r\n", "- Correct R register behaviour\r\n", "- Correct Z80 instruction timing\r\n", "- Almost 100% correct behavior of the undocumented Z80 flags\r\n", "- Both a synchronous (for implementation) and an asynchronous (for board level simulations) Z80 top level\r\n", "- Only a synchronous 8080 top level\r\n        ", "\n            - Z80 compability and functionality thoroughly verified in FPGA\r\n", "- The gameboy mode is experimental\r\n", "- No gameboy top level\r\n        "]},
{"details": ["\n    Name: t51", "\n    Created: Apr 25, 2002", "\n    Updated: Apr  1, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            8052 compatible microcontroller core.\r\n\r\nTwo different top levels:\r\nT8052:\r\n- Single cycle synchronous RAM/ROM\r\n- Wishbone bus interface for memory mapped peripherals\r\nT8032:\r\n- Wishbone bus interface\r\n\r\nA utility to create VHDL ROMs is also included.\r\nTo create a ROM compatible with the 8052 core type:\r\nhex2rom [-b] inputfile.hex ROM52 13b8s > ROM52.vhd\r\nLeonardo Spectrum can infer the ROMs created with hex2rom to Xilinx block RAM.\r\n\r\nI have also modified the baud rate recognition of the BASIC-52 ROM to support the faster instruction timing. The modified BASIC-52 might also work with other high speed 8032 compatible cores such as the 80c320.\r\n\r\nBrowse source code ", ".\r\nDownload latest tarball ", ".\r\n\n        ", "\n            - All peripherals/interrupts implemented\r\n", "- Single cycle per byte fetch\r\n", "- Supports synchronous RAM/ROM\r\n", "- Single cycle MOVX (8052)\r\n", "- Optional second DPTR\r\n", "- Technology independent\r\n", "- Three stage pipeline\r\n", "\n        "]},
{"details": ["\n    Name: t48", "\n    Created: Mar 23, 2004", "\n    Updated: Aug 19, 2009", "\n        SVN Updated: Aug 15, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 17 reported / 17 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "The T48 \u00b5Controller core is an implementation of the MCS-48 microcontroller family architecture. While being a controller core for SoC, it also aims for code-compatability and cycle-accuracy so that it can be used as a drop-in replacement for any MCS-48 controller.", "\r\n", "It can be configured to better suit the requirements and characteristics of the integrating system. On the other hand, nearly the full functionality of a stock 8048/8049 is available.", "\r\nSuch a sample system has been implemented in several FPGA families.", "The implementation has been done with the free version of the vendor tools (Quartus II 7.2sp3 and ISE 10.1). Your mileage may vary.", "Alongside with the microcontroller design, an implementation of the 8243 I/O expander chip is available.", "The T48 \u00b5Controller has been successfully integrated in the ", ", the ", ", and the ", " projects.", "\n            The project has Stable status:\r\n", "\n            ", "The first step of this project was to collect information of the original MCS-48 family architecture. The available documents were bundled in electronic form and represent a superset of the architecture specification for the T48 \u00b5Controller. Download this document here: ", " (link is external to OpenCores.org).", "\n            ", "The latest release of the T48 \u00b5Controller project is version 1.2.", "Get this and all previous versions of the design files from SVN: ", ".", "Please keep in mind that trunk/ is work in progress and might contain smaller or bigger problems.", "You should also check the ", " for known bugs and see if they affect your work.", "\n            ", "The verification of the T48 \u00b5Controller core is based on self-checking assembler tests that are executed with one single testbench.\r\nAll test programs contribute to the regression suite that allows automated, scripts-based verification whenever the design files have changed.", "The test suite will be split up into two parts. First, a set of tests is generated to proof that each single instruction works in the expected way. As this excludes all implementation specific issues and only looks at the architectural features, these tests are called black-blox tests.", "\r\nWhen issues with the internal implementation of some features arise, more in-depth tests are necessary to stimulate the design in a way that triggers potential bugs. These tests form the white-box test suite.", "A C-model of the core architecture is available that is used as a reference for the hardware design. This model is implemented as an executable program (native compiled code for the host system) and has been used for years now within the ", ". It executes the same assembler tests of the regression suite and by comparing the machine state after each instruction with the RTL implementation it acts as a instruction-cycle accurate reference.", "\n            ", "The following tools are integrated and are required for this project:"]},
{"details": ["\n    Name: t400", "\n    Created: May  5, 2006", "\n    Updated: Aug 19, 2009", "\n        SVN Updated: May 28, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "The T400 \u00b5Controller is an implementation of National's 4-bit COP400 microcontroller family architecture. It is intended to be used as a replacement for the original chip in SOCs recreating legacy systems.", "Its final target is to provide design variants that are compatible with the COP420/421 and COP410L/411L family members. All of them derived from the common t400_core design. Such a sample system has been implemented in several FPGA families.", "The implementation has been done with the free version of the vendor tools (Quartus II 7.2sp3 and ISE 10.1). Your mileage may vary.", "Altera EP1C12Q240C8:", "Xilinx Spartan-IIE XC2S300EPQ208-6:", "The T400 \u00b5Controller has been successfully integrated in the ", " project.", "\n            ", "The following tools are integrated and are required for this project:", "\n            ", "The project has Stable status:", "Known bugs will be logged on the ", ". Please feel free to enter any problems you encounter with this core.", "\n            ", "The COPS Family User's Guide and the specific datasheets can be downloaded from ", ".", "\n            ", "The latest release of the T400 \u00b5Controller project is version 1.1.", "Get this and all previous versions of the design files from SVN: ", ".", "Please keep in mind that trunk/ is work in progress and might contain smaller or bigger problems.", "You should also check the ", " for known bugs and see if they affect your work."]},
{"details": ["\n    Name: system68", "\n    Created: Sep  9, 2003", "\n    Updated: Apr  7, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            6800 System on a chip with added 6801 instructions. Fits on 200K Gate Spartan II board. Will fit on an XC2S100 if an external ROM is used.\r\n\r\n", "\r\n\r\nMichael Hasenfratz is working on a Wishbone version of System68 called\r\n", "\r\n\r\n6800 Flex Operating System and software is available from the ", " \n        ", "\n            - 6800/6801 instruction compatible core \r\n", "- MiniUART Modified to look like 6850 \r\n", "- Parallel I/O Port \r\n", "- Compact Flash interface \r\n", "- SWTBUG Monitor ROM \r\n", "- Dynamic Address Translation RAM for extended addressing\r\n", "- Bus Trap logic generates interrupts on any address/data/control signal\n        ", "\n            - Runs old SWTPC & TSC Basic Interpreters.\r\n", "- Implemented on BurchED B5-X300 Spartan2e FPGA board.\r\n", "- Update More Reliable UART runs at 57.6 Kb.\r\n", "- Uses 25 MHz System Clock\r\n", "- CPU runs with 12.5 MHz E clock.\r\n", "\n        "]},
{"details": ["\n    Name: wb4pb", "\n    Created: Jan  5, 2010", "\n    Updated: Apr 22, 2011", "\n        SVN Updated: Aug 28, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            This project provides interface logic and assembler routines, giving PicoBlaze (TM) embedded soft-uC the ability to access wishbone systems or slave cores as an 8-bit master device. There is no native hardware handshake mechanism at PicoBlaze (TM) ports, so wishbone wait-state recognition is done by software polling. Some standard wishbone slave peripherals like GPIO and UART are included as well.\n        ", "\n            ", "\n            ", "\n            "]},
{"details": ["\n    Name: ssbcc", "\n    Created: Jan  2, 2014", "\n    Updated: Feb  5, 2014", "\n        SVN Updated: Sep 29, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            "]},
{"details": ["\n    Name: sayeh_processor", "\n    Created: May 30, 2008", "\n    Updated: Jul 17, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The SAYEH processor (Simple Architecture,Yet Enough Hardware) has been designed for educational and benchmarking purpose. Relying on the material of the computer architecture course provide the necessary background for understanding details of the hardware of SAYEH, so it could be useful IP core for graduate or last year undergraduate students to implement computer architecture materials in a real processor design.\r\n", "Originally SAYEH has been developed in ECE at university of Tehran, IRAN.\n        ", "\n            SAYEH has a register file that is used for data processing instructions, also has a 16-bit data bus, 16-bit address bus and 16-bit instruction set architecture with simple arithmetic ,logic and communicative instructions.\r\n", " (SAYEH Architecture)\n        ", "\n            - Latest version of Verilog description files uploaded. \r\n", "- necessary information and documentation gathered from computer students in University of Tehran.   \n        "]},
{"details": ["\n    Name: risc5x", "\n    Created: Jan 17, 2002", "\n    Updated: Sep  9, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A small RISC CPU (written in VHDL) that is compatible with the 12 bit opcode PIC family. Single cycle operation normally, two cycles when the program counter is modified. Clock speeds of over 40Mhz are possible when using the Xilinx Virtex optimizations.\r\n", "Licensed under LGPL.\n        ", "\n            This core is distributed in the hope that it will be useful, but\r\n", "WITHOUT ANY WARRANTY; without even the implied warranty of\r\n", "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n", "\r\n", "You are responsible for any legal issues arising from the use of this core.\r\n", "\r\n", "PIC is a trademark of Microchip Technology Inc. \n        ", "\n            The core has a single pipeline stage and is run from a single clock, so (ignoring program counter changes) a 40Mhz clock will give 40 MIPS processing speed. Any instruction which modifies the program counter, for example a branch or skip, will result in a pipeline stall and this will only cost one additional clock cycle.\r\n", "\r\n", "The CPU architecture chosen is not particularly FPGA friendly, for example multiplexers are generally quite expensive. The maximum combinatorial path delay is also long, so to ease the place and route tool's job the core is written at a low level. It instantiates a number of  library macros, for example a 4:1 mux. Two versions of these are given, one is generic VHDL and the second is optimised for Xilinx Virtex series (including Spartan devices). A constraints file locates the datapath macros within the device and ensures an easy fit and high clock speed.\r\n", "\r\n", "\r\n", "\n        ", "\n            The core builds to around 110 Virtex CLBS (depending on synthesis).\r\n", "\r\n", ">33 Mhz in a Virtex e - 6  \r\n", ">40 Mhz in a Virtex e - 8 \n        ", "\n            Complete.\r\n", "Tested successfully on hw.\r\n", "rel1.1 source zip released. \r\n        ", "\n            24/02/02\r\n", "Added hex_conv software\r\n", "\r\n", "12/02/02\r\n", "Added rel1.1 source zip : bug fix\r\n", "  Used wrong bank select bits in direct addressing \r\n", "  INDF register returns 0 when indirectly read\r\n", "  FSR bit 8 always set\r\n", "\r\n", "Added rel1.0 source zip : \r\n", "  Initial release\n        "]},
{"details": ["\n    Name: s1_core", "\n    Created: Jan  3, 2007", "\n    Updated: Oct  1, 2012", "\n        SVN Updated: May  7, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "The S1 Core is a reduced version of the OpenSPARC T1 released by Sun Microsystems. While the T1 is a complete microprocessor with 8 cores (capable of running up to 32 concurrent threads) and includes a crossbar switch, L2 Caches and several other interfaces, the S1 takes only one 64-bit SPARC v9 core (capable of running from 1 up to 4 concurrent threads) and includes a Wishbone Master Interface to connect to the cores available on OpenCores.", "For more details please refer to the ", ", or to the new ", " that contains several updates and bug-fixes."]},
{"details": ["\n    Name: risc16f84", "\n    Created: May  7, 2002", "\n    Updated: Jun 28, 2014", "\n        SVN Updated: Jun 28, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            ", "The risc16f84 project is intended to provide a small, easy to use microcontroller in Verilog.  The original code was VHDL, but I have done a wonderful translation of it into good clean Verilog code. (Well, I think it is wonderful, anyway.)  The VHDL code was called \"CQPIC\" and it was published in 1999 by Sumio Morioka of Japan, in the December 1999 issue of \"Transistor Gijutsu Magazine.\"  I did the translation by hand, and then tested the design in actual hardware by running C code on it, and looking for correct behavior.  I realize that this is not 100% test coverage, but I have found and fixed several bugs by this method -- including an error in the carry bit logic of the original code!  There are four separate versions of the microcontroller presented here.  The \"original\" one is called \"risc16f84.v\" and it includes all the logic needed to implement the entire 16f84 chip functionality as published in the original article.  ", "However, I have realized over time, that a person using a microcontroller inside of an FPGA does not have the same constraints (i.e. on port sizes, number of pins, multiple functions needed on each pin, etc.) as the original chip designers, and so I have taken liberty in the other three versions, to simplify the logic by removing items that may not be wanted inside of an FPGA or ASIC implementation.  For example, there is a version called \"risc16f84_lite.v\" which has no interface for the EEPROM...", "Another version, called \"risc16f84_small.v\" further eliminates the multiple interrupt sources present on the original chip (since in a PIC there is only one interrupt vector defined, so interrupt service routines must do some \"checking\" anyway to determine the source of an interrupt - why bother having separate inputs defined?  Just make up your own interrupt structure and use it the way you like inside of your chip!)", " Finally, the fourth version, called \"risc16f84_clk2x.v\" further removes the port A and port B interfaces, since you can create as many ports as you like inside of your own chip.  Toward this end, \"risc16f84_clk2x.v\" also includes an \"auxiliary\" bus interface, allowing the microcontroller to access 64k bytes of registers, ports and hardware peripherals, all defined within their own address space -- not within the limited register space of the PIC microcontrollers.  I have used it to address a screen with 12288 pixels, and each pixel has its own address.  It is easy to define addresses for the auxiliary bus components in most PIC code generation tools, so this works out nicely.", "The code is written in Verilog, and was sythesized into a Xilinx SpartanII XC2S200 chip.  Debugging was done in actual hardware, with an HP16500 series logic analyzer, and there are no simulation testbenches for these modules.", "The hardware debugger used to test this core is ", "\n            - The original \"risc16f84.v\" supports execution with 4 clocks per instruction, as in PIC microcontrollers.\r\n", "- The \"risc16f84_clk2x\" version uses only 2 clocks per instruction.\r\n", "- Xilinx DPRAM blocks were used to implement the processor register space and program ROM.  These RAMs are dual-ported, so I have mapped the other port into the \"auxiliary bus\" space.\r\n", "- Debugging is aided by the use of \"rs232_syscon.v\" which is a hardware \"monitor\" that allows read/write of addresses on the auxiliary bus.  Since program memory is mapped into the auxiliary bus, programs can be downloaded via rs232_syscon.\r\n", "- Since the registers and all useful peripherals are present on the auxiliary bus, single stepping and hardware breakpoints are implemented through the rs232_syscon interface (a serial port connects to a terminal window.)\r\n", "- I have been downloading C code through the serial port, in the form of rs232_syscon write commands.\r\n", "- A PERL script transforms s-record files into rs232_syscon write commands.\r\n", "- The cores are parameterized. \r\n", "- The code has good comments.\r\n", "- Interrupts are supported and tested in \"risc16f84_clk2x.v\"\r\n        ", "\n            - The \"risc16f84_clk2x.v\" core has been coded completely, synthesized and tested for correct operation (and debugged!) inside a Xilinx XC2S200 chip.\r\n", "- The \"risc16f84_clk2x.v\" core was tested running C-code at 65.28 MHz (approx. 32 MIPS), and uses 321 Virtex slices.  This test is not exhaustive, I only bumped up the clock speed until the program \"froze up.\"\r\n", "- The entire debugging environment, including risc16f84_clk2x, rs232_syscon, single stepping and breakpoint logic and registers, consumes about 900 Virtex slices, and runs at frequencies up to 65.28 MHz or so, when implemented inside of a Xilinx XC2S200 FPGA.\r\n", "- There is no documentation yet.  Please email me if you have specific questions and you cannot figure out how the modules work.  The code has some good comments in it.\r\n", "- \"risc16f84_clk2x.v\" has been rewritten somewhat.  It supports a single edge-triggered interrupt now.\r\n", "- The debugging environment has been updated to include support for generating slow interrupts (user controlled bit) and periodic interrupts (narrow pulses.)\r\n", "- The entire SoC was compiled using Xilinx WebPack (XST synthesizer) free tools!  It works at various clock rates, and has an automatic BAUD rate circuit that resynchronizes when the user changes speeds.\r\n", "- A user reported a mathematical error on subtract opcodes.  This was verified and fixed.  Thanks to Stefan Frank for diligently reporting the bug!\r\n", "- New \"README.TXT\" file describes some of the helpful hints and arcane tips for running the design.  Enjoy!\r\n        "]},
{"details": ["\n    Name: ppx16", "\n    Created: May 14, 2002", "\n    Updated: Jan 19, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Microcontroller core compatible with 16C55 and 16F84.\r\n\r\nSingle cycle VHDL implementations of 16C55 and 16F84. Four times faster than the original MCUs, otherwise timing compatible. Watchdog and EEPROM are not implemented. Both implementations use the configurable PPX16 12/14 bit instruction width core, other MCUs using the same instruction set can easily be implemented by creating a new top level.\r\n\r\nThere are utilities included that can create VHDL ROMs for simulation and synthesis. The utilites create generic ROMs that can be used for simulation and for synthesis with Leonardo and also Xilinx specific ROMs that can be used for XST synthesis.\r\n\r\nBatch files for runnning XST and Leonardo synthesis can be found in ", ".\r\n\r\nBefore you can run the scripts you need to compile hex2rom and xrom or download binaries from ", ".\r\nYou must also put your hex file in either sw/c55.hex or sw/f84.hex.\r\nIf you need to change target device and settings you need to edit the batch files and some of the files in ", ".\r\n\r\nThe Leonardo batch file also creates the VHDL ROMs you need to run the Modelsim compile script in ", ".\r\n\r\nIf you want to create ROMs without running the scripts use the following parameters for 16C55:\r\nhex2rom [-b] inputfile.hex ROM55 9l12s > ROM55.vhd\r\nAnd these for 16F84:\r\nhex2rom [-b] inputfile.hex ROM84 10l14s > ROM84.vhd\r\nHex2rom can read intel/motorola hex and binary files.\r\n\r\nBrowse source code ", ".\r\nDownload latest tarball ", ".\r\n        ", "\n            - High performance, > 30 MIPS in Spartan 2 -5\r\n", "- Supports synchronous ROM/RAM (Xilinx Block RAM compatible)\r\n", "- Parametric\r\n", "- Technology independent\r\n        ", "\n            - Tested in FPGA\n        "]},
{"details": ["\n    Name: plasma_fpu", "\n    Created: Jul  1, 2015", "\n    Updated: Jul  7, 2015", "\n        SVN Updated: Jul  7, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            This project is based on an implementation of MIPS I specified core by Steve Rhoads: ", "\r\n", "entity plasma is", "\u00a0  generic(", "\u00a0\u00a0      core_idx                : natural := 0;", "\u00a0\u00a0      FPU_FLAG                : string  := \"OF\";", "\u00a0\u00a0      SIM_FLAG                : string  := \"ON\";", "\u00a0\u00a0      DEBUG_FLAG              : string  := \"OF\"", "\u00a0    );", "\u00a0    port(", "\u00a0\u00a0      clk                     : in  std_logic;", "\u00a0\u00a0      rst                     : in  std_logic;", "\u00a0\u00a0      instr_addr              : out std_logic_vector(31 downto 0);", "\u00a0\u00a0      data_addr               : out std_logic_vector(31 downto 0);", "\u00a0\u00a0      rd_mask                 : out std_logic_vector(3  downto 0);", "\u00a0\u00a0      wr_mask                 : out std_logic_vector(3  downto 0);", "\u00a0\u00a0      instr_stall             : in  std_logic;", "\u00a0\u00a0      data_stall              : in  std_logic;", "\u00a0\u00a0      instr_in                : in  std_logic_vector(31 downto 0);", "\u00a0\u00a0      data_to_cpu             : in  std_logic_vector(31 downto 0);", "\u00a0\u00a0      data_from_cpu           : out std_logic_vector(31 downto 0)", "\u00a0    );", "end entity plasma;", " generic flags controls choice of intern components: ", " 1. execute create_workspace.sh ", " 2. go to (automatically create) directore \"workspace\"", " 3. execute \"run.sh\" script", " The program executes an encoding algorithm that converts an .bmp file to .jp2 file (JPEG2000 format). Source code is from ", ". The folder test/program contains simulation output (file \"memory_out.mem\") and a script \"check_output.sh\" can generate a binary from this output. By replacing the file \"test.bmp\" and executing script \"create_test.sh\" the given .bmp file will be converted by simulation run."]},
{"details": ["\n    Name: plasma", "\n    Created: Sep 25, 2001", "\n    Updated: Nov 21, 2016", "\n        SVN Updated: Aug 30, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 50 reported / 44 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            The Plasma CPU is a small synthesizable 32-bit RISC microprocessor.  It is currently running a live web server with an interrupt controller, UART, SRAM or DDR SDRAM controller, and Ethernet controller.  The Plasma CPU executes all MIPS I(TM) user mode instructions except unaligned load and store operations (see \"Avoiding Limitations\" below).  \r\n", "\r\n", "This \"clean room\" CPU core is implemented in VHDL with either a two or three-stage pipeline.  It is running at 25 MHz on a Xilinx FPGA and also verified on an Altera FPGA.\n        ", "\n            The Plasma CPU along with the Plasma RTOS and TCP/IP protocol stack are now running a live ", " on a Xilinx FPGA.", "\r\n", "\r\n\u00a0\u00a0", "\r\n\u00a0\u00a0", "\r\n\n        ", "\n            ", "\n        ", "\n            FILE: cpu.gif\n", "DESCRIPTION: \n", "\n        ", "\n            The CPU is implemented with a two or three stage pipeline with an additional optional stage for memory read and writes.  (Using the three stage pipeline enables \"pipeline.vhd\" which delays some control signals into the next stage.)\r\n\r\nAn ADD instruction would take the following steps:\r\n", "Stage #0:\r\n", "\n            The Plasma Version 3 core now contains a bidirectional serial port, interrupt controller, and hardware timer.  Version 3.5 added a DDR SDRAM controller, Ethernet MAC, and Flash interface.  There is C and assembly code for the Plasma Real-Time Operating System -- a fully preemptive ", " supporting threads, semaphores, mutexes, message queues, timers, heaps, an interrupt manager, ANSI C library, single precision floating point library, TCP/IP protocol stack, and Web server.\n        ", "\n            ", "\n            ", "The Opencores Subversion web page can create the 130KB ", " file containing all the latest code.\n        ", "\n            ", "The MIPS(tm) GCC ELF compiler for Windows is available ", " (2.4MB).  The OpenCores server wouldn't let me save zip files so I had to rename it with an '.odt' extention.  Rename the file from gccmips_elf.odt to gccmips_elf.zip before unzipping the files into the trunk\\gccmips_elf directory.  Add this directory to your executable PATH environment:  set path=%PATH%;YOUR_DIR\\trunk\\gccmips_elf\r\n", "If you use Windows and don't have a Microsoft C compiler for Windows, you will need pre-compiled versions of the ", " (rename as tools.zip) which should be placed in the tools directory.  \r\n", "You may also need a Windows version of ", ".  Rename the file gmake_zip.odt to gmake.zip before unzipping.\n        ", "\n            See the tabs at the top for additional build instructions:\r\n", "\n            The CPU core operates in Big Endian mode by default. To operate in Little Endian mode, change \"little_endian\" from \"00\" to \"11\" in the file mem_ctrl.vhd. \n        ", "\n            All signals are active high.  Here are the signals for writing a character to address 0xffff when using a two stage pipeline:\r\n", "\n            The CPU core was synthesized for several different FPGAs:\r\n", "\n            ", "\n            MIPS(R) is a registered trademark and MIPS I(TM) is a trademark of MIPS Technologies, Inc. in the United States and other countries.  MIPS Technologies, Inc. does not endorse and is not associated with this project.  OpenCores and Steve Rhoads are not affiliated in any way with MIPS Technologies, Inc.\n        ", "\n            The Plasma CPU project has been placed into the public domain by its original author and is free for commercial and non-commercial use.  \r\n", "\r\n", "This software is provided \"as is\" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed.\n        ", "\n            This section describes how to avoid the two main limitations of the Plasma CPU core.  The first limitation is that unaligned load and store operations are not supported since they were patented.  This means that when loading or storing 32-bit values the memory address must be on a 32-bit aligned address.  [The ", " for the unaligned memory access instructions expired Dec 23, 2006.]\r\n\r\n", "Most RISC CPUs have limited support for unaligned memory accesses.  The GCC MIPS compiler does not normally generate unaligned memory accesses.  Try compiling a C program and then look in the listing file if any of these MIPS instructions are used:  LWL, LWR, SWL, or SWR.  If needed, there is a GCC patch to never generate unaligned memory accesses at ", "->GCC Modifications.\r\n\r\n", "The second main limitation of the Plasma CPU is that exceptions (BREAK and SYSCALL opcodes) must not be placed immediately after a branch instruction (in the branch delay slot).  The main uses for exceptions are software interrupts for debugger support and calling operating system calls.  \n        ", "\n            Several groups have published how they have used the Plasma CPU.\r\n"]},
{"details": ["\n    Name: riscmcu", "\n    Created: Apr 13, 2002", "\n    Updated: Sep 17, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            \r\n\r\n", "RISCMCU is  based on the features and instruction set of Atmel AVR AT90S1200 RISC Microcontroller.", " : Based on the report of Synopsys  FPGA Express", " ", " : Altera EPF10K20RC240-4 Device (on Altera UP1 Education Board)", "     ", "     ", " \t\t\t* To download any of the files, please \t\t\t", " on the link and select 'Save Target As'.", "Please visit ", " to  download more files.", " ", " You will ", " be able to synthesis (compile)  the project with MaxPlus II. The project was synthesized with Synopsis FPGA  Express 3.4. At that time, Altera was providing free license for it. However,  Altera no longer provides free license file. If you are lucky, your university  might have purchased it and make it available in the lab. Else, you will need to  purchase it yourself.", " But the good news is, Altera Quartus II is able to  synthesis the project and it is FREE! Get it ", ". You will need to do some minor modifications to modules v_rom and v_ram.  Comment out or remove the 'inclock' and 'outclock' lines in port(). Else,  Quartus will complaint.", " ", "."]},
{"details": ["\n    Name: pdp8", "\n    Created: Jul  8, 2012", "\n    Updated: Dec  1, 2016", "\n        SVN Updated: Oct 31, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "The PDP-8 was one of the earliest minicomputers and was in use from the mid 1960s into the 1980s.\r\n\r\n", "Because the PDP-8 was relatively inexpensive and was available in various forms for many years, the PDP-8\r\nis remembered fondly by many programmers and engineers\r\n\r\n", "This project implements a complete PDP-8 system.\r\nThe system includes the many of the basic PDP-8 peripherals including:\r\n", "The system passes all relevant diagnostics (MAINDECs) with the exception of the RK8E\r\nDisk Controller. The system boots OS/8 and runs all applications. ", "The design has been implemented and tested on a \r\n", "\r\nEvaluation Board using the Xilinx ISE Webpack Version 13.3 toolset.", "\r\n\r\n", "\r\n\r\n", "The design has been implemented and tested on a \r\n", "\r\nEvaluation Board using the Quartus II 11.1 Build 173 Full Version toolset.", "The design has been implemented and tested on a \r\n", "\r\nBoard using the Quartus II 11.1 Build 173 Full Version toolset.", "The design is currently being implemented on a \r\n", "\r\nDevelopment and Education board using the Quartus II 12.0 Web Edition tool set.", "The DE0-Nano is expected to be the least expensive platform for this device\r\nand is available at a cost of $86.25 from (among other places)\r\n", ".", " ", " ", " "]},
{"details": ["\n    Name: or1200_hp", "\n    Created: Oct 22, 2010", "\n    Updated: Aug  6, 2013", "\n        SVN Updated: Nov 12, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The project is based on OpenCores' OR1200 project.\r\n", "\r\n", "The core is now hyper pipelined. It is a technique to multiply the functionality \r\n", "of a design by adding registers (called pipeline stage registers) to the core logic \r\n", "in order to multiply its functionality. If you are interested in the technology, go to www.cloudx.cc\r\n", "\r\n", "The functional behavior of the OR1200 remains the same, the hyper pipelined\r\n", "version is used when multiple OR1200 cores (2, 3, ...) are instantiated in the \r\n", "same design (multicores). \r\n", "\r\n", "The main benefit is the multiplication of the core's functionality by only \r\n", "implementing registers. This leads to a reduced size compared to the \r\n", "individual instantiation of the cores. This is a great advantage for ASICs \r\n", "but obviously very attractive for FPGAs with their already existing registers. \r\n", "\r\n", "Another issue is the performance of the resulting hyper pipelined OR1200 core. \r\n", "The pipeline stage registers are timing driven placed to partition the critical \r\n", "path into equal parts, which leads to an almost multiplied performance of the \r\n", "design. The timing is optimized for a Virtex 5 device from Xilinx. \r\n", "\r\n", "The modifications are done on RTL, so that the project can be used in an \r\n", "RTL based testbench. \r\n", "\r\n", "The project shows the modified RTL code with 2, 3 and 4 times multiplied \r\n", "functionality. It is delivered with a testbench and a detailed documentation. \r\n", "\r\n", "\r\n", "Enjoy ...\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: or1k", "\n    Created: Sep 25, 2001", "\n    Updated: Mar  1, 2012", "\n        SVN Updated: Feb 24, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 166 reported / 166 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: next186", "\n    Created: Mar 12, 2012", "\n    Updated: May 31, 2013", "\n        SVN Updated: May 13, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            80186 instruction compatible, high performance processor, able to execute up to 40MIPS on a Spartan3AN FPGA. It requires ~1500 slices (25%) on a Spartan3AN. The speed performance is comparable with a 486 in 16bit real mode.\n        ", "\n            Next186 CPU features:\r\n", "  - All 80186 intstructions are implemented according with the 80186 specifications (excepting ENTER instruction, which uses always 0 as the second parameter - level).\r\n", "  - all 80186 exceptions implemented (divide error - INT0, Trace - INT1, Overflow - INT4, Bounds - INT5, Invalid opcode - INT6, Coprocesor exception - INT7)\r\n", "  - Mascable and non mascable interrupts implemented. If a repeat block instruction is interrupted, the return address is the repeated instruction including all prefixes. This allows fully resume of repeated instruction after interrupt, with no other precautions.\r\n", "  - Designed with 2 buses: 16bit data / 20bit data_address and 48bit instruction / 20bit instruction_address. This allows most instructions to be executed in one clock cycle.\r\n", "  - In order to link the CPU unit on a single memory bus, these sepparate data/instruction buses must be multiplexed by a dedicated bus interface unit (BIU).\r\n", "  - It is able to execute up to 40 MIPS on Spartan XC3S700AN speed grade -4, performances comparable with a 486 CPU (real mode, 16bit only).\r\n", "  - Small size, the CPU + BIU requires ~25%  or 1500 slices - on Spartan XC3S700AN\r\n", " \r\n", "\r\n", "Next186 BIU (Bus Interface Unit) features:\r\n", "  - Links the CPU with a 32bit static synchronous RAM (or cache)\r\n", "  - Able to address up to 1MB \r\n", "  - 16byte instruction prefetch queue\r\n", "  - Works at 2 X CPU frequency (80Mhz on Spartan3AN), requiring minimum 2T for an instruction.\r\n", "  - The 32bit data bus and the double CPU clock allows the instruction queue to be almost always full, avoiding the CPU starving. The data un-alignement penalties are required only when data words crosses the 4byte boundaries.\r\n", "\r\n", "\r\n", "\n        ", "\n            How to compute each instruction duration, in BIU clock cycles:", "\r\n\r\n1 - From the Next186_features.doc see for each instruction how many CPU T states are required (you will notice they are always\r\n  less or equal than 486 and much less than the original 80186)", "\r\n\r\n2 - Multiply this number by 2 - the BIU works at double CPU frequency because it needs to multiplex the data and instructions,\r\n  in order to keep the CPU permanently fed with instructions.", "\r\n\r\n3 - Add penalties, as follows:", "\r\n\r\n  +1T for each memory read - because of the synchronous SRAM which need this extra cycle to deliver the data", "\r\n  +2T for each jump - required to flush and re-fill the instruction queue", "\r\n  +1T for each 16bit(word) read/write which overlaps the 4byte boundary - specific to 32bit bus width", "\r\n  +1T if the jump is made at an address with the latest 2bits 11 - specific to 32bit bus width", "\r\n  +1T when the instruction queue empties - this case appears very rare, when a lot of 5-6 bytes memory write instructions are executed in direct sequence", "\r\n\r\nSome examples:", "\r\n\r\n  - \"lea ax,[bx+si+1234]\" requires 2T", "\r\n  - \"mov word ptr [bx+si+1234],5678\" requires 2T", "\r\n  - \"add ax, 2345\" requires 2T", "\r\n  - \"xchg al, [bx]\" requires 4T", "\r\n  - \"inc word ptr [1]\" requires 5T (2x2T inc M + 1T read)", "\r\n  - \"inc word ptr [3]\" requires 7T (2x2T inc M + 1T read + 1T unaligned read + 1T unaligned write)", "\r\n  - \"imul ax,bx,234\" requires 4T (2x2T imul)", "\r\n  - \"loop address != 3(mod 4)\" requires 4T/2T (2x1T loop + 2T flush if jump)", "\r\n  - \"loop address == 3(mod 4)\" requires 5T/2T (2x1T loop + 2T flush if jump + 1T unaligned jump)", "\r\n  - \"call address 0\" requires 4T (2x1T call near + 2T flush", "\r\n  - \"ret address 0\" requires 7T (2x2T ret + 1T read penalty + 2T flush)", "\r\n\r\n\n        ", "\n            The package contains a minimal demonstration system containing:\r\n", "\t- Next80186 CPU\r\n", "\t- Next80186 BIU - 32bit bus, 80Mhz (the clock can be easily modified by tuning the DCM - but you also need to adjust the bootstrap RS232 receiver code which uses delays made with loop).\r\n", "\t- 4KB SRAM (2KB at address 00000h - interrupt vector zone, 2KB at address FF800h - ROM zone)\r\n", "\t- 1DCM with 50Mhz input and 80Mhz output\r\n", "The system is connected to RS232, to 9 LEDs on board and to a RESET button. \r\n", "The SRAM is preloaded with a RS232 (115200bps) bootstrap able to load and run an executable at address FF80:0100.\r\n", "A sample .ASM application is provided (a simple RS232 feedback loop, with a mini memory dump feature).\n        ", "\n            Booting DOS 6.22 on a Next186 PC AT SoC Xilinx Spartan 3AN used at ~50% ", "(64MB DDR2, simplified VGA, PS2 KB and mouse, SDCard 4GB, 33MIPS, speaker sound)", "\r\n", "\r\n", "NC V5.0", "\r\n", "\r\n", "Running BC++ v2.0", "\r\n", "\r\n", "Running Turbo Pascal 7", "\r\n", "\r\n", "Indy MCGA", "\r\n", "\r\n", "Prince of Persia 2 MCGA", "\r\n", "\r\n", "WordPerfect 6.0 in 640x480x256", "\r\n", "'\r\n", "BattleChess4000 in 640x480x256, using EMM", "\r\n", "\n        "]},
{"details": ["\n    Name: nextz80", "\n    Created: Mar 18, 2011", "\n    Updated: Jul  3, 2014", "\n        SVN Updated: Feb  6, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            - Z80 compatible processor.\r\n", "- All documented / un-documented intstructions are implemented. \r\n", "- All documented / un-documented flags are implemented.\r\n", "- All (doc / un-doc) flags are changed accordingly by all (doc / un-doc)instructions. The block instructions (LDx, CPx, INx, OUTx) have only the documented effects on flags. The Bit n,(IX/IY+d) and BIT n,(HL) un-documented flags XF and YF are implemented like the BIT n,r XF and YF, not actually like on the real Z80 CPU.\r\n", "- All interrupt modes implemented: NMI, IM0, IM1, IM2.\r\n", "- R register available. \r\n", "- Fast conditional jump/call/ret takes only 1 T state if not executed. \r\n", "- Fast block instructions: LDxR - 3 T states/byte, INxR/OTxR - 2 T states/byte, CPxR - 4 T states / byte \r\n", "- Each CPU machine cycle takes (mainly) one clock T state. This makes this processor over 4 times faster than a Z80 at the same clock frequency (some instructions are up to 10 times faster). \r\n", "- Works at up to 40MHZ on Spartan XC3S700AN speed grade -4) - performances similar or better than a real Z80 running at 160Mhz. \r\n", "- Small size (~12%, ~700 slices - on Spartan XC3S700AN). \r\n", "- Tested with ZEXDOC (fully compliant) and with ZEXALL (all OK except CPx(R), LDx(R), BIT n, (IX/IY+d), BIT n, (HL) - fail because of the un-documented XF and YF flags). \n        ", "\n            The test bench is a micro computer based on NextZ80 processor (tested on Xilinx Spartan 3AN).\r\n", "Main features:\r\n", "- NextZ80 CPU running at 40 MHZ\r\n", "- the CPU receives maskable interrupt at the end of each scan line. The interrupt vector is 0x00, allowing all IM modes (IM0 = NOP, IM1 = RST38, IM2 = jump at mem[I:0]). It can be used for border effects or for ink - paper - video memory effects.\r\n", "- 32 KB static RAM\r\n", "- VGA (640*480) screen, with 128 lines upper border, 80x24 characters (8x8 pixels each), and 160 lines lower border.\r\n", "- screen buffer (1920 bytes) at address 0x7800\r\n", "- character map (2048 bytes) at address 0x7000\r\n", "- output port 1 - border color (R3G3B2)\r\n", "- output port 2 - ink color (R3G3B2)\r\n", "- output port 4 - paper color (R3G3B2)\r\n", "- output port 8 - {bit0 = PS/2 clk, bit1 = PS/2 data, bit2 = RS232 TxD}\r\n", "- input port 0 - scan line lower 8 bits\r\n", "- input port 1 - { bit1:0 = scan line upper 2 bits, bit2 = PS/2 clk, bit3 = PS/2 data, bit4 = RS232 RxD}\r\n", "- 1 DCM (supplied with 50 MHZ), providing the 25MHZ VGA clock and 120MHZ system clock.\r\n", "- 1 reset button\r\n", "- 1 HALT LED\r\n", "- RS232 interface\r\n", "- PS/2 keyboard interface\r\n", "The CPU is fed with 120Mhz, but 2 from 3 states is in WAIT. This way, the CPU runs at 40Mhz, allowing one clock state for the video generator to read the memory (no contention between CPU and VGA).\r\n", "The system clock is flexible, it can be adjusted from 120Mhz, by re-programming the DCM\r\n", "The boot loader waits for RS232 (115200 bps) to receive a binary file. It places it at address 100h and then launches it. The binary file can be a .COM CP/M file, which uses at most BDOS 2 and 9 functions (print char and string) - this is the case for ZEXDOC.COM and ZEXALL.COM, which may be directly uploaded.\r\n", "\r\n", "A RS232 communication application is provided (SerialComm).\n        ", "\n            Benchmark results: ", "\r\nThe ZEXALL/ZEXDOC Z80 instruction exerciser takes 5min:16sec to finalize. ", "\r\n\r\n", "\r\n", "\r\n\r\n\n        "]},
{"details": ["\n    Name: openmsp430", "\n    Created: Jun 30, 2009", "\n    Updated: Feb 16, 2018", "\n        SVN Updated: Aug 17, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 37 reported / 36 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            \r\n"]},
{"details": ["\n    Name: open8_urisc", "\n    Created: Sep 11, 2006", "\n    Updated: Jul 20, 2016", "\n        SVN Updated: Jul 25, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 4 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            This is a \"clean\" reimplementation of the Vautomation uRISC processor core (aka the \"V8\", also named the Arclite core) based on ISA documentation only.\r\n", "\r\nIt implements the full v8 architecture with a few additions, most of which are optional:\r\n", "\r\n* Thirty-six basic instructions (and four new instructions)\r\n", "\r\n* 8-bit PSR(Program Status Register) with Zero, Carry, Negative, and Interrupt status bits, and 4 general purpose status bits.\r\n", "\r\n* Eight 8-bit registers, R0 though R7.\r\n", "\r\n* Accumulator register (R0)\r\n", "\r\n* A 16-bit program counter\r\n", "\r\n* Any two adjacent registers may be paired to create a 16-bit index register.\r\n", "\r\n* Three basic addressing modes; addressed, indexed, and indexed with offset\r\n", "\r\nThe design adds a few new features, which can be enabled through generics:\r\n", "\r\n* An optional auto-increment for indexed addressing modes (\"LDX R4++\" is equivalent to \"LDX R4 ; UPP R4\" )\r\n", "\r\n* A new branching instruction, DBNZ (Decrement, and Branch if Not Zero)\r\n", "\r\n* A new math instruction, MUL, uses on-board multipliers.\r\n", "\r\n* The interrupt mask can now be set with the new instructions SMSK and GMSK\r\n", "\r\nThe Open8 is being designed to work optimally in newer FPGA architectures.  It assumes 2 clocks for memory and register file latency.\r\n", "\r\nThis design has now fielded as a test stimulus controller hosted in an Altera 3C40, not once - but twice. It's primarily serving as a data acquisition controller / packet generator in those designs, and has performed trouble-free for well over a year. Additionally, as part of the test stimulus system, the Open8 is responsible for synchronizing output frequencies with the device under test. Due to the nature of these calculations, a 16-bit ALU/co-processor was written to \"hardware accelerate\" common math functions, rather than have to write emulations in assembly. This ALU has been included in the SVN repository. The Open8, and its ALU coprocessor, use about 2400 LE's in the FPGA.\r\n", "\r\nIt has also been fielded in several non-shipping test instruments and small emulators hosted in Altera 3C16's, where it performs a variety of tasks. I am presently looking to use it as a packet processor to bridge between a PC and a custom digital waveform generator design.\r\n", "\n        ", "\n            - Model is written in VHDL ('93)\r\n", "\r\n- Simple RISC architecture and instruction set. All instructions fit in a single byte, with either 1 or 2 operands.\r\n", "\r\n- 16-bit PC / address allows for 64kB of directly accessible memory (can be expanded with paging)\r\n- Flat memory model allows code or data to be placed anywhere in the memory map, as well as easily supporting self-modifying code.\r\n", "\r\n- Moderate number of general purpose registers\r\n", "\r\n  + Eight byte-wide registers.\r\n", "\r\n  + Any two registers may be paired as (Rn+1:Rn) to create an index register\r\n", "  + R0 acts an the accumulator\r\n", "- 8 interrupts, 1 NMI, 7 maskable. Interrupt controller is built into the core.\r\n", "  + Interrupt controller keeps track of interrupt order and priority\r\n", "  + Interrupt mask is controllable through two new instructions, SMSK and GMSK.\r\n", "- Reasonably small gate-count, with strong fMax in \"low-end\" devices.\n        ", "\n            - Complete! The CPU has been synthesized and tested on an Altera DE2 board (Cyclone II 2C35).\r\n", "\r\n- [UPDATE:  the Hi-Tech compiler is no longer available.]  Hi-Tech has now made their C compiler for the v8/Arclite architecture available as a demo. Note, the Open8 implements instructions that aren't in the stock v8/Arc core, so some of the generated code could probably be accelerated with a bit of hand optimization. (the DBNZ Rn instruction won't be used in loops for example)\r\n", "\r\n- Source VHDL for the Open8 can be retrieved from either the \"download\" link, or from the SVN repository, above.\r\n", "\r\n- An assembly language reference manual has been added to the source repository (March 20, 2011)\r\n", "\r\n- A port of GNU binutils is in the SVN repository.  This is a beta release, and has not yet been incorporated into the official binutils source base.  Please report any bugs here, not at the binutils bugzilla.\r\n", "\r\n- The Open8 is getting its first real use in a test set. It is implemented alongside a number of hardware accelerators, relegating it to primarily moving things around in memory, but so far it has performed well. There are some minor alterations, including an option to replace BRK with WAI - or WAit_for_Interrupt. When selected, there is no longer a true NOP available, but the ability to halt the processor waiting for an interrupt is a useful capability.\r\n", "\r\n- BRK_Implements_WAI is tested, and shown to work correctly. An updated processor model has been checked in to SVN.\r\n", "\r\n- The Open 8 has now successfully been fielded! The core in question used the new features recently checked in, and has worked remarkably well as a supervisory processor in a larger FPGA design. The whole system features a lot of hardware accelerators, including a 16-bit, bus-addressed ALU to handle some of the math, but using the Open8 has allowed the design to be a lot more flexible.\r\n", "\r\n- A port of the GNU C/C++ compiler is underway, with no release date yet targeted.  The calling conventions are still under design, and there will likely be changes to the instruction set to make it easier for the compiler to generate efficient code.\r\n", "\r\n- A few bugs were found while regression testing an updated version of the Open8 processor core. Apparently the vectored interrupt controller didn't always obey priority. Also, it appears that auto-incrementing indexed loads and stores didn't complete execution of the UPP command. These have been both corrected.\r\n", "\r\n- The ALU control signals were pipelined to improve fMax on smaller parts. This allowed a design targeting an Altera Cyclone 3C16 to go from ~60MHz to ~132MHz (without trying, the target frequency was 100MHz). Unfortunately, this also means that all math instructions (Opcodes 0 though 15 and GMSK) now take take 3 clock cycles to execute instead of one, like the MUL and UPP instructions. The only other instruction to suffer increased latency was the DBNZ instruction, which requires the status register to update before continuing. All other instructions retain their existing latencies. Unfortunately, this does imply that code should be regression tested on the model, as the total execution time in clock cycles will increase.\r\n", "\r\n- As part of the update, a lot of superfluous code was stripped out. The model should be a lot easier to understand.\n        "]},
{"details": ["\n    Name: mpx", "\n    Created: Mar 11, 2012", "\n    Updated: Sep 22, 2013", "\n        SVN Updated: Sep 22, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: mips_enhanced", "\n    Created: Nov 27, 2010", "\n    Updated: Apr 10, 2011", "\n        SVN Updated: Apr  9, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project is based on MIPS789 opencores project.We used MIPS789 core and added the cache infrastracture and AMBA bus from LEON3.The final core executes MIPS I instructions.It is downloaded on a Spartan3 fpga(gr-xc3s-1500).In order to test it we used the Leon3 Testbench.\n        "]},
{"details": ["\n    Name: navre", "\n    Created: Aug  5, 2010", "\n    Updated: Apr 19, 2013", "\n        SVN Updated: Aug 24, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\r\n\r\n", "\n            Even though simple C programs can be run, the Navr\u00e9 softcore still contains several bugs and testers are ", ".", "\r\n", "\r\nThe idea is to use Verilog simulations to run and verify every instruction just like the ", " test suite (which can be used for inspiration). Simple and incomplete test benches can be found with the SoftUSB core.", "\r\n", "\r\nIf you are interested in carrying out this work because you need an AVR compatible softcore in your design or just as a contribution to the Milkymist project, please contact ", " mailing list or drop by the #milkymist channel on the ", " IRC network.", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: neo430", "\n    Created: Oct 16, 2015", "\n    Updated: Feb 12, 2018", "\n        SVN Updated: Feb 12, 2018", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n            ", "\n            If you have any questions about the NEO430 or if you want to give any kind of feedback, feel free to drop me some lines ;)", "\r\n"]},
{"details": ["\n    Name: mipsr2000", "\n    Created: Oct 12, 2012", "\n    Updated: Nov 23, 2016", "\n        SVN Updated: Jan  9, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The mipsr2000 is mips 32 bits processor. The processor implementation was designed by Lazaridis Dimitris.\r\n", "Main aspects\r\n", "The core is in 5 stages: \r\n", "\t- Instruction extraction \r\n", "\t- Instruction decoding \r\n", "\t- Execution \r\n", "\t- Memory access \r\n", "\t- Update registers\r\n", "It supports almost all instructions of mips technology, R type, I type, Branch, Jump and multiply packet instructions.\r\n", "The multiply result is stored until is needed regardless if others instructions follows.\r\n", "There is a separate memory for instructions and another for data read \u2013 write which can be changed.\r\n", "Each stage use one clock cycle. Both memories function in descending pulse and the remaining pulse is used for developing the necessery functions (e.g. pipeline), which makes the core faster and more flexible.\r\n", "All I types instructions are part decoded in first stage and all R types also part decoded in Alu control reducing the complexity in main Control unit (FSM).  \r\n", "All instructions are tested for correct execution. A test benchs from separate circuit implementation is also included (to verify the program which exists in Instruction memory).\r\n", "The mipsr2000 was integrated in an FPGA from Xilinx version 13.1 in Spartan 3 xc3s400-5fg456 target device but can be fit in another similar target device, but this project made mostly for general fpga devices.\r\n", "In case to be fitted in another fpga target device,specially  smaller fpga target device,  the clk = master clock signal and rst = master reset, must be fitted in device's global signal buffers to take advances of the device resources, (like the use of DCM, DONE) and different timing constraints must evaluate for timing analyses. \r\n", "The processor is implemented all in VHDL.\r\n", "\n        "]},
{"details": ["\n    Name: mips32r1", "\n    Created: Oct 14, 2012", "\n    Updated: Apr 12, 2014", "\n        SVN Updated: Jan  2, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            UPDATE 1-Jan-2014: This project has moved to GitHub. Please visit ", " for the latest code. No further changes will be committed to this repository.\r\n", "\r\n", "\r\n", "A 32-bit MIPS processor which aims for conformance to the MIPS32 Release 1 ISA. This processor implementation was designed and built by Grant Ayers as part of the eXtensible Utah Multicore (XUM) project at the University of Utah, 2011-2012. Feel free to send questions or feedback to grant DOT ayers AT stanford.edu.\n        ", "\n            - Single-issue in-order 5-stage pipeline with full forwarding and hazard detection.\r\n", "- Harvard architecture with separate instruction and data ports which can be combined if desired.\r\n", "- All required MIPS32 instructions are implemented, including hardware multiplication and division, fused multiply/adds, atomic load linked / store conditional, and unaligned loads and stores.\r\n", "- Complete Coprocessor 0 allows ISA-compliant interrupts, exceptions, and user/kernel modes.\r\n", "- No MMU and no FPU, with toolchain support for software-based floating point.\r\n", "- Hardware divider is small, multicycle, and runs asynchronously from the pipeline allowing some masking of latency.\r\n", "- Memory interface is separate from the processor for flexibility with connecting various RAMs.\r\n", "- Hardware is Big-Endian by default and supports reverse-endian mode for User mode.\r\n", "- Parameterized addresses for exception/interrupt vectors and boundary address between user/kernel regions.\r\n", "- Extensive documentation in-source and elsewhere.\r\n", "- Vendor-independent code.\r\n", "- A clean, modular design written from scratch.\r\n", "\r\n", "The project includes a standalone MIPS32 processor as well as a full System-on-Chip design targeted for the XUPV5-LX110T board. With minor changes (clock module, BRAM module, and pin constraints) the SoC can run on many hardware platforms.\r\n", "\r\n", "The standalone processor utilizes approximately 1,800 slice registers (2%) and 4,000 LUTs (5%) on a Virtex 5 LX110T.\r\n", "The SoC utilizes approximately 2,700 slice registers (3%) and 5,100 LUTs (7%) on a Virtex 5 LX110T.\r\n", "\n        ", "\n            1. Add hardware division. (DONE)\n        ", "\n            The following MMIO hardware drivers are included as part of the SoC design:\r\n", "\r\n", "- Basic single-master I2C driver.\r\n", "- 16x2 LCD driver for Sitronix ST7066U, Samsung S6A0069X / KS0066U, Hitachi HD44780, SMOS SED1278, or other compatible hardware.\r\n", "- LED driver.\r\n", "- Piezo transducer driver.\r\n", "- Switch input filter.\r\n", "- 115200 baud 8-N-1 serial port using only Tx and Rx with configurable baud rate.\r\n", "- 592 KB BRAM and clock generation for XUPV5 board.\r\n", "\r\n", "The following software is included:\r\n", "\r\n", "- XUM bootloader which loads programs from a PC to the FPGA. This is written in C# for Windows, however the boot protocol is simple and can be implemented in any operating system or not used at all.\n        ", "\n            The software toolchain is based on Binutils, GCC, and Newlib. It can be built for almost any platform, including unix-like environments and Windows (Cygwin). Instructions are included with the project.\r\n", "\r\n", "The current toolchain uses Binutils 2.21, GCC 4.7.1 (mpfr 3.0.1, mpc 0.9, gmp 5.0.5), and Newlib 1.20.0.\r\n", "\r\n", "The toolchain currently supports Big- and Little-Endian code as well as software floating point. Newlib C library stubs are left unchanged.\n        "]},
{"details": ["\n    Name: mips_fault_tolerant", "\n    Created: Jan 22, 2013", "\n    Updated: May 14, 2013", "\n        SVN Updated: May 14, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A fault tolerant for processor \r\n", "The mips \u2013 fault tolerant is mips 32 bits processor with error detection ( Fault Tolerant ). The processor implementation was designed by Lazaridis Dimitris.\r\n", "Main aspects\r\n", "The core is in 5 stages:\r\n", "- Instruction extraction\r\n", "- Instruction decoding\r\n", "- Execution\r\n", "- Memory access\r\n", "- Update registers\r\n", "It supports almost all instructions of mips technology, R type, I type, Branch, Jump and multiply packet instructions.\r\n", "The multiply result is stored until is needed regardless if others instructions follows.\r\n", "There is an error detection circuits for fault tolerant. It is implementing in hardware 100% which provides error detection at reset start-up.\r\n", "There is a separate memory for instructions and another for data read \u2013 write which can be changed.\r\n", "At each stage one clock cycle is used. Both memories function in descending pulse and the remaining pulse is used for developing the necessary functions (e.g. pipeline), which makes the core faster and more flexible.\r\n", "All I types instructions are part decoded in first stage and all R types also part decoded in Alu control reducing the complexity in main Control unit (FSM).\r\n", "All instructions are tested for correct execution. A test benchs from separate circuit implementation is also included (to verify the program which exists in Instruction memory).\r\n", "The mips - fault tolerant was integrated in an FPGA from Xilinx version 13.1 in Spartan 3 xc3s400-5tq144 target device but can be fit in another similar target device.\r\n", "The processor is implemented all in VHDL. \r\n", "Error detection\r\n", "With continuous scaling in CMOS technology the number of transistors grows more and more in a single chip. Chip multiprocessors (CMPs) are an efficient way for using this very large number of transistors integrated in a chip. Several researches show that high density integration makes modern processors prone to the risk of transient or permanent fault. However, the increase of temperature and decrease of the voltage in the chip lead to a higher susceptibility to faults. As the feature size shrinks the probability of a single transistor to become faulty, it increases due to the low threshold voltages.\r\n", "It is projected that the rate at which the transient errors occur will grow exponentially and will soon represent one of the most significant issues in the design of future generation high-performance microprocessors.\r\n", "This work proposes a fault tolerant architecture that tolerates the high fault rates that are expected in future technologies. In this work the multiplication block circuit is tested. \r\n", "Analyze\r\n", "In this method a multiplication is executed and the result is stored following by a comparison. It is start with initial value of 00001111\u2026. which this value executes a multiplication in multiplication circuit and the result is stored. It needs 64 machine cycles to complete this error detection. After the initial multiplication the numbers which are executed are subjected a shift one digit, following by a multiplication again and the result are stored in previous result. This is continuous for 64 machine cycle, where the final result is stored, including the previous results. In final stage of error detection the calculated result is compared with a correct stored result and if any error exists in multiplication array circuit this can be found. In this method the fault coverage is approximately 75% and 64 machine cycles are demanded. The error detection begins at start up before any execution. It has a high fault coverage and nearly fast execution due to hardware implementation, which will be more popular method for errors detection in future for the time saving (there is not time penalty), reliability, low cost and high presentence to fault coverage, low power consumption. \r\n", "A slide different circuit implementation but much more powerful: \r\n", "The multiplier circuit device made with and/h/f/adders.\r\n", "C\\AB    00   01  11  10\r\n", "0\t0    1\t 0   1\r\n", "1\t1    1c  0   1c\r\n", "I treat both exits as one because the point is to detect errors, from the karnaugh map we have:\r\n", "A\u2019B + AB\u2019 + CB\u2019 If combine the first two we have CB\u2019.\r\n", "There is the term +AB (from 111, 110) but I subtract it temporally to simplify the procedure.\r\n", "To implement it we need to include only one 0 in test vectors.\r\n", "If we will check a 4X4 bits multiplier with a shift in each clock as:\r\n", "1110, 1101, 1011, 0111 in y axes and the same in x axes, we will cover the 90% error detection in 8 machines cycles. I left one stage of variables out, for isolate detection to simplify the procedure, which is the value all -> 1s, which needs one machines cycle and cover the remaining 10% of error detection. The total procedure needs 10 machines cycles with an addition all -> 0s. The total coverage is 98-99%. In multiplier 32X32 bits it needs 66 machines cycles for total coverage. This method is fast enough and support total error detection with hardware implementation.\r\n", "\r\n", "Another alternate method: This method is hardware implemented 100% also and it is very simple. In first machine cycle a 0000\u2026 is executed in multiplication circuit and the result is compared with 0, if a 1 stack exists can be found here. (This covers the 50% error detection)\r\n", "In second cycle a number 1111111111111111111111111111111 is multiplied with the 10101010101010101010101010101010 and comparison is done with a correct stored value at the end of this cycle. The third and final stage a multiplication is done with reversed numbers to cover as much as possible of the multiplication array circuit and if any error detection exist is also found here. (In a sample multiplier 4X4 bits error detection coverage is about 2%) This method has smaller fault coverage about 54% but it is very fast, it is only need 3 machines cycles to complete the fault tolerance.\r\n", " \r\n", "Further research \r\n", "Most error detect methods for fault tolerance check the mips or a circuit at start up or at once or periodically to find any errors for fault coverage, but what if an error occurs during the tests? A fault data will process as correct. To work around with this, a non stop searching method is presented to test the mips continuously, it can be implement and find any error as it appears in born, further more if the fpga has enough space to relocate the damaged place it can be done in another undamaged.  \r\n", "To implement this error detect method, we can inject in fsm and detect the errors for fault tolerance. Knowing the next stage (instruction) through fsm, it is easy to start the test for \u201cmultiply\u201d block circuits, which error detection circuit could test the multiply circuits as long as the next instruction it is not concern this circuits, if a multiply instruction is coming up we can stop the process and continue when it is free again, thus we can find if an error occurs in this part of cpu and cover the fault tolerance. The same process it is possible to test and other critical part of mips or central unit and find if an error exist. The advantage in this method is that the error detect circuit works continuously. This method does not require double cores, but only some additional parts (low cost) and which can work in conjunction with fsm without consume the microprocessor\u2019s working time but it can work simultaneously. \r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: mips789", "\n    Created: Aug 24, 2007", "\n    Updated: Oct  2, 2014", "\n        SVN Updated: Nov 12, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a soft processor core written in verilog-2001 with five pipeline stages which supports almost MIPSI instructions. MIPS789 supports gcc-elf-mips tools provided by Steve Rhords, author of plasma.In fact, this core is designed based on this complier. I\u2019ve tested it by using a lot of C programs in a CYCLONE device EP1C6Q240  at 50MHZ frequence and it worked so well. By calculation, its CPI (cycle per instruction) is about 1.1 when run common programs.  \n        ", "\n            - Five stage \r\n", " - IF&ID: instructions fetch /decode.\r\n", " - RF: register fetch /generate next pc (branch included).\r\n", " - EXEC: execute instruction.\r\n", " - DMEM: read/write data from/to data memory or device.\r\n", " - WB: result write back to register bank.\r\n", "\r\n", "- supporting interrupt by using a special way.\r\n", " -  dynamic IRQ address, which means you can redefine the IRQ address by point of C programs.\r\n", " - using \u201cMFC0 $RX,$RX\u201d to save the Saved PC to register $RX.\r\n", " - using \u201cMTC0 $ZERO,$ZERO\u201dto return from an interrupt.\r\n", "\r\n", "- WELL TESTED \r\n", " - Tested running all instructions that are implemented generated by assembler.\r\n", " - Tested and running correctly at 50MHz in cyclone device EP1C6Q240 -8.\r\n", " - Tested running large blocks of compiled C code.\r\n", "\r\n", "- ATTIONS\r\n", " - Only support big endian.\r\n", " - DO NOT SUPPORT normal COP0 currently. \r\n", " - SWL, SWR, LWL and LWR are not implemented.\r\n", "\r\n", "\n        ", "\n            I have no idea if implementing this core will or will not violate \r\n", "patents, copyrights or cause any other type of lawsuits.\r\n", "\r\n", "I provide this core \"as is\", without any warranties. If you decide to \r\n", "build this core, you are responsible for any legal resolutions, such \r\n", "as patents and copyrights, and perhaps others ....\r\n", "\r\n", "THIS SOURCE FILE(S) IS/ARE PROVIDED \"AS IS\" AND WITHOUT ANY \r\n", "EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT \r\n", "LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND \r\n", "FITNESS FOR A PARTICULAR PURPOSE.\n        ", "\n            FILE: topview.GIF\r\n", "DESCRIPTION: structure of MIPS789\n        ", "\n            FILE: pi_2200.GIF\r\n", "DESCRIPTION: Calculating PI with 2200 digitals (about 5second @50MHZ)\r\n", "\n        "]},
{"details": ["\n    Name: minimips", "\n    Created: Jun  3, 2004", "\n    Updated: Mar 24, 2006", "\n        SVN Updated: Jun 18, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n             - The miniMIPS is a 32 bits core and has a Von Neumann architecture.\r\n", "\r\n", " - The miniMIPS is 5-stage pipeline :\r\n", "  - Instruction extraction\r\n", "  - Instruction decoding\r\n", "  - Execution\r\n", "  - Memory access\r\n", "  - Update registers\r\n", "\r\n", "- Only two instructions can access the memory. The others work on registers which are 32 bits large. The processor contains 32 registers.\r\n", "\r\n", "- Data hazards are resolved thanks to a bypass unit.\r\n", "\r\n", "- Branch hazards are resolved by predicting the address results.\r\n", "\r\n", "- Interruptions and exceptions are taken in account thanks to a system coprocessor.\n        ", "\n            An assembly gasm is provided with the project to generate the binaries for the miniMIPS cores.\r\n", "This program is developed by Samuel Hangou\u00ebt and Louis-Marie Mouton.\n        ", "\n            The miniMIPS was integrated in an FPGA from Xilinx Xc2V1000-5fg456.\r\n", "\r\n", "The processor speed is 50MHz. As at each cycle an instruction ends (except when there are stalls), that means 50 million instructions per second.\r\n", "\r\n", "The processor is used as a free example in the XSmart-ICE product (a generic emulator for core) from the french society Raisonance based in Grenoble.\n        ", "\n            The project miniMIPS is a processor core based on the MIPS I architecture. \r\n", "\r\n", "The project is born during a school project at the ENSERG (Ecole Nationale Sup\u00e9rieure d'Electronique et de Radio\u00e9lectricit\u00e9 de Grenoble), France.\r\n", "\r\n", "The main contributors are Samuel Hangou\u00ebt, S\u00e9bastien Jan, Louis-Marie Mouton and Olivier Schneider.\r\n", "\n        "]},
{"details": ["\n    Name: usimplez", "\n    Created: Mar  9, 2011", "\n    Updated: Nov 11, 2011", "\n        SVN Updated: Nov  9, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project is developed at Reconfigurable Computer Laboratory - FRM - UTN, and allows\r\n", "simulate and synthetize the Simplez processor. It is a didactic processor created by\r\n", "Gregorio Fern\u00e1ndez in his book \"Conceptos B\u00e1sicos de Arquitectura y Sistemas Operativos\",\r\n", "2003 Edition.\r\n", "\r\n", "This theoretical processor has a von Neuman architecture, with a set of eight instructions\r\n", "and 512 memory words. Each twelve bits word, contains two fields: operation code and\r\n", "data address. Basically, Simplez repeats cyclically the next three steps:\r\n", "\r\n", "- Reads the instruction stored in a main memory's address.\r\n", "- Decodes the instruction and executes it.\r\n", "- Generates the address in the main memory of the next instruction.\n        "]},
{"details": ["\n    Name: mcpu", "\n    Created: Jul 31, 2007", "\n    Updated: Jan 20, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            MCPU is a minimal cpu aimed to fit into a 32 Macrocell CPLD - one of the smallest available programmable logic devices. While this CPU is not powerful enough for real world applications it has proven itself as a valuable educational tool. The source code is just a single page and easily understood. Both VHDL and Verilog versions are supplied. The package comes with assembler, emulator and extensive documentation.\r\n", "\r\n", "Please let me know if you find a good use for this CPU and put your project/publication/lecture notes on the web. I will try to maintain a list here. I know it already has found good use for many purposes.\r\n", "\r\n", "\n        ", "\n            The CPU is accumulator based and supports a bare minimum of registers. The accumulator has a width of eight bits and is complemented by a carry flag. The program counter (PC) has a width of six bits which allows addressing of 64 eight bit words of memory. The memory is shared between program code and data.\n        ", "\n            \r\n", "See Github for latest updates\n        ", "\n            I moved the project archive over to Github for easier maintenance. \r\nYou can find the latest version here: ", "\r\n\r\nThe opencore archive will stay a v1.06b\n        "]},
{"details": ["\n    Name: minirisc", "\n    Created: Sep 25, 2001", "\n    Updated: Feb  6, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a Mini-RISC CPU/Microcontroller that is compatible with the PIC 16C57 from Microchip. Additional information about the instruction set and capabilities can be found at: www.microchip.com.\n        ", "\n            \r\nPIC, Microchip, etc. are Trademarks of Microchip Technology Inc. I have no idea if implementing this core will or will not violate patents, copyrights or cause any other type of lawsuits. I provide this core AS IS, without any warranties. If you decide to build this core, you are responsible for any legal resolutions, such as patents and copyrights, and perhaps others .... This source files may be used and distributed without restriction provided that all copyright statement are not removed from the files and that any derivative work contains the original copyright notices and the associated disclaimer.\r\n", "\n            - A PIC compatible Microcontroller that runs a lot faster \r\n", "- Synthesisable and technology independent design \r\n", "- Separate (External to the core) Program Memory \r\n", "- Options to extend the core \n        ", "\n            This design should be fully software compatible to the Microchip Implementation of the PIC 16C57, except for the following extensions:\r\n", "\r\n", "- Port A is full 8 bits wide \r\n", "- Hardware stack is 4 level deep [original 2 levels] (can be easily expanded) \r\n", "- Executions of instructions that modify the PC has became a lot more expensive due to the pipeline and execution of instructions on every cycle. Any instruction that writes to the PC (PC as destination (f), call, goto, retlw) now takes 4 cycles to execute (instead of 2 in the original implementation).\r\n", "- The 4 'skip' instructions, remain as in the original implementation: 1 cycle if not skipped, 2 cycles if skipped. \r\n", "- Sampling of IO ports might be off \r\n", "- Timer and watchdog might be off a few cycles \n        ", "\n            - About 80Mhz, in a Spartan IIe-50, 30% utilization\r\n", "- Single cycle instruction execution, except as noted above for PC modifications.\r\n", "- I estimate about 22K gates with the xilinx primitives, (excluding Register File and Program Memory). A Xilinx Vertex XCV100 can hold 4 of this cores and program memory, and still have some room left. \n        ", "\n            The only file you should edit if you really want to implement this core, is the 'primitives.v' file. It contains all parts that can be optimized, depending on the technology used. It includes memories, and arithmetic modules. I added a primitives_xilinx,v file and xilinx_primitives.zip which contain primitives for xilinx.\n        ", "\n            First version of the core is released. Included with the release is also a small test bench and several test programs written in assembly. MPLAB from Microchip, can be used to compile and develop additional code.\r\n", "\r\n", "The core can be downloaded from OpenCores CVS (see Downloads)\n        ", "\n            A very nice(and free) development environment with a software simulator is provided by Microchip on their web site. This environment works only on PCs. Various free and chimerical tools are available from third party, just Search the web !\r\n\r\n", " (http://www.microchip.com/10/Tools/PICmicro/DevEnv/)\n        ", "\n            Things that need to be done\r\n\r\n1.Write more test/compliance test vectors \r\n", "\n            6/18/200 RU\r\n", " - Added this Change Log\r\n", " - Added \"Development Tools\" Section|\r\n", " - Removed speed claims from the \"Performance\" Section: Need to re-synthsise the core and resolve synthesis tool/backend tool issues.\r\n", " - added \"risc_core_top.v\", a top level with tri-state buffers and program memory, to make it look like a real PIC !\r\n", " - Updated the primitives_xilinx.v so it will work correctly with Synplify and Synopsys FPGA compiler\n        ", "\n            "]},
{"details": ["\n    Name: marca", "\n    Created: Feb  1, 2007", "\n    Updated: Feb  2, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            McAdam's RISC Computer Architecture (marca) is a simple 16-bit microprocessor, implementing a load/store instruction set architecture and featuring a 4-stage pipeline.\n        ", "\n            - 16 16-bit registers\r\n", "- Harvard architecture\r\n", " - all memories on-chip\r\n", " - 16KB instruction ROM\r\n", " - 8KB data RAM\r\n", " - 256 byte data ROM\r\n", "- load/store instruction set architecture\r\n", " - 75 instructions\r\n", "- 16 interrupt vectors\r\n", "- 4-stage pipeline\n        ", "\n            - running on an Altera Cyclone FPGA\n        "]},
{"details": ["\n    Name: m32632", "\n    Created: Jun 24, 2015", "\n    Updated: Aug 14, 2016", "\n        SVN Updated: Aug 15, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            M32632 is an implementation of the Series 32000 architecture of National Semiconductor.\r\n", "This 32-bit architecture was popular in the 1980's and began to disappear in the beginning\r\n", "of the 1990's. The first microprocessor was the NS32016. The third generation CPU was\r\n", "the NS32532. This processor is the basis of M32632. In addition M32632 implements the\r\n", "functionality of the NS32381 floating point unit.\n        ", "\n            ", "\n            ", "\n            ", "The M32632 has the following features:", " ", "\n            ", "The performance of M32632 at 50 MHz has been measured on a system running NetBSD 1.5.3 with the Dhrystone 2.1 Benchmark compiled with gcc.\r\nThe source code of Dhrystone was taken from the link at the processor project ao486.\r\nThe number is:", "The Linpack Benchmark is a well known program to measure the floating point performance of a computer. The original program was written in Fortran. It can be found here: \r\n", " .\r\nCompiled with gcc with optimization level -O3 the M32632 achieves", "\n            For the DE0-Nano board using an Altera Cyclone IV E FPGA is a demonstration system available. The data for it is contained in the directory trunk/DE0-Nano. The M32632 running at 50 MHz is connected to a 32 MB SDRAM running at 100 MHz. The program for the processor flashes the LEDs on the board. Changing the configuration is easily possible. The source code for the SDRAM controller is included.\n        "]},
{"details": ["\n    Name: mblite", "\n    Created: Jun 19, 2009", "\n    Updated: Jan  5, 2017", "\n        SVN Updated: May 15, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 13 reported / 12 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "The MB-Lite microprocessor is a ligth-weight implementation of the Microblaze Instruction Set Architecture. It is instruction and cycle compatible with the Microblaze EDK 10.1i. It is successfully tested on older and newer Xilinx platforms (EDK 9 and 11). The design has been successfully synthesized for an Altera board as well to show platform independence.", "\n            ", "MB-Lite is a highly modular design and is therefore very simple to understand and modify. Features of the MicroBlaze architecture and MB-Lite implementation are:", "The following instructions are currently not implemented. All of these instructions are not used by the compiler (mb-gcc) or can be replaced by software libraries.", "\n            ", "\n            ", "The core is designed using the ", ". All modules use inferred components, the design is not targeted specificly to any platform. However, currently it is only tested on a Xilinx Spartan 3 FPGA. All memory blocks and registers will synthesize to BRAM on xilinx devices.", "\n            ", "The organization of the hardware corresponds closely to the implementation of the classic RISC pipeline of Hennesy & Patterson (Computer Organization and Design: The Hardware/Software Approach).", "\n            ", "MB-Lite is tested on a Virtex 5 development board (XC5VLX110-3FF 1760). It is able to obtain 229 MHz (c.f. the original implementation obtains 227 MHz). Furthermore, MB-Lite has a lower Cycles Per Instruction (CPI) than MicroBlaze since MicroBlaze has a prefetch buffer which reduces the rate of instructions which can be fed into the processor. The execution time of MB-Lite is therefore approximately 10% lower than MicroBlaze.", "\n            "]},
{"details": ["\n    Name: light8080", "\n    Created: Oct 24, 2007", "\n    Updated: Sep 27, 2012", "\n        SVN Updated: Apr 10, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 6 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a simple, small microprogrammed Intel 8080 CPU binary compatible core.\r\n", "\r\n", "\r\nThere are already at least two other 8080-compatible cores in Opencores, both of them well proven. This one is different because it emphasizes area instead of cycle-count compatibility or speed.\r\n", "\r\n", "\r\nI have tried to minimize logic size and complexity as much as possible, at the expense of speed. At about the same size as a Picoblaze on a Spartan 3 (204 LUTs + 1 BRAM), this is perhaps amongst the smallest 8-bit CPU cores available. On the other hand, it is rather slow in clock frequency and particularly in cycles per instruction (25 to 50% more clocks per instruction than the original, which is an awful lot! -- see the design notes). Besides, the 2 KBytes of dedicated fpga ram it does use may in some designs be more valuable than a large number of logic blocks.\r\n", "\r\n", "\r\nThe source is quite simple: a single file with some 1300 lines of straightforward, moderately commented VHDL code; plus a microcode source file from which the microcode table embedded into the vhdl was assembled. However, the simplicity may be deceptive; it can be argued that the complexity of the system has been moved from the RTL to the microcode... \r\n", "\r\n", "\r\nA description of the circuit and its microcode is included in the design notes and the respective source files. The microcode assembler (a perl script) is included too, though it is not necessary if you just want to use the core and not modify it.\r\n", "\r\n", "\r\nThis is just a fun project I created to learn vhdl; my design goal was to get the simplest possible 8080-compatible core, at the smallest possible size, at any reasonable speed. And above all, at a minimum cost in development time -- so I could get something worthy done in the very limited time available.", "\r\nThough I think I accomplished my goal, the resulting core is probably of little practical use: it is certainly no match for a picoblaze in its application niche, and it is not small enough to compensate for its lack of features (the smallest Nios II is only 2 or 3 times larger). And there are better 8080 cores around, as I said.\r\n", "\r\n", "\r\nI am in debt with Scott A. Moore for his cpu8080 core. Though I have not used his code in this project, I studied it and did use much of the research and test material that he made available at this site.\r\n", "\r\n\r\n\r\n\n        ", "\n            - Available in both VHDL and Verilog versions (thanks to Moti Litochevski) -- identical circuit.", "\r\n- Microcoded design, very simple circuit.", "\r\n  - Microcode source and assembler included, though the vhdl microcode table can be edited directly.", "\r\n  - Slower than original in clocks per instructions (about 25 to 50%, comparative table included in the design notes).", "\r\n- 100% binary compatible to original 8080.", "\r\n- Synchronized to positive clock edges only.", "\r\n- Signal interface very simplified. Not all original status info available (no M1, for instance).", "\r\n- Synchronous memory and i/o interface, with NO WAIT STATE ability.", "\r\n- INTA procedure similar to original 8080, except it can use any instruction as int vector.", "\r\n- Undefined/unused opcodes are NOPs.", "\r\n", "\r\n", "\r\n", "\r\n\r\nPerformance (standalone CPU, synthesis only):\r\n", "\r\n", "\r\n", "\r\nXilinx XST on Spartan 3 (-5 grade):", "\r\n", "\r\n\u00a0\u00a0\u00a0204 LUTs plus 1 BRAM @ 80 MHz ", "\r\n\u00a0\u00a0\u00a0228 LUTs plus 1 BRAM @ 100 MHz ", "\r\n\u00a0\u00a0\u00a0618 LUTs @ 53 MHz ", "\r\n", "\r\n", "\r\nAltera Quartus on Cyclone 2:", "\r\n", "\r\n\u00a0\u00a0\u00a0369 LEs plus 4 M4Ks   @ 67 MHz ", "\n            The core has already executed some quite large pieces of original code in hardware, including the Microsoft Altair 4K Basic.", " Interrupt response has been simulated and tested in real hardware.", "\r\nThe project includes a small SoC system built around the CPU core that can be useful as an usage example or as the starting point for a real application.", "\r\nBesides, thanks to Moti Litochevski the project is now available in both Verilog and VHDL versions.", "\r\n", "\r\nCompatibility to the original Intel 8080 has not yet been achieved at 100% -- the CY flag undocumented behavior for some logic instructions is slightly incompatible. This is an issue that can't be fixed without a lot of testing with original 8080 chips, or with very accurate simulators.", "\r\n", "\r\nPlease note that the ", " behavior of the CPU is 100% compatible to the original; it's only the undocumented behavior of the original silicon that has not yet been fully replicated -- only almost.\r\n", "\r\n\r\n\r\nWe have set up some ", " to showcase the core. \r\n", "\r\n\r\n\r\nThe development progress can be tracked in the ", ".\r\n", "\r\n\n        "]},
{"details": ["\n    Name: leros", "\n    Created: Sep  5, 2011", "\n    Updated: Mar  6, 2012", "\n        SVN Updated: Nov  8, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Leros is a 16-bit processor optimized for FPGAs. It consumes less than 200 logic cells and 1-2 on-chip memories.\r\n", "Leros is programmed in assembler and in a restricted subset of Java. Leros is a direct competitor to tiny processor\r\n", "cores, such as PicoBlaze.\n        ", "\n            Leros targets the same application area as PicoBlaze and\r\n", "is about the same size. Following list gives the main differences:\r\n", "\r\n", "* Truly open source (BSD)\r\n", "* Compiles on Altera and Xilinx tools\r\n", "* Leros is a 16 bit architectures instead of 8 bit\r\n", "* Leros has no restrictions on code and data size\r\n", "* Single clock cycle instructions\r\n", "* Java based assembler is platform independent\r\n", "* Simplified Java compiler for Leros available\n        "]},
{"details": ["\n    Name: jop", "\n    Created: Feb 19, 2004", "\n    Updated: Sep  5, 2011", "\n        SVN Updated: Mar 31, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            - VHDL files and and supporting tools for the design are available from OpenCores CVS.\r\n", "- Actual updates are now in a git repository, see ", "\r\n", "- Further information can be found at ", "\r\n", "- A wiki is available at ", "\n        ", "\n            - Very small core:\r\n", "  - about 2000 LCs - 3000 LCs (configurable)\r\n", "  - fmax is 100 MHz in a Cyclone EP1C6\r\n", "- Real-time features:\r\n", "  - architecture designed to simplify WCET analysis\r\n", "  - cycle accurate time interrupt (not tick based)\r\n", "  - real-time enhanced thread model\r\n", "- WISHBONE master\n        ", "\n            JOP is the implementation of the Java Virtual Machine (JVM) as concrete machine in hardware. The design has been sucessfully implemented in low cost FPGA devices from Altera (ACEX 1K50, Cyclone) and Xilinx (Spartan II and Spartan-3).\r\n", "\r\n", "JOP is open-source under the GNU General Public License, version 3.\n        ", "\n            The latest version of JOP can be obtained with anonymous GIT:\r\n", "\r\n", "   git clone git://www.soc.tuwien.ac.at/jop.git\r\n", "\n        "]},
{"details": ["\n    Name: hive", "\n    Created: Jun 22, 2013", "\n    Updated: Sep  7, 2015", "\n        SVN Updated: Sep  7, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Quick link to the design document v08.06: ", "\r\n", "Quick link to everything including C++ sim: ", "\r\n", "\r\n", "v08.06 - 2015-09-04 - PUBLIC RELEASE -\r\n", "- Fixed horrific bug that goes all the way back to v06.01:\r\n", "  - Copy path through the ALU not specified for op_dat immediate data!\r\n", "- Fixed horrific bug that goes all the way back to v05.03:\r\n", "  - AB Pops not inhibited during decode of IRQ cycle!\r\n", "- Bit reduction opcodes now return 1/0 rather than -1/0 (more useful?).\r\n", "- Added conditional (A?0) GTO opcodes.\r\n", "- Removed op_jmp_4 (A?B) opcodes - hogging too much opcode space.\r\n", "- Added op_sk1 and op_sk2 (A?B) opcodes.\r\n", "- Added A odd tests to SKP & SK2 opcodes.\r\n", "- Removed redundant PC+1 & PC+2 lit logic.\r\n", "- The core port now sports the RBUS master interface.\r\n", "- Added parameter MEM_ROM_W to protect ROM area in low main memory.\r\n", "- Added parameter XSR_LIVE_MASK to enable / disable XSR inputs.\r\n", "- Moved remaining trivial registering of RBUS bridge to the data ring.\r\n", "- MEM_IM_W is now 5, moved *2 shift for 32 bit access address\r\n", "  offset into op_decode.\r\n", "- Removed thread clear events from error register.  Cleared\r\n", "  threads can report this through some other mechanism if needed.\r\n", "- New component: hive_in_cond.sv to handle XSR & register set \r\n", "  input conditioning (identical functionality).\r\n", "- Fixed bug regarding register set input data edge detection \r\n", "  option masks (mask vectors weren't indexed).\r\n", "- Register set now distributed rather than in one component,\r\n", "  which makes the design more modular.  \"RBUS\" is the internal bus.\r\n", "- Removed most interstage feedback, now almost competely feedforward:\r\n", "  - Push stack selector encoded binary w/ enable rather than one-hot.\r\n", "  - Stack push moved to stage 5.\r\n", "  - Stack errors pipelined to next cycle @ stage 0.\r\n", "  - Opcode error and thread clear reporting @ stage 0.\r\n", "- Shuffled opcodes, removed opcode type CODE_T, streamlined default decoding.\r\n", "- Passes new verification & functional testing.\r\n", "- EP3C5E144C: 2420 LEs, 194.1 MHz.\r\n", "\r\n", "=============\r\n", "\r\n", "Quick link to the Excel simulator v06.01:  ", "\r\n", "Quick link to the design document v06.01: ", "\r\n", "Quick link to the SystemVerilog code v06.01: ", "\r\n", "\r\n", "v06.01 - 2014-07-13\r\n", "- Major changes in hive_main_mem.sv to support 16 & 32 bit aligned and unaligned access for literals and memory R/W.\r\n", "- Main memory BRAM now a dual entity to provide separate addressing of high and low and to circumvent bootcode init issues.\r\n", "- R/W immediate field offset is based on 16 bit access.\r\n", "- New / different opcodes:\r\n", "  - op_cpy_ls   : 16 bit copy low signed\r\n", "  - op_cpy_lu   : 16 bit copy low unsigned\r\n", "  - op_lit      : 32 bit literal \r\n", "  - op_lit_ls   : 16 bit literal low signed\r\n", "  - op_lit_lu   : 16 bit literal low unsigned\r\n", "  - op_mem_ir   : 32 bit memory read\r\n", "  - op_mem_irls : 16 bit mememory read low signed\r\n", "  - op_mem_iw   : 32 bit mememory write\r\n", "  - op_mem_iwl  : 16 bit memory write low\r\n", "- Some juggling of opcode order to hopefully ease decode.\r\n", "- hive_alu_logical.sv rearranged a bit, removed a and default path.\r\n", "- Passes all boot code verification & functional tests.\r\n", "\r\n", "=============\r\n", "\r\n", "Quick link to the SystemVerilog code v05.04: ", "\r\n", "\r\n", "v05.04 is now written in synthesizable SystemVerilog!  Lots of minor edits, magic numbers are all in packages.\r\n", "\r\n", "=============\r\n", "\r\n", "Quick link to the Excel sim v05.03: ", "\r\n", "Quick link to the verilog code v05.03: ", "\r\n", "Quick link to the design document v05.03: ", "\r\n", "\r\n", "v05.03 has more extensive interrupt support, 32 bit register access, and an updated design document.  Footprint is a bit smaller and top speed is a bit faster than previous versions due to cleanup / rewrite / edits. \r\n", "\r\n", "=============\r\n", "\r\n", "With v04.05 Hive now has 8 stacks per thread and a UART!\r\n", "\r\n", "=============\r\n", "\r\n", "Hive is a general purpose soft processor core intended for instantiation in an FPGA when CPU functionality is desired but when an ARM or similar would be overkill.  The Hive core is complex enough to be useful, with a wide data path, a relatively full set of instructions, high code density, and good ALU utilization \u2013 but with very basic control structures and minimal internal state, so it is simple enough for a human to easily grasp and program at the lowest level without any special tools.  It fits in the smallest of current FPGAs with sufficient resources left over for peripherals (as well as other unrelated logic) and operates at or near the top speed of the device DSP hardware.\r\n", " \r\n", "Hive isn\u2019t an acronym, the name is meant to suggest the swarm of activity in an insect hive: many threads sharing the same program and data space, individually beavering away on separate tasks, and cooperating together to accomplish larger goals.  Because of the shared memory space, thread intercommunication is facilitated, and threads can all share a single instance of code, subroutines, and data sets which enables code compaction via global factoring.\r\n", "\r\n", "The novel hybrid stack / register construct employed reduces the need for a plethora of registers and allows for small operand indexes in the opcode.  This construct, coupled with explicit stack pointer control in the form of a pop bit for each stack index, minimizes the confusing and inefficient stack gymnastics (swap, pick, roll, copying to thwart auto-consumption, etc.) normally associated with conventional stack machines, and also minimizes the saving and restoring of register contents normally associated with conventional register machines.\r\n", "\r\n", "Hive employs a naturally emergent form of multi-threaded scheduling which eliminates all pipeline hazards and provides the programmer with as many equal bandwidth threads \u2013 each with its own independent interrupt \u2013 as pipeline stages.  Processors that employ this form of pipelining are classified as \u201cbarrel\u201d processors.\r\n", "\r\n", "Hive is a largely stateless design (no pipeline bubbles, no registered ALU flags that may or may not be automatically updated, no reserved data registers, no pending operations, no branch prediction, etc.) so subroutines require no overhead and interrupts consume a single branch cycle, and their calculations can be performed directly and immediately with complete disregard for what may be transpiring in other contexts.\n        "]},
{"details": ["\n    Name: fpz8", "\n    Created: Nov 12, 2016", "\n    Updated: Nov 18, 2016", "\n        SVN Updated: Dec  2, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            FPz8 is a softcore processor based on Zilog Z8 encore (eZ8) 8-bit core. FPz8 features 2kb of RAM, 16kb of program memory, 8-level vectored interrupt controller with programmable priority and an on-chip debugger compatible with Zilog's OCD protocol.\r\n", "\r\n", "This softcore was designed to be almost 100% compatible with eZ8 object-code (some features as data RAM, LDE/LDEI and WDT instructions are not implemented).\r\n", "\r\n", "FPz8 can be programmed and debugged by using Zilog's ZDS-II IDE both in Assembly or C languages.\r\n", "\r\n", "It was tested on an Altera EP4CE6 (Cyclone IV) FPGA and works flawlessly.\n        "]},
{"details": ["\n    Name: mips_16", "\n    Created: Mar  3, 2012", "\n    Updated: Aug 18, 2013", "\n        SVN Updated: Mar  4, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project was aimed at providing people a simple, runnable, and easy-to-enhance MIPS CPU main architecture, along with well commented Verilog RTL source code, complete simulation test benches & scripts, and detailed documentation. People can read the source code, make simulations to verify the result, and then make modifications to enhance it. I hope this project can help you learning the MIPS CPU architecture and enjoy constructing your own CPU core.\r\n", "This CPU design is based on Mr. Hu Weiwu\u2019s book \u201dComputer Achitecture\u201d, Tsinghua University Press, 2011\r\n", "\n        ", "\n            1.\t16-bit data width\r\n", "2.\tclassic 5-stage static pipeline, 1 branch delay slot, theoretical CPI is 1.0\r\n", "3.\tpipeline is able to detect and prevent RAW hazards, no forwarding logic\r\n", "4.\t8 general purpose register (reg 0 is special, according to mips architecture)\r\n", "5.\tup to now supports 13 instructions, see ./doc/instruction_set.txt for details\r\n", "6.\tMaximum clk Frequency: 82.688MHz on Xilinx 3s1000fg320-5 device (XST).\n        ", "\n            Directory tree:\r\n", "mips_16\t\r\n", "+-backend => Backend tool dir\r\n", "|  +-Xilinx => Xilinx ISE work dir\r\n", "+-bench => Test benches & modelsim scripts for each module\r\n", "|  +-mips_16_core_top => benches & scripts for top module\r\n", "|  +-module_1 => benches & scripts for module_1\r\n", "|  +-module_2 => benches & scripts for module_2\r\n", "|  +-... => ...\r\n", "|  +-module_n => benches & scripts for module_n\r\n", "+-doc => documentations\r\n", "+-rtl => RTL source code of this project\r\n", "+-sim => Modelsim work dir\r\n", "+-sw => Tool chains\r\n", "\r\n", "File types:\r\n", "*.asm : => MIPS_16 assembly language source file\r\n", "*.prog: => MIPS machine language file,\r\n", "generated from .asm files,\r\n", "in ASCII format, for simulation only.\n        "]},
{"details": ["\n    Name: gup", "\n    Created: Apr  2, 2008", "\n    Updated: Jul  5, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n             - Motorola/Freescale 68xx Architecture", "\r\n - Source-code and machine-code compatible 68HC11 cpu core", "\r\n - Compatible with all HC11 C/C++ compilers including GNU GCC", "\r\n - Up to 100MHz operation in modern FPGAs", "\r\n - 2.5 times faster per clock cycle than a HC11 on average", "\r\n", "\r\nVisit the official website at:\r\n", "\n        ", "\n            Version 0.9a: Released\r\n", "Version 1.0: Released\r\n", "Version 2.0: Coming Soon\n        "]},
{"details": ["\n    Name: hf-risc", "\n    Created: Mar 31, 2016", "\n    Updated: Dec  3, 2017", "\n        SVN Updated: Dec 20, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This project is also available at ", "\n        ", "\n            HF-RISC is a small 32-bit, in order, 3-stage pipelined MIPS / RISC-V microcontroller designed at the Embedded Systems Group (GSE) of the Faculty of Informatics, PUCRS, Brazil. All registers / memory accesses are synchronized to the rising edge of clock. The core can be easily integrated into several applications, and interfaces directly to standard synchronous memories.\r\n\r\nPipeline stages are:\r\n", "\n            Patched GNU GCC version 4.9.3. Mandatory compiler options (for bare metal) are: -mips1(**) -mpatfree -mfix-r4000 -mno-check-zero-division -msoft-float -fshort-double -ffreestanding -nostdlib -fomit-frame-pointer -G 0 -mnohwmult -mnohwdiv -ffixed-lo -ffixed-hi.\r\n", "\r\n", "A complete set of flags to be used with the compiler is provided in example applications, along with a small C library. A full compiler toolchain (including Newlib) can be generated using the provided scripts.\r\n", "\r\n", "(**) \"-mips2 -mno-branch-likely\" can be used instead of \"-mips1\". The result is similar to the code generated with \"-mips1\", but no useless nops are inserted after loads on data hazards (load delay slots).\r\n", "\n        ", "\n            The following instructions from the MIPS I instruction set were implemented (41 opcodes):\r\n\r\n", "\n            The memory map is separated into regions.\r\n\r\n", "\n            Another version of this core implements the RV32I base user level instruction set of the RISC-V architecture. The core organization is basically the same as HF-RISC, including the memory map and software compatibility (a given application just has to be recompiled to the RV32I target). Improvements (compared to HF-RISC) include shorter critical path for higher clock frequency and an exception handling mechanism (traps) for unimplemented opcodes.\r\n", "\r\n", "Other advantages of this core are related to the ISA, which improves a lot (compared to MIPS) several aspects: better code density (even without the compressed code extensions), more extensible ISA, no delayed load/branches, better immediate fields encoding and nice support for relocatable code. Also, there is no need to tweak the compiler (as done on the HF-RISC) because RV32I is as simple as it gets.\r\n", "\r\n", "The toolchain used with this core is the GCC compiler with a backend for the RISC-V architecture. Sources and installation instructions can be found at ", "\n        ", "\n            HF-RISC: 0.96 CoreMark/MHz\r\n", "HF-RISCV: 0.84 CoreMark/MHz*\r\n", "\r\n", "If a multiplier is used (not included in this design) the score is around 2.1 Coremark/MHz.\r\n", "\r\n", "*HF-RISCV doesn't include the multiply/divide (M) extension (pure RV32I) and doesn't include dalayed branches as found on MIPS. This sacrifices performance a bit, but simplifies the ISA for deeper pipelines and OOO execution. Based on several experiments, the inclusion of the M module will boost the performance of this core beyond the HF-RISC version, even without branch prediction.\n        "]},
{"details": ["\n    Name: gpu", "\n    Created: Feb  8, 2015", "\n    Updated: Feb 10, 2015", "\n        SVN Updated: Feb 10, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The graphics processed by the GPU are defined as a set of vertices that contain spatial information, i.e. vectors with coordinates [x y z] in three-dimensional Cartesian space, and additional information of color or texture coordinates.", "\r\n\r\nThe processing that is performed has 4 phases:", "\r\n\r\n1. A group of vertices is processed as a point list, a line list, a line strip, a triangle list, a triangle strip or a triangle fan.", "\r\n2. The given vertices are transformed three-dimensionally based on a 4x4 transformation matrix, being able to translate them, rotate them, scale them and/or project them.", "\r\n3. Depending on whether the vertices correspond to a set of points, lines or triangles, the visible region of these figures is calculated by cutting the parts that are in front of the near view plane, and the parts that are behind the far plane of vision.", "\r\n4. The information contained in the vertices is mapped in the area defined by these, at this stage it is assumed that the vertices already been projected from three-dimensional space to a space bidimencional.", "\r\n\r\nThe area mentioned in step 4 of processing corresponds to a section of memory that can be read and then sent to a screen for viewing.", "\r\n\r\n", "\n        "]},
{"details": ["\n    Name: dfp", "\n    Created: Dec 15, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The data flow processor (DFP) is a flexible microprocessor written in VHDL which you can program down to the gate level to optimize your entire design. It is composed of 7 components with a specific data flow architecture. In most cases you just provide a VHDL file containing the program you want the processor to run, compile the whole design and then download it to an FPGA. For more specific designs, the code for the components can be altered to suit your needs. The components are:\r\n", "\r\n", "TR - top register - top-most register for manipulating data or data flow\r\n", "FU - function unit - provides functions to operate on data with TR and DS\r\n", "DS - data stack - for holding intermediate data values \r\n", "ME - memory - holds data, program and memory mapped I/O\r\n", "PC - program counter - current address of program in memory\r\n", "RS - return stack - holds values from PC for program nesting and return\r\n", "IR - instruction register - runs instruction sequences from memory\r\n", "\r\n", "By design, there is no bank of registers as in a conventional microprocessor design. This simplifies the instructions as they don't need a source or destination field. Instead, data items are pushed and popped to/from a stack. There is also no cache.\r\n", "\r\n", "The idea is that since the FPGA ultimately will be manipulating data flows through it when it is running an application program, prebuilt soft processors ready for deployment and able to execute programs, can be used. While this is not new in of itself, the extension we add is flexibility, in that while the structure is there, it is also fully resizable and programmable. The depth of the stacks, the width of the data bus and the length of memory are all changeable parameters from 0,1,2... to chip limits.\r\n", "\r\n", "The parameters are gleaned from compiling the code down to a hardware description language, VHDL in this case, for compiling or simulating with hardware tools.\r\n", "\r\n", "In addition to changeable parameters, the instruction set is also programmable. When a DFP program is constructed, part of it will either define primitives, one or more instructions in a sequence, or include required ones from a library. The other part of a DFP program utilizes these primitives to form the basis language for the program. The program looks similar to assembler.\r\n", "\r\n", "For more information, see the DFP and GCA websites:\r\n", "\r\n", "\r\n", "\n        ", "\n            FILE: dfp.gif\r\n", "DESCRIPTION: Structure of the DFP\r\n", "\n        ", "\n            - VHDL coded Data Flow Processor\r\n", "- VHDL coded RS232 interface, can be connected as a peripheral\r\n", "- DFP Program compiler with full documentation and example programs\r\n", "- DFP Program libraries including:\r\n", "\t- basic assembler primitives\r\n", "\t- stack manipulation primitives\r\n", "\t- multi-step math implentations of addition, subtraction, multiplication, and division (see the DFP website for more info) \r\n", "\t- Granular computing operations, including functionality for applications requiring fast fuzzy control\r\n", "\r\n", "\n        ", "\n            - Fully synthesizable with Xilinx ISE 6.1 (make sure to turn off ROM extraction in the properties for Synthesize - XST, under HDL Options tab)\r\n", "- Should be able to simulate with any VHDL simulator (tested with DirectVHDL, ModelSim, and Symphony EDA)\r\n", "- 4/30/05 For the Windows platform, there is a newer compile of the Timbre tool used for creating VHDL code at:\r\n", "  ", "\r\n", "or\r\n", "- major new release with many updates at:\r\n", "  ", "\r\n", "- New website for natural artificial life forms using GCA technology:\r\n", "  ", "\n        "]},
{"details": ["\n    Name: cpu65c02_true_cycle", "\n    Created: Apr 12, 2008", "\n    Updated: Aug  2, 2013", "\n        SVN Updated: Aug  2, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 7 reported / 6 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The 65C02 by Rockwell is the upgraded version of the legendary Rockwell's R6502. cpu65c02_tc offers you an accurate timing for all new and upgraded op codes of the R65C02. This soft core was generated in VHDL and was designed with Mentor's HDL Designer.\r\n", "It comes also with graphical views formatted in HTML to show and explain very clearly the hierarchy of the whole design.\r\n", "\r\n", "Please feel free to tell me any ideas, errors or some thing else like special functions, test benches or documentation. Use the \"Tracker\" link to do this.\n        ", "\n            - true cycle timing for all official opcodes \r\n", "- unknown op's decoded as \"NOP/special op codes\" \r\n", "- one clock source \r\n", "- input signal \"rdy_i\" for generating waitstates (see attached specification of R65C02) \r\n", "- output signal \"sync_o\" to indicate an op fetch (see attached specification of R65C02) \r\n", "- input signal \"so_n_i\" sets the internal OV Flag (see attached specification of R65C02) \r\n", "- fully synthesizable VHDL\r\n", "\n        ", "\n            - Based on the cpu6502_tc core", "\r\n- This version will support Rockwell's 65C02 (other variants are planed for future)", "\r\n- Core is running in a APPLE //e SoC and tested under ProDOS V2.0.3 and", "\r\n  Klaus Dormann's 6502/65c02 test suite written in assembler.", "\r\n", "\r\nCORE:     \"READY - RELEASE CANDIDATE\"", "\r\nLICENSE: Puplished under GPL V3", "\r\nDOCUMENTATION: \"on working\"", "\r\nTESTBENCHES: \"on working\"", "\r\nTESTSOFTWARE: \"ready\"", "\r\n", "\r\n", ":", "\r\n- all of the new R65C02 op codes are tested under real working conditions with", "\r\n  Klaus Dormann's 6502/65c02 test suite written in assembler (included in /asm now)", "\r\n- irq_n_i: not fully tested on real hardware yet", "\r\n- nmi_n_i: not fully tested on real hardware yet", "\r\n- so_n_i: not fully tested on real hardware yet", "\r\n", "\r\n", "\r\n", "\r\nAug-02-2013", "\r\nRevision 1.5 RC 2013/07/31 11:53:00 (RELEASE CANDIDATE)", "\r\n- Bug Fix CMP (IND) - wrongly decoded as function AND", "\r\n- Bug Fix BRK should clear decimal flag in P Reg", "\r\n- Bug Fix JMP (ABS,X) - Low Address outputted twice - no High Address", "\r\n- Bug Fix Unknown Ops - Used always 1b2c NOP ($EA) - new NOPs created", "\r\n- Bug Fix DECIMAL ADC and SBC (all op codes - \"C\" flag was computed wrong)", "\r\n- Bug Fix INC/DEC ABS,X - N/Z flag wrongly computed", "\r\n- Bug Fix RTI - should increment stack pointer", "\r\n- Bug Fix \"E\" & \"B\" flags (Bits 5 & 4) - should be always \"1\" in P Reg. Change \"RES\", \"RTI\", \"IRQ\" & \"NMI\" substates.", "\r\n- Bug Fix ADC and SBC (all sub codes - \"Overflow\" flag was computed wrong)", "\r\n- Bug Fix RMB, SMB Bug - Bit position decoded wrong", "\r\nRevision 1.4  2013/07/21 11:11:00 (internal copy only - not published)", "\r\n- Changing the title block and internal revision history", "\r\n- Bug Fix STA [(IND)] op$92 ($92 was missed in the connection list at state FETCH)", "\r\n", "\r\nFeb-25-2009", "\r\n- Correct \"RTI\" (wrong: use of stack pointer)", "\r\n- Correct \"RMBx\" & \"SMBx\" (wrong: bit translation)", "\r\n- Rename all states of \"FSM Execution Unit\" for better reading", "\r\n- (85%) Finish working for Specification of cpu65C02_tc", "\r\n- Correct timing for addressing mode \"ABS,X\" for \"INC\" (wrong: 6 cycles instead of 7)", "\r\n- Optimize end states of \"STA\" (s197,s207,s200,s213)", "\r\n", "\r\nJan-04-2009", "\r\n- Deleted unused/duplicated nets, registers and modules. Renamed some blocks. Synthesis run now without warnings.", "\r\n", "\r\nDec-01-2008", "\r\n- CVS loaded with updated finite state machine (bug fixes for interrupts)", "\r\n- Include an example for specification (copied from cpu6502_tc - on working)", "\r\n", "\r\nAug-05-2008", "\r\n- CVS loaded with BETA source files (VHDL)", "\r\n\r\n\n        "]},
{"details": ["\n    Name: myforthprocessor", "\n    Created: Oct 30, 2012", "\n    Updated: Oct 31, 2012", "\n        SVN Updated: Nov 24, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A 32-bit FORTH processor conforming to the DPANS'94. This processor was developed as diploma thesis to obtain the academic degree Diplomingenieur (Master of Computer Science) at Johannes Kepler University in Linz, Austria.\r\n", "\r\n", "Details\r\n", "\r\n", "- Pipelined (6-stage) instruction execution.\r\n", "- 2 stacks instead of register array.\r\n", "- memory common to data and instructions.\r\n", "- optional 64-bit multiplier and divider.\r\n", "- optional multicore possible\r\n", "- ANSI 754 floating point arithmetic.\r\n", "- Hardware is Little-Endian.\r\n", "- an Interruptcontroller.\r\n", "- an UART.\r\n", "- board specific DDR2 memory controller\r\n", "- a ROM containig the BIOS, sources included\r\n", "- Vendor-independent code. \r\n", "- A clean, modular design.\r\n", "\r\n", "The projects are realized on Xilinx Spartan 3A Starter board, but can be moved to other Xilinx boards.\r\n", "\r\n", "The following software is included:\r\n", "A Java-client for communication between board and user. The client includes a FORTH-Assembler and a Java compiler. The sources are included.\n        "]},
{"details": ["\n    Name: ax8", "\n    Created: May 14, 2002", "\n    Updated: Feb 16, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Microcontroller core compatible with 90S1200 and 90S2313.\r\n\r\nSame instruction timing as in the original MCUs. Both MCUs use the configurable AX8 core. Other MCUs using one of the two instruction sets the core supports can easily be implemented by creating a new top level.\r\n\r\nThere are utilities included that can create VHDL ROMs for simulation and synthesis. The utilites create generic ROMs that can be used for simulation and for synthesis with Leonardo and also Xilinx specific ROMs that can be used for XST synthesis.\r\n\r\nBatch files for runnning XST and Leonardo synthesis can be found in ", ".\r\n\r\nBefore you can run the scripts you need to compile hex2rom and xrom or download binaries from ", ".\r\nYou must also replace one of the hex files in sw/ or change the batch files to use another hex file.\r\nIf you need to change target device and settings you need to edit the batch files and some of the files in ", ".\r\n\r\nThe Leonardo batch file also creates the VHDL ROMs you need to run the Modelsim compile script in ", ".\r\n\r\nIf you want to create ROMs without running the scripts use the following parameters for 90S1200:\r\nhex2rom [-b] inputfile.hex ROM1200 9l16s > ROM1200.vhd\r\nAnd these for 90S2313:\r\nhex2rom [-b] inputfile.hex ROM2313 10l16s > ROM2313.vhd\r\nHex2rom can read intel/motorola hex and binary files.\r\n\r\nBrowse source code ", ".\r\nDownload latest tarball ", ".\r\n        ", "\n            - High performance, > 30 MIPS in Spartan 2 -5\r\n", "- Except for the watchdog, the analog comparator and the EEPROM all peripherals and interrupts are implemented\r\n", "- Supports synchronous ROM/RAM (Xilinx Block RAM compatible)\r\n", "- Parametric\r\n", "- Technology independent\r\n        ", "\n            - Not yet tested in hardware\r\n        "]},
{"details": ["\n    Name: avr_core", "\n    Created: Nov  5, 2002", "\n    Updated: Feb 12, 2017", "\n        SVN Updated: Oct 28, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 10 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Microcontroller core compatible with one used in AT mega 103 and written in VHDL. It has the same instruction timing  and the same instruction set (with a few exceptions).\n        ", "\n            \u2022 Core features:\r\n", "\u2013 32 x 8 general purpose registers\r\n", "\u2013 Twenty three interrupt vectors\r\n", "\u2013 Supports up to 128 Kb of program and up to 64 Kb of data memory\r\n", "\r\n", " \u2022 Peripheral features:\r\n", "\u2013 Programmable UART\r\n", "\u2013 Two 8-bit Timer/Counters with separate prescalers and PWM\r\n", "\u2013 Eight external interrupt sources \r\n", "\u2013 Two parallel ports\n        ", "\n            The core was tested with several ASM and C programs.\r\n", "It was implemented in Altera EPF10K50ETC144-3 device and \r\n", "tested with AVR port of uC/OS-II The Real-Time Kernel, written by Ole Saether.(I used special version of the design with external SRAM for both program and data memories).\r\n", "Update 22.12.12. Verilog version of the project is uploaded.\n        "]},
{"details": ["\n    Name: lwrisc", "\n    Created: Feb  8, 2008", "\n    Updated: Feb 13, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This ClaiRISC is a soft MCU core which runs PIC 12bits instruction.Compared with PIC16F57 ,This core has the same number of register file while ports and timer are not avilable,but you can map your device register to the REGINSTER_FILE address.It uses about 240LES in ALTERA CYCLONE device. \n        ", "\n            - The architecture of ClaiRISC is very clair.\r\n", "- Written with verilog-2001.\r\n", "- Two stages pipeline.\r\n", "- Not support interrupt now.\r\n", "- Each instruction run in one clock except some \"test and skip\" instructions which run in two clock.\r\n", "- Synthesized and tested  in ALTERA cyclone device at 50MHZ using 240 LES (4%)and works well.\n        ", "\n            I have no idea if implementing this core will or will not violate \r\n", "patents, copyrights or cause any other type of lawsuits.\r\n", "\r\n", "I provide this core \"as is\", without any warranties. If you decide to \r\n", "build this core, you are responsible for any legal resolutions, such \r\n", "as patents and copyrights, and perhaps others ....\r\n", "\r\n", "THIS SOURCE FILE(S) IS/ARE PROVIDED \"AS IS\" AND WITHOUT ANY \r\n", "EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT \r\n", "LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND \r\n", "FITNESS FOR A PARTICULAR PURPOSE.\r\n", "\r\n", "\r\n", "\n        ", "\n            FILE: 200735153855.JPG\n", "DESCRIPTION: In the name of Leifeng\n", "\n        ", "\n            FILE: we.GIF\n", "DESCRIPTION: Architecture of ClaiRISC\n", "\n        "]},
{"details": ["\n    Name: mips32", "\n    Created: Feb 20, 2017", "\n    Updated: Feb 28, 2017", "\n        SVN Updated: Mar 10, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            A classic 5-stage pipeline MIPS 32-bit processor, including a 2-bit branch predictor, a 1024 depth branch prediction buffer, a 2KB direct-mapped cache and a 64K main memory. You can also download the project from \"", " if the SVN access is not available.\r\n", "\r\n", "This MIPS processor is coded according to the fifth edition book of David A.Patternson & John L.Hennsessy, \"Computer Organization and Design\". The architecture is the referred to the descriptions in this book. However, some alteration are made to reduce the critical data path, especially the Forwarding in EXECUTE stage. The bypass unit are migrated from the EXECUTE stage to the DECODE stage to improve timing. \r\n", "\r\n", "This MIPS is fully evaluated on Xilinx Vivado design tools and several testbenchs are providered to test the processor. It is also evaluated on Xilinx ZC706 board. The clock can run at 285MHz(3.5ns) and the hardware resource utilization:\r\n", "FF: 1709, LUT: 3171, MEMORY LUT: 1015, BRAM: 7.5.\r\n", "\r\n", "1: Classic 5-stage pipeline, including FETCH, DECODE, EXECUTE, MEM and WB.\r\n", "\r\n", "2: Apply the Dynamic Branch Prediction technology to improve the branch accuracy. It contains a 2-bit branch predictor and a 1024 depth branch prediction buffer to predict the branch address. Furthermore, it takes the jump instruction(j, jal, jr .etc) as specital branch instructions to deal with, and this can simplfy the jump implementation.\r\n", "\r\n", "3: Implement the Forwarding and Stalling mechanism to solve the data-hazard.\r\n", "\r\n", "4: A 2KB direct-mapped data-cache is added to accelerate memory access. This cache has 64 blocks and each block has 8 words. A cache controller is designed to connect the MIPS processor and the 64KB main memory. The cache is implemented as LUT in Xilinx FPGAs, and the main memory is implemented as Block Rams(BRAM).\r\n", "\r\n", "This MIPS processor supports the basic instructions as bellow. Users can add extra instructions conveniently.\r\n", "\r\n", "1 TYPE-R: AND, OR, ADD, SUB, SLT, NOR, SLRV, SLLV\r\n", "\r\n", "2 TYPE-I: ADDI, ANDI, ORI, XORI, LUI\r\n", "\r\n", "3 MEM: LW, SW\r\n", "\r\n", "4 BRANCH: BEQ, BNE\r\n", "\r\n", "5 JUMP: J, JAL, JR\r\n", "\r\n", "Some testbenchs are providered. All the codes are assembled by \"mipsasm.exe\", which is a MIPS assembler and simulator.\r\n", "\r\n", "1 sort: use the search-maximum method to sort an array.\r\n", "\r\n", "2 stack_sort: use two stacks to sort an array.\r\n", "\r\n", "3 finonacci: calculate the Fibonacci series.\r\n", "\r\n", "4 gcd: calculate the gcd of two numbers\r\n", "\r\n", "5 function/fact: test the function recursion. Accumulate the result in recursively way.\r\n", "\n        "]},
{"details": ["\n    Name: cpugen", "\n    Created: Sep  3, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cpugen (TM) generates customizable RISC cpu cores. \r\n", "It allows direct customization of address/data/instruction bus size, \r\n", "interrupt handling, indirect addressing, data/instruction latency \r\n", "timings and custom instructions definition.\r\n", "It is targeted to low size FPGAs, easy to use and getting started with.\r\n", "GNU VHDL source code provided.\r\n", "\r\n", "\n        ", "\n            1) Portability:\r\n\r\nvendor dependent blocks (ex. memory blocks) are kept separate from vendor independent logic. \r\nCustomizable built-in assembler with data/instruction memory files generation; output file formats for the following environments:\r\n\t\r\n\t- Altera\r\n\t- Xilinx\r\n\t- binary\r\n\t- testbench\r\n\r\n2) Configurability: \r\n\r\nIn order to optimize logic resources and take advantage of FPGA flexibility; targeted to low size FPGAs; it permits to define: \r\n\r\n\t- address/data/instruction bus size \r\n\t- stack type/depth \r\n\t- interrupt \r\n\t- indirect address \r\n\t- data/instruction variable latency\r\n\t- custom instructions support\r\n\t\r\n3) Graphical user interface:\r\n\r\n    ", "\r\n\r\n4) Easy to use and getting started with: \r\n\r\n\t- Tutorial and example files are supplied with the package\r\n\t- Xilinx/Altera 4/8/16/32 bit cpu applications samples\r\n\t- GNU VHDL source code\r\n\r\n\n        ", "\n            - Current release 2.0\r\n", "- VHDL simulations \r\n", "- Tested on Altera and Xilinx evaluation boards \r\n", "- Test/debug currently in progress\r\n", "\r\n", "Please contact me for bugs reporting or for obtaining technical support.\r\n", "\n        "]},
{"details": ["\n    Name: cf_ssp", "\n    Created: Apr 15, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nSeveral cores are provided in Verilog, Vhdl, and C.  If you don't see the configuration you need, chances are we can easily generate it for you.\r\n\r\nThe State Space Processor is used for implementing discrete linear systems, such as finite and infinite impulse response filters, multiple input and output systems, and general state space equations common in control and DSP applications.  Its simple instruction set and efficient architecture has a very low logic footprint.\n        ", "\n            Architecture:\r\n", "\r\n", "The processor requires two external memories: one for program instructions and the other for constants (coefficients) used in calculation.  The processor maintains a register file of 16 N-bit registers used to retain state information and for processing intermediate results.  The register file is also used for handling input and output; registers can be written from an external source and all registers are available as outputs.  For convenience, register 0 is wired to ground and instructions updating r0 have no effect on the register file.\r\n", "\r\n", "The processor runs calculations on a cycle basis:\r\n", "  1. The external environment writes inputs into the register file.\r\n", "  2. The external environment signals a \"Cycle\" to run the program and calculate a cycle.\r\n", "  3. The external environment waits for \"Done\", then reads output from the register file.\r\n", "\r\n", "Instruction Set:\r\n", "\r\n", "There are 4 instruction types and a total of 8 instructions.  Each instruction is 16-bits.  The types include:\r\n", "- Unary Operation\r\n", "  - OpCode [15:12], Operand A Reg [11:8], Not Used [7:4], Result Reg [3:0]\r\n", "- Binary Operation\r\n", "  - OpCode [15:12], Operand A Reg [11:8], Operand B Reg [7:4], Result Reg [3:0]\r\n", "- Constant Load\r\n", "  - OpCode [15:12], Constant Memory Address [11:4], Result Reg [3:0]\r\n", "- Halt\r\n", "  - OpCode [15:12], Not Used [11:0]\r\n", "\r\n", "Unary Operations (OpCode):\r\n", "- ShiftLeft (0000)\r\n", "  - RegX   - Flag - ShiftRight (0001)\r\n", "  - RegX   - Flag - ShiftClip  (0010)\r\n", "  - RegX   - RegX   - RegX   - Flag   - Performs a limited/clipped multiplication by 2.\r\n", "\r\n", "Binary Operations (OpCode):\r\n", "- Add (0011)\r\n", "  - RegX   - Flag - AddCond (0100)\r\n", "  - RegX   - Flag - Sub (0101)\r\n", "  - RegX   - Flag - Switch (0110)\r\n", "  - RegX   - Flag \r\n", "Constant Load Instruction (OpCode):\r\n", "- Constant (0111)\r\n", "  - RegX   - Flag \r\n", "Halt Instruction (OpCode):\r\n", "- Halt (1---)\r\n", "  - Halts processor (prevents further register updates).\r\n", "\r\n", "Booth multiplication can be performed using ShiftRight and AddCond with an accumulation register.\r\n", "\r\n", "Each file is stand-alone and represents a specific configuration.\r\n", "The 2 parameters are:\r\n", "- Data Width\r\n", "- Instruction Memory Address Width\r\n", "\r\n", "The configuration parameters are coded in the file names: cf_ssp_32_5.v\r\n", "- 32 : Data Width\r\n", "- 5 : Instruction Memory Address Width\r\n", "\r\n", "Current configurations:\r\n", "- cf_ssp_8_6\r\n", "- cf_ssp_16_6\r\n", "- cf_ssp_32_6\r\n", "- cf_ssp_64_6\r\n", "- cf_ssp_8_7\r\n", "- cf_ssp_16_7\r\n", "- cf_ssp_32_7\r\n", "- cf_ssp_64_7\r\n", "- cf_ssp_8_8\r\n", "- cf_ssp_16_8\r\n", "- cf_ssp_32_8\r\n", "- cf_ssp_64_8\r\n", "- cf_ssp_8_9\r\n", "- cf_ssp_16_9\r\n", "- cf_ssp_32_9\r\n", "- cf_ssp_64_9\r\n", "- cf_ssp_8_10\r\n", "- cf_ssp_16_10\r\n", "- cf_ssp_32_10\r\n", "- cf_ssp_64_10\n        "]},
{"details": ["\n    Name: avr_hp", "\n    Created: Oct 15, 2010", "\n    Updated: Dec 22, 2012", "\n        SVN Updated: Oct 16, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The project is based on OpenCores' AVR project by Ruslan Lepetenok.\r\n", "\r\n", "The core is now hyper pipelined. It is a technique to multiply the functionality\r\n", "of a design by adding registers (called pipeline stage registers) to the core logic\r\n", "in order to multiply its functionality. If you are interested in the technology, go to www.cloudx.cc\r\n", "\r\n", "The functional behavior of the AVR remains the same, the hyper pipelined version\r\n", "is used when multiple, equal AVR cores (2, 3, ...) are instantiated in the\r\n", "design (multicores).\r\n", "\r\n", "The main benefit is the multiplication of the core's functionality by only\r\n", "implementing registers. This leads to a reduced size compared to the\r\n", "individual instantiation of the cores. This is a great advantage for ASICs\r\n", "but obviously very attractive for FPGAs with their already existing registers.\r\n", "\r\n", "Another issue is the performance of the resulting hyper pipelined AVR core.\r\n", "The pipeline stage registers are timing driven placed to partition the critical\r\n", "path into equal parts, which leads to an almost multiplied performance of the\r\n", "design. The timing is optimized for a Spartan 3 and a Virtex 5 device from Xilinx.\r\n", "\r\n", "The modifications are done on RTL, so that the project can be used in an\r\n", "RTL based testbench.\r\n", "\r\n", "The project shows the modified RTL code with 2, 3 and 4 times multiplied\r\n", "functionality. It is delivered with a testbench and a detailed documentation. \r\n", "\r\n", "\r\n", "Enjoy ...\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: cpu6502_true_cycle", "\n    Created: Jan 23, 2008", "\n    Updated: Jul 24, 2013", "\n        SVN Updated: Mar 15, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a VHDL/Verilog IP core with True Cycle Timing for Rockwell's 6502 8-Bit CPU. With full functional input signals like ready, interrupt, non maskable interrupt and set overflow flag. Also available is the output signal sync which signals an op fetch. The ready signal is usable for DMA operations or multiprocessing. Signal sync can be used for software/hardware debugging via single stepping (single cycles or complete op codes) the 6502.\r\n", "This core was successfully tested in an APPLE ][+ SoC (completely designed into a FPGA with Z80 Softcard, DISK2 System, 80C Card, Language Card and 48kB of main memory).\r\n", "\r\n", "Please feel free to contact me for any reasons like ideas or error messages.\r\n", "\n        ", "\n            - true cycle timing for all official opcodes \r\n", "- unknown op's decoded as \"NOP/0xEA\" \r\n", "- one clock source \r\n", "- input signal \"rdy_i\" for generating waitstates (see original documentation of R6502) \r\n", "- output signal \"sync_o\" to indicate an op fetch (see original documentation of R6502) \r\n", "- input signal \"so_n_i\" sets the internal OV Flag (see original documentation of R6502) \r\n", "- fully synthesizable VHDL and Verilog\r\n", "\n        ", "\n            CORE:     Ready for use and downloadable via SVN", "\r\nLICENSE: Puplished under GPL V3", "\r\nDOCUMENTATION: \"on working\"", "\r\nTESTBENCHES: \"on working\"", "\r\nTESTSOFTWARE: \"on working\"", "\r\n\r\n", ":", "\r\n- all op codes: simulated and approved under real working conditions (APPLE ][plus SoC)", "\r\n- irq_n_i: simulated and run in real environment", "\r\n- nmi_n_i: simulated and run in real environment", "\r\n- so_n_i: only simulated", "\r\n- all other signals: simulated and approved under real working conditions (APPLE ][plus SoC)", "\r\n", "\r\n", ":", "\r\n(Mar-15-2010)", "\r\n- Correct interrupt sequences for NMI and IRQ", "\r\n", "\r\n(Feb-25-2009)", "\r\n- Correct \"RTI\" (wrong: use of stack pointer)", "\r\n- Rename all states of \"FSM Execution Unit\" for better reading", "\r\n- Update HTML documentation", "\r\n- (90%) Finish working for Specification of cpu6502_tc", "\r\n", "\r\n(Jan-09-2009)", "\r\n- Phaze 2: Remove unused nets, registers and modules", "\r\n- Added Verilog source files on demand by customers (for trial use)", "\r\n", "\r\n(Jan-04-2009)", "\r\n- Remove unused nets, registers and modules", "\r\n- Update HTML documentation to visualize the Execution unit", "\r\n", "\r\n(Apr-17-2008)", "\r\n- State of project", "\r\n- CVS loaded with new core and HTML documentation", "\r\n- correct the handling of the stack while BRK, IRQ and NMI", "\r\n- correct the handling of \"B\" flag while BRK", "\r\n- correct the alignment between addresses and data while BRK, IRQ and NMI when writing onto the stack", "\r\n\r\n\r\n\n        "]},
{"details": ["\n    Name: aspida", "\n    Created: Dec 13, 2002", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            The ASPIDA project has implemented an asynchronous IP of the DLX Instruction Set Architecture (ISA) with incorporated support for ISA conversion so it can be easily converted to any RISC ISA. The DLX architecture, is well-supported by existing software development tools (compiler, assembler, loader, instruction set simulator and debugger).\r\n", "\r\n", "The synchronous single-pipeline architecture, which is standard for the basic synchronous DLX implementations, is identical to the architecture of the asynchronous version. A suitable Open IP interface (WISHBONE) is embedded onto the processor to enable it to be integrated into any Open IP SOC system. In addition, the ASPIDA project issues a new Open IP interface standard based on asynchronous technology (CHAIN), and support for this new Open IP interface is also embedded onto the processor core.\r\n", "\r\n", "A design flow that is based as much as possible on existing EDA tools for all design steps, and which is part of the background technology brought in by the partners, has been used in order to produce a portable netlist, and to distribute all the intermediate HDL files used for high-level and gate-level design. The final product is technology-independent and timing-independent and in a form suitable for integration using only standard, industrial tools and flows, with no dependence on asynchronous tools and specific knowledge of asynchronous design for potential end users.\n        ", "\n            - Technology-portable processor core\r\n", "- Fully-asynchronous core for low-power, low-EMI\r\n", "- Industrial-quality testability (internal scan)\r\n", "- WISHBONE interface\r\n", "- Core includes additional novel asynchronous bus, CHAIN (CHip Area INterconnect)\r\n", "- Targetted for ASIC EDA flows\n        ", "\n            - Project is completed\r\n", "- Fully Working FPGA Implementation is available on Xilinx Spartan 2E device\r\n", "- ASIC Implementation completed and tested\r\n", "- Download FAQ and all the sources and scripts from the project download section\r\n", "- Visit our ASYNC group web page at ", "\n        "]},
{"details": ["\n    Name: sap", "\n    Created: Apr 10, 2012", "\n    Updated: Jul  2, 2017", "\n        SVN Updated: Apr 11, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is 8-bit microprocessor with 5 instructions. It is based on 8080 architecture. This architecture called SAP for Simple-As-Possible computer. It very useful design which introduces most of the basic and fundamental ideas behind computer operation.\r\n", "\r\n", "This design could be used for instruction classes for undergraduate classes or specific VHDL classes. This processor is based on the 8080 architecture, therefore, it could be upgraded step by step to integrate further facilities. It is very exciting challenge for the students to do so. Further, they could think about building complete system, i.e. integrating and I/O peripherals to the processor.\r\n", "\r\n", "The design is proven for ASIC and FPGA. It was implemented using Xilinx FPGA Spartan-3E starter kit. A full documentation for the code and the used resources are attached within the project.\r\n", "\r\n", "I hope that you will enjoy it.\r\n", "\r\n", "Personally, I recommend you to start building your own design then you can compare to this one as a reference design. We learn from our mistakes.\r\n", "I will be glad to receive your feedback and comments, acknowledgments would be great as well.\n        "]},
{"details": ["\n    Name: amber", "\n    Created: Dec 23, 2010", "\n    Updated: Sep  8, 2017", "\n        SVN Updated: Apr 11, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 41 reported / 32 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n        "]},
{"details": ["\n    Name: altor32", "\n    Created: Jun  9, 2012", "\n    Updated: Feb 15, 2015", "\n        SVN Updated: Jun 28, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            AltOR32 is an OpenRISC 1000 architecture derived RISC CPU targeted at small FPGAs and contains only the most basic ISA features from the OpenRisc project. \r\n", "Instructions & registers relating to Vector, floating-point, 64-bit extensions, MMU & Cache have been omitted. \r\n", "The aim of AltOR32 is to provide a simple 32-bit soft CPU architecture aimed at control applications that can fit in low-end FPGA technology. \r\n", "\r\n", "This design implements all instructions that cannot be disabled. Anything else is viewed as beyond the scope of this cut-down soft-CPU implementation. \r\n", "\r\n", "AltOR32 does not make use of delay slots, unlike the original OpenRisc implementation. \r\n", "Due to this, the or1knd toolchain is required. \n        ", "\n            The 'or1knd' toolchain is required for this target. \r\n", "\r\n", "To build from source: \r\n", "\r\n", "git clone git://github.com/openrisc/or1k-src.git  \r\n", "git clone git://github.com/openrisc/or1k-gcc.git  \r\n", "\r\n", "Build the first set of tools, binutils etc.\r\n", "\r\n", "../or1k-src/configure --target=or1knd-elf --prefix=/opt/or1k-toolchain --enable-shared \\ \r\n", "--disable-itcl --disable-tk --disable-tcl --disable-winsup --disable-libgui --disable-rda \\ \r\n", "--disable-sid --disable-sim --disable-gdb --with-sysroot --disable-newlib --disable-libgloss --disable-werror  \r\n", "make  \r\n", "make install  \r\n", "\r\n", "Build gcc \r\n", "\r\n", "../or1k-gcc/configure --target=or1knd-elf --prefix=/opt/or1k-toolchain --enable-languages=c \\ \r\n", "--disable-shared --disable-libssp --disable-werror  \r\n", "make  \r\n", "make install  \n        ", "\n            The project contains a Verilator cycle accurate model of the CPU which can execute the same code as the simulator. Waveforms can be outputted and viewed in GTKWave.\r\n", "\n        ", "\n            - Pipelined Verilog core with optional instruction & data cache. \r\n", "- Synthesizes to ~100MHz on a Xilinx Spartan 6 LX9 -3\r\n", "- Harvard architecture (separate instruction & data cache / memory interfaces). \r\n", "- Support for interrupts & tick timer. \r\n", "- Also non-pipelined 'lite' version available. \n        ", "\n            - A simple simulator for OpenRisc instructions. \r\n", "- Able to execute OpenRisc 1000 (ORBIS32) code compiled with the following options: \r\n", "-msoft-div -msoft-float -msoft-mul -mno-ror -mno-cmov -mno-sext \r\n", "- Extensible \n        "]},
{"details": ["\n    Name: a-z80", "\n    Created: Dec 12, 2014", "\n    Updated: May 18, 2017", "\n        SVN Updated: Feb 24, 2018", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n            ", "\n            ", "\r\nA ", " document is here: ", "\r\n", "\r\nComplete ", " is here: ", "\r\nIn addition, project files contain a number of readme's to help you understand, recreate it and/or add A-Z80 to your own project.\r\n", "\n            ", "\n            This design is fully completed, tested and working.\r\n", "\r\nA ", " based ", " board implementation used about 11% of its LE's.\r\n", "\r\n", "\r\n", "\r\nA ", " based ", " board implementation used about 19% of its slices.\r\n", "\r\n", "\r\n", "\r\n\r\nThis implementation is using free Altera and Xilinx tools (", " v13.0.1 Web Edition and ", " Webpack). It also uses Python 3.5 to build some components and tests.\r\n", "\r\nAlthough based on Altera and Xilinx devices, this project could be used with other vendors\r\nsince (Quartus-specific) schematic files are pre-compiled into generic Verilog files.\r\n\n        "]},
{"details": ["\n    Name: arm4u", "\n    Created: Mar 31, 2014", "\n    Updated: May  2, 2014", "\n        SVN Updated: May  2, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This processor, done as an university project, is a functional clone of the ARM processor, is almost entierely compatible with the ARMv3 instruction set and can be targetted by the GCC toolchain if the proper options are used during the compilation process.\r\n", "\r\n", "The processor uses a classical 5-stages RISC pipeline and an instruction cache. It was made to connect to the Altera Avalon bus, as a Q-Sys compatible component. It should however be simple to retarget it for other similar buses.\r\n", "\r\n", "We made it run at 50 MHz on a Cyclone IV FPGA.\r\n", "Full VHDL sources, schematics and documentation is included.\n        "]},
{"details": ["\n    Name: cpu8080", "\n    Created: Oct  4, 2006", "\n    Updated: Apr 28, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is an 8080 core I created as a project to get to know Verilog. \r\n", "\r\n", "The 8080 was the second in the series 8008->8080->Z80. It was the second\r\n", "commercially available single chip CPU (disregarding the required\r\n", "clock and multiplexer chips), after the 4 bit 4004. Besides being an interesting\r\n", "project, it also can serve as a very compact core, suitable for a supervisor role on an\r\n", "FPGA with other blocks. It has extensive support, all freely available, including\r\n", "assemblers, compilers, an operating system (CP/M).\r\n", "\r\n", "Although the Z80 is a more popular core due to being a superset of the 8080, the Z80\r\n", "takes considerably more chip real estate.  Its likely that more than 50% of available\r\n", "software is 8080 only, since the Z80 was often used to run 8080 code. For example,\r\n", "the CP/M OS itself was 8080 only code.\r\n", "\r\n", "This means that the 8080 can be an attractive core if you want the great support of\r\n", "this processor series, but need it to fit in less space.\r\n", "\r\n", "The core is fully instruction compatible with 8080, but not signal compatible. The\r\n", "original 8080 was a multiplexed nightmare. one of the original selling points of the Z80\r\n", "was its cleanup of the signals, and the 8080 itself had a companion chip that\r\n", "demultiplexed it.\r\n", "\r\n", "There are a few other similar chips on opencores. This one is a bit different because\r\n", "it is only 8080, and is in native Verilog (not a translation). Further, the goal was to\r\n", "get it down to the minimum in both source size and synthesized size.\r\n", "\r\n", "I also suspect there is a perverse advantage to running this core: its original\r\n", "manufacturer no longer makes it, or any compatible chip, and it has probally passed\r\n", "from any IP protection long ago. However, as usual, Should warn that I have not\r\n", "verified any legal status on this processor and do not speak from any knowledge or\r\n", "authority on the matter.\r\n", "\r\n", "Postscript\r\n", "\r\n", "I did this core back in 2006. I know it has been incorporated in real designs, and\r\n", "has generated several other projects here on Opencores. I even found it mentioned\r\n", "in online research projects.\n        ", "\n            Instruction set: 8080\r\n", "Data size: 8 bit\r\n", "Address: 16 bit\r\n", "Instruction: 8 bit\r\n", "Language: Verilog\r\n", "License: None (public domain)\r\n", "Created under: Xilinx ISE, free webpack edition\r\n", "Device: xc3c1000-4ft256\r\n", "Slices: 1104\r\n", "Slice flip flops: 296\r\n", "4 input LUTs: 2082\r\n", "Bonded IOBs: 33\r\n", "GCLKs: 1\r\n", "\r\n", "The CPU works entirely on positive clock edges and signals, but could be reconfigured\r\n", "easily.  It has wait state ability, and simple interrupt request/acknowledge structure.\r\n", "The original 8080 method of fetching an external instruction to satisfy the interrupt is\r\n", "preserved, and it is left up to an external interrupt controller to provide vectoring.\r\n", "\r\n", "I have no problem with, and in fact encourage, commercial use, modifications (public\r\n", "and private), etc.\r\n", "\n        ", "\n            2016/04/27 Status:\r\n", "\r\n", "Fortunately or unfortunately I have been working with Verilog again, and have a few\r\n", "changes and additions I want to make.\r\n", "\r\n", "- Make it boot CP/M, probably up to 3.0. CP/M was the only real OS possibility for\r\n", "  the 8080, so stands to reason that would be a target.\r\n", "\r\n", "- Reduce the gate count of the core (while perhaps making the code more clear).\r\n", "\r\n", "I considered making it a MITS Altair 8800 emulator. It was kinda already headed\r\n", "in that direction. This is both for nostalgia reasons as well as practical ones.\r\n", "The MITS manuals are all online, it was a very popular machine, it was the first\r\n", "real hobbyist computer, and I happen to have one in the garage gathering dust. \r\n", "The problem is the the 88-DCDD, the one created by MITS itself, as well as many\r\n", "other disk controllers of the era, directly read data off the disk. You kids\r\n", "don't know what that means. It means you got a shift register, some logic to \r\n", "sync the serial data to byte boundaries, and that was really about it. The CPU\r\n", "would form a tight loop and read from the shift register and place in memory\r\n", "as fast as possible, and that would be JUST enough to keep up with floppy disk\r\n", "speeds (in fact the first floppy controller I used toggled the wait state line\r\n", "to keep the CPU synced to the byte boundaries). Later on they came out with\r\n", "buffered, fully controlled chips for floppies (Western digital). \r\n", "\r\n", "It is possible to emulate such an interface, but at that point you would be emulating\r\n", "timing as well. I notice that many MITS 8800 simulators attempt to do this, ie.,\r\n", "emulating the exact timing of the 8080. The short answer is that I did my time\r\n", "emulating existing systems like this, and it is a real time sink. There is nothing\r\n", "in the CP/M bios that needs timing, its actually a very simple interface, I have\r\n", "written several.\r\n", "\r\n", "To host CP/M, the design needs two facillities that I didn't do the last time around.\r\n", "The first is a flash drive interface, and the second, perhaps optional, is a DRAM\r\n", "interface. I say perhaps optional because placing a 64kb memory block onchip is not\r\n", "out of the question, and may actually be a good idea for small designs.\r\n", "\r\n", "For the second point, reducing the size of the core, I am gratified that that became\r\n", "sort of a contest here on Opencores. I think the winner is the 200 LUT design by\r\n", "Ruiz & Moti. There should have been some kind of prize for what they accomplished.\r\n", "It was probably far more work to make it that small than to make a \"regular\" \r\n", "implementation. cpu8080 comes out at about 2000 LUTs. In my defense, this was\r\n", "my first Verilog design, and I often looked at it and realized I could do better.\r\n", "\r\n", "Notice:\r\n", "\r\n", "The CPU8080 project has passed a very complete CPU instruction test, and has run\r\n", "a medium (but not large) piece of code, the SCS1 monitor, this morning. I have marked\r\n", "the project as complete.\r\n", "\r\n", "Tonight, after consideration, I think I will call it complete, at least for a while. I was\r\n", "planning to take the design to a CP/M boot, but I think I have accomplished my\r\n", "original purpose, and more. I have high confidence in this core, and I hope you all can\r\n", "find uses for it. In the meantime, I have other projects, and my paid work calling.\r\n", "\r\n", "Feel free to email me questions. Good luck, and good success with your projects.\r\n", "\r\n", "2006/11/20 Status:\r\n", "\r\n", "The SCS1 monitor/assembler signs on!\r\n", "\r\n", "\r\n", "\r\n", "Here it is shown signing on, and executing a \"dump 0 30\" command to dump the first\r\n", "30h bytes in the system.\r\n", "\r\n", "The wires trailing off the XESS board are the Intronix USB analyzer wires.\r\n", "\r\n", "Note that I added the sign on message to SCS1, normally it has no sign on.\r\n", "\r\n", "This marks the first major piece of original 8080 software CPU8080 has run. I am\r\n", "promoting the project status because of it.\r\n", "\r\n", "2006/11/18 Status:\r\n", "\r\n", "cpu8080 passes the Kelly Smith test, both in simulation and in hardware. There were\r\n", "8 different cpu bugs solved by my count, so this is a very important series of updates.\r\n", "Kelly Smith is an 8080 CPU test created in 1980 under the Microcosm Associates\r\n", "brand name, and donated to the \"SIG/M\" CP/M user's group.\r\n", "\r\n", "Its a very complete CPU test for all flags, modes and instructions, so passing that is\r\n", "very good for the design.\r\n", "\r\n", "Chris Strahm's modifications were incorporated, which include the following:\r\n", "\r\n", "1. All constants that are not a single bit have their bit width specified. This was\r\n", "required to remove Quartus errors.\r\n", "2. Wait state ability is now optional. See cpu8080.v.\r\n", "3. I/O instructions are now optional. See cpu8080.v.\r\n", "\r\n", "The last two are part of the \"super compact\" core concept that Mr. Strahm is\r\n", "following. See the section below for more details on this.\r\n", "\r\n", "2006/11/15 Status:\r\n", "\r\n", "The ADM 3A terminal emulation is very complete now. There are only a few modes\r\n", "missing, reduced intensity and graphics. There are still a few issues with the\r\n", "emulation, but they are minor, and should not impact any software.\r\n", "\r\n", "Going forward, I have hooked up with Rich Cini's excellent Altair website and project\r\n", "page at:\r\n", "\r\n", "\r\n", "\r\n", "And the material there is really going to help me speed up this work.\r\n", "\r\n", "I want to emphasize that I am not creating a \"computer history\" project here. The\r\n", "logic is simple: The most complete test of a CPU is to run an extensive suite of\r\n", "existing software, and that means existing operating systems, compilers and utilities,\r\n", "of which the 8080 has quite a large supply. With the 8080 being more than 30 years\r\n", "old, any such systems are going to look like a history project. The reason it's useful\r\n", "to me is that a popular computer has a lot of preexisting software available for it.\r\n", "\r\n", "In fact, Rich's site has already taken care of a large peice of work I had yet to do,\r\n", "there is a full CPU test suite available there, 8080test.asm. The code is dated 1980,\r\n", "and I'll bet the author never would have imagined it would be used to proof a new\r\n", "implementation of the 8080. I'll post the result when that runs, which should be\r\n", "shortly.\r\n", "\r\n", "Moving forward from there, the only piece of hardware left to emulate is the Altair\r\n", "floppy disc controller, which looks pretty simple. After that, I will be able to use\r\n", "Rich's rich catalog of disc images including CP/M 2.2, Microsoft Basic and others to\r\n", "do a full 8080 checkout without so much as performing an assembly.\r\n", "\r\n", "There is a Altera/Quartus version of the CPU being developed by a user who has been\r\n", "emailing me of late. I hope to have more news on this later.\r\n", "\r\n", "Previous status:\r\n", "\r\n", "The design runs, abet with a simple program, on an XESS 1000 board. It prints\r\n", "\"Hello, FPGA world\" on a VGA display. Here is a picture:\r\n", "\r\n", "\r\n", "\r\n", "There have been a lot of improvements since the last version. First, I switched to the\r\n", "50 mhz clkb, which gets divided down from the 100 XESS board clock. There are a\r\n", "couple of reasons for this. The CPU core appeared to be deeply unhappy about running\r\n", "at the top speed of the FPGA, and was showing internal failures. Second, the raw\r\n", "100 mhz clock was coming direct from the oscillator, which I believe has a non-50/50\r\n", "duty cycle. Since I have been using both edges, that's bad.\r\n", "\r\n", "Second, I switched most clocking to positive edges. In fact, there is only one negedge\r\n", "left, and that's because I haven't had time to test it.\r\n", "\r\n", "Third, all of the read and write signals from the CPU, I/O and memory, were extended\r\n", "by a cycle. This was required to get the single edge clocking going, and relaxes the\r\n", "timing all around.\r\n", "\r\n", "With these changes, the design is now running quite well. The \"hello, FPGA world\"\r\n", "example now runs a terminal emulator loop, and the ADM 3A dumb terminal is fairly\r\n", "complete. It features shift, caps, and control keys on input, and obeys the ADM 3A\r\n", "controls, most of them, on output. See vgachr.v for details on what is and is not\r\n", "implemented.\r\n", "\r\n", "By entering various characters in the terminal mode, I have tested all the usual\r\n", "control characters, line up, down, left, right, clear screen, etc.\r\n", "\r\n", "For anyone who has got far with trying this design out, I'll apologize in advance for\r\n", "the character font. It was banged out in about 2 hours, I just wanted something\r\n", "for test. I'll be cleaning it up later.\r\n", "\r\n", "I'm currently using a Intronix 34 channel USB logic analyzer to verify the design on\r\n", "hardware. Chipscope was just out of reach for me, it not only takes about $800 for\r\n", "a full version, but requires you also to purchase the full, not free, version of ISE,\r\n", "bringing the total cost to about $3000. I have all of the CPU signals brought out to\r\n", "the analyzer, plus you'll notice an 8 bit \"debug\" bus that replaces the top 8 bits\r\n", "of the address lines. This technique allows me to attach various signals to the \"bus\"\r\n", "to be routed out to the external analyzer, and I can swap this to and from the debug\r\n", "bus by modifying the pin assignments at the top level.\r\n", "\r\n", "What's next is the Imsai monitor/assembler discussed below. I'm going to run that\r\n", "under a simulator first, so that is 1 to 2 weeks off. I'll post a new picture when that\r\n", "runs.\r\n", "\r\n", "The testbench so far on the hardware consists of the following:\r\n", "\r\n", "8080 core\r\n", "ROM to store test program (\"hello\"/terminal emulator)\r\n", "RAM\r\n", "Select controller\r\n", "Interrupt controller (no plans to use this on the hardware)\r\n", "ADM 3A Dumb Terminal emulator\r\n", "\r\n", "The wait state capability, as of this writing, has not been verified. For anyone curious,\r\n", "the \"select controller\" has bits reserved for this, bits 0 and 1 of the mask register\r\n", "will select from 0 to 3 wait states for that select.\r\n", "\r\n", "I plan to add a bus hold (tristate) and acknowledge pins and mode, this will allow\r\n", "connection of an external DMA. I don't plan to actually create a DMA, since this\r\n", "project needs to end (da' wife is getting annoyed). I'll just activate the hold pin and\r\n", "watch for high-z on all outputs.\r\n", "\r\n", "I also plan to add a NMI (non maskable interrupt) pin. That will get a simple test\r\n", "as well.\r\n", "\r\n", "I placed an assembler file in the source that I will use for first tests with the core:\r\n", "\r\n", "scs1.asm - An IMSAI monitor/assembler\r\n", "\r\n", "This is a famous old program for the 8080. It preceeds CP/M. It's interesting\r\n", "as first test because it only uses a single I/O port to the console.\r\n", "\n        ", "\n            There is TONS of software available for the 8080. The best way to go about it is to run\r\n", "a CP/M simulator on your host machine. Here are a few:\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "For development systems, try these forums:\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "This includes CP/M, assemblers, a basic compiler, the original Microsoft Basic interpreter,\r\n", "Fortan compilers, Cobol, C (of course), Pascal, Modula, Algol, and Ada.\r\n", "\r\n", "You can find a lot more with a simple search.\r\n", "\r\n", "CP/M itself is a good, small operating system to run on your target if you wish. It can be\r\n", "adapted to your target hardware with a very simple BIOS, which can run using a flash\r\n", "memory as the \"disk\" for it. The entire system fits in less than 256kb (yes, actually less\r\n", "than a meg), which was the common size of a floppy disk back when this CPU was\r\n", "popular.\r\n", "\r\n", "If you choose to run CP/M, the amount of software available is truly amazing. Try\r\n", "these sections of the retroarchive:\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "CP/M was a popular system from the start of the home computer revolution to well\r\n", "into the 1980's, and continues to have a following today.\r\n", "\r\n", "I use a proprietary development system, the IP toolset, at my web site. This is not\r\n", "meant as a plug for that system (the 8080 version is not even for sale), but simply to\r\n", "explain why you will see a lot of the support files for the assembly code configured\r\n", "for that system. There is nothing I have here that you cannot find for free at the\r\n", "above sources. The main advantage I get from the IP toolset is that it runs natively\r\n", "under Windows/XP.\n        ", "\n            The 8080 CPU implemented here was created as a not for profit student project. I don't\r\n", "know if  its use will violate patents, copyrights, trademark rights or other rights. The\r\n", "source files were created entirely by me, but their use, commercial or otherwise, and\r\n", "any legal, consequences that arise, are entirely the responsibility of the user. I\r\n", "specifically deny that this core is usable for life support systems, or any other system\r\n", "that can or will cause, directly or indirectly, any harm to persons or property.\r\n", "\r\n", "THESE SOURCE FILES ARE PROVIDED \"AS IS\" AND WITHOUT ANY\r\n", "EXPRESS OR IMPLIED WARRANTIES, INCLUDING, WITHOUT\r\n", "LIMITATION, THE IMPLIED WARRANTIES OF MERCHANTIBILITY AND\r\n", "FITNESS FOR A PARTICULAR PURPOSE. \n        ", "\n            The CVS repository is under cpu8080.\r\n", "\r\n", "I'll apologize in advance, but repository is basically a dump of my Xilinx ISE directory. This\r\n", "is not the clean way to do it, but it does have the advantage that if you are running\r\n", "ISE, you can download the entire thing and just go. Here is a list of the important files\r\n", "in the directory:\r\n", "\r\n", "readme.txt - A copy of this text\r\n", "cpu8080.txt - The documentation for the project, in plain ASCII.\r\n", "cpu8080.v - The 8080 core\r\n", "testbench.v - The testbench for the core. Also contains the peripherals for the core,\r\n", "such as the peripheral select controller, the interrupt controller, the test ROM, RAM, and\r\n", "anything else required.\r\n", "vgachr.v - The ADM 3A dumb terminal emulator, keyboard interface, and MITS Serial\r\n", "I/O emulator.\r\n", "vga.vhd - The stripped XESS vga timing generator/pixel shift register.\r\n", "ps2_kbd.vhd - The XESS keyboard interface.\r\n", "\r\n", "The other files are the testbench running files, like the stimulus package. I don't even\r\n", "know what half of them are, sorry, I only started using the system 2 weeks ago!\n        ", "\n            For people who want ask me questions, or find out more about what I am doing, my\r\n", "information is:\r\n", "\r\n", "Email: samiam@moorecad.com\r\n", "Web page: ", "\r\n", "\r\n", "Disclaimer: The above web page does include commercial content, ads, rants, etc.\n        ", "\n            Here are some locations that have the original 8080 documentation:\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "That last link contains the \"8080 Assembly language programming manual\", which is the\r\n", "book that I used to construct cpu8080, from my original coffee stained edition, bought in\r\n", "1977.\r\n", "\r\n", "For people interested in the difference between the 8080 and its predecessor, the 8008,\r\n", "the following site is available:\r\n", "\r\n", "\r\n", "\r\n", "You can find the User's reference manual for the ADM 3A dumb terminal, which was used\r\n", "to produce the emulation used in this design, at:\r\n", "\r\n", "\r\n", "\r\n", "You can find a copy of the manual for the REALLY elementary MITS Serial I/O card used\r\n", "to construct the serial port emulation on the design at:\r\n", "\r\n", "\n        ", "\n            Chris Strahm has been working on a \"super compact\" 8080 core. The idea is to strip out\r\n", "features that are not absolutely required for most designs.\r\n", "\r\n", "He's been reporting cell counts (LUTS) of below 1500.\r\n", "\n        "]},
{"details": ["\n    Name: aquarius", "\n    Created: Jul 12, 2003", "\n    Updated: Jul  6, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\r\n", "\n        ", "\n            Aquarius is a Core IP (Intellectual Property) of pipelined RISC CPU and can execute SuperH-2 instructions. Follows are SuperH characteristics. \r\n", "\r\n", "- SuperH is a very popular CPU core. The software development environments such as C compiler have been well prepared. The GNU C compiler for SuperH is very famous and easy to get. The SuperH had been developed by Hitachi, Ltd. Now, semiconductor group of Hitachi has merged with same group of Mitsubish and new semiconductor company ?gRenesas Technology Corp.?h has established in April, 2003. \r\n", "- SuperH-2 is a CPU for MCU (Micro Controller Unit). Then the CPU need not handle complex exception recovering such as memory fault exception from MMU (Memory Managing Unit). This means SuperH-2 has simple structure, easiness to design, and it does not consume many logic gates and power. \r\n", "- All SuperH-2 instructions have 16bit length. It also makes the hardware very simple. And most important aspect from 16bit fixed length of instructions is that the object code size compiled from C source programs becomes very small. \n        ", "\n            - Instruction set is compatible with SuperH-2. \r\n", "- Bus interface is compatible with WISHBONE. \r\n", "- Aquarius is written in Verilog RTL codes. \r\n", "- Aquarius has verified on a test bench by vector simulation and FPGA implementation with GNU Assembler and C Compiler. \r\n", "- Interrupts and Exceptions are fully supported. \r\n", "- Low Power Mode (SLEEP) is supported. \r\n", "- Some small applications are provided including debugging monitor for a FPGA board. \r\n", "- A complete Document with over 100 pages, describing Usage of Aquarius, FPGA Implementation and Inside Aquarius, is provided. \r\n        ", "\n            FILE: cpublock.gif\n", "DESCRIPTION: CPU Block Diagram\n", "\n        ", "\n            Top layer of Aquarius is ?gCPU?h which has WISHBONE compliant bus signals and accepts interruption related signals. The most important system signals such as clock and reset are not shown in this figure.\r\n", "\r\n", "The Memory Access Controller handles instruction fetch and data read/write access.  The operations of Memory Access Controller are fully controlled by Decoder unit. Memory Access Controller sends fetched instruction bit fields to the Decoder unit, and interchanges read/write data and its address with Data Path unit. Aquarius assumes the Wishbone bus is a Non-Harvard bus, then the simultaneous instruction fetch and R/W data access makes bus contention. Memory Access Controller handles such contention smoothly and informs the pipeline stall caused by the bus contention to Decoder unit. Also, the Memory Access Controller can sense each boundary of bus cycles (with wait state) from WISHBONE ACK signal. In Aquarius architecture (may be in SuperH-2 architecture as well), such bus cycle boundary corresponds to the pipeline?fs slot edge. So the Memory Access Controller produces the most important pipeline control signal ?gSLOT?h indicating pipeline slot edge.\r\n", "\r\n", "The Data Path unit has registers you can see in programmer?fs model in SuperH-2 manual such as General Registers (R0 to R15), Status Register (SR), Global Base Register (GBR), Vector Base Register (VBR), Procedure Register (PR) and Program Counter (PC). The Multiplication and Accumulate Registers (MACH/MACL) are found in Multiplication unit. The Data Path unit also has necessity operation resources such as ALU (Arithmetic and Logical operation Unit), Shifter, Divider, Comparator, temporary registers, many selectors, interfaces to/from Memory Access Controller and Multiply unit, and several buses to connect each resource. The Data Path is fully controlled by control signals from Decoder unit. \r\n", "\r\n", "Multiplication unit has a 32bit x 16bit multiplier and its control circuits. A 16bit x 16bit multiplication operation is executed in one clock cycle. A 32 bit x 32bit multiplication operation is done in two clock cycles. Multiplication unit also has the Multiplier and Accumulate Registers (MACH/MACL). The MACH/MACL are not only the final result registers of multiply or multiply-and-accumulation but also the temporary registers to hold the 48bit partial multiply result from 32bit x 16bit multiplier for 32bit x 32bit operation. The multiply instruction, for example MULS.L, clears the contents of MACH/MACL in early stage of the instruction operation. However the multiply and accumulate instruction, for example MAC.L, does not clear MACH/MACL before the operation. The MAC.L accumulates its own partial multiply result to initial MACH/MACL and then finalize the operation result. The major difference between multiply (MULS.L) and ?gmultiply and accumulate?h (MAC.L) is whether to clear or not to clear the MACH/MACL before the operation. And also, for MAC.L and MAC.W instruction, the accumulation adder in this unit has saturating function.\r\n", "\r\n", "The Decoder unit is the fundamental CPU controller. It orders Memory Access Controller fetch instructions and then receives the instruction. The Decoder Unit decodes the instruction bit fields and judges the followed operations. Basically, the Decoder unit plays the role only for the instruction ID stage. But it throws many control signals for following EX, MA and WB stages toward Data Path unit, Multiplication unit, and Memory Access Controller. These control signals are kept and shifted with its pipeline flow at each slot edge until reaching to the target stage of the instruction. The Decoder unit detects every conditions of pipeline stalling, and makes each unit of CPU be controlled properly. Also, it controls not only simple 1 cycle instructions but also multi cycle instructions and exception?fs sequences such as interrupt and address error. \n        ", "\n            - RTL coding and verifying have already been finished. \r\n", "- FPGA (Xilinx VirtexE) implementation with LCD, Matrix Keyboard and RS-232C interfaces has also finished using GNU Assembler and C Compiler.\r\n", "- Some small Applications using FPGA and its interface board have finished.\r\n", "- Detail Design Document has finished.\r\n        ", "\n            - Verilog RTL codes for CPU, and Test Bench including modules comprising MCU, such as UART, System Controller, Parallel I/O Interface, and Internal Memories (ROM/RAM). \r\n", "- Verification Resources, such as Converter from S-format to Verilog format for ROM coding, and Assemble Source Programs for Vector Simulation. \r\n", "- FPGA Resources, such as Circuit Schematics of Interface Board, Converter from S-format to Xilinx BlockRAM INIT statements for RAM initialization, and a sample of User Constraints File. \r\n", "- Small Applications written in C Sources including LCD Test Program, Clock using interval interrupt, Debugging Monitor, and Calculation of Circular Constant (Pi). \n        ", "\n            FILE: rtl.gif\n", "DESCRIPTION: Tree of RTL\n", "\n        ", "\n            Documents, RTL Source codes and related Tools can be downloaded from the OpenCores CVS; the directory is \"Aquarius\".\n        ", "\n            Aquarius CPU core and related peripheral modules have been configured in both Xilinx and Altera. Following table shows their performance.\r\n", "\r\n", "\r\n    ", "\r\n    ", "\n            Aquarius has adpoted as a showcase of Soc Emulator developped by Edaptability ! \r\n", "\r\n", "\r\n\r\nRenesas Technology Corp.\r\n", "\r\n\r\nSuperH Family", "\r\n\r\nHuMANDATA Ltd.\r\n", "\r\n\r\nSchematic of FPGA Board", "\r\n\r\nSUNLIKE Displays Tech Corp.\r\n", "\r\n\r\nLCD SC-1602B Datasheet", "\r\n\r\nLCD Timing", "\r\n\r\nLCD Display Commands", "\r\n\r\nLCD Initialization", "\r\n\r\nAnalog Devices Inc.\r\n", "\r\n\r\nRS-232C PHY", "\n        ", "\n            FILE: fpgaboard.gif\n", "DESCRIPTION: FPGA Board\n", "\n        "]},
{"details": ["\n    Name: 68hc08", "\n    Created: Feb  1, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Jul 16, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            A MC68HC08 clone in VHDL as single file. Twice performance as the original. Multiplication is done in one clock cycle. Division in two clock cycles.\r\n", "\n        ", "\n            - feature1\n", "  - feature1.1\n", "  -feature1.2\n", "-feature2\n        ", "\n            tested with C compiler works OK with interrupts\r\n", "2009.07.16  new version, bugfix at opcode 7E  mov ,X+,opr8a  X post increment fixed\n        "]},
{"details": ["\n    Name: 68hc05", "\n    Created: Feb  1, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            A MC68HC05 clone in VHDL as single file. Twice performance as the original. Multiplication is done in one clock cycle.\n        ", "\n            \n        ", "\n            tested with C compiler works OK\n        "]},
{"details": ["\n    Name: 1664", "\n    Created: Mar 25, 2010", "\n    Updated: Mar 26, 2010", "\n        SVN Updated: Mar 26, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            ", "\r\n16,32,64 bit microprocessor - simulator source configurable.", "\r\n16 bit fixed instruction length. All instructions conditional.", "\r\nup-to 128 instructions. 64 registers.", "\r\nRun-time instruction configuration / code obfuscation.", "\r\nSimulator software includes macro assembler, console debugger and interpreter using host system calls.", "\r\n", "Public domain."]},
{"details": ["\n    Name: wb_to_amba", "\n    Created: Feb  2, 2010", "\n    Updated: Aug 30, 2010", "\n        SVN Updated: Mar 29, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A AHB master to WishBone slave bridge along with a basic testbench is included. Burst in not yet supported. \n        "]},
{"details": ["\n    Name: zedboardoled", "\n    Created: Aug 22, 2014", "\n    Updated: Aug 23, 2014", "\n        SVN: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            The ZedboardOLED IP core provides a user friendly interface to the 128x32 organic LED display available on the Zedboard development board, a driver is supplied with the package, enabling a standalone usage for the display. The design can be easily modified to target other embedded platforms, provided with the package, a step-by-step quick start guide for using the IP.\r\n", " \r\n", "Features\r\n", "1 Plug and play using Vivado design suite.\r\n", "2 Hierarchical open-source design, it can be easily altered to fit other systems\u2019 requirements.\r\n", "3 Internal display buffer.\r\n", "4 English characters bit maps are cached inside the controller.\r\n", "5 Implemented driver for alphanumeric display .\r\n", " \r\n", "This work was done as part of teaching materials for the ECEN 449 class offered at Texas A&M University/Qatar.\r\n", "Written by Ali Aljaani/Texas A&M University at Qatar.\r\n", "\n        "]},
{"details": ["\n    Name: c16", "\n    Created: Sep 29, 2003", "\n    Updated: Jun 20, 2015", "\n        SVN Updated: Aug  5, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            800 Xilinx slices for CPU\r\n", "1000 Xililinx slices for complete SoC\r\n", "Optimized for exeution of C programs\r\n", "VHDL, Assembler, C Compiler, Simulator\r\n", "6 kByte RTOS\r\n        ", "\n            Done. ", "\r\nTo browse the SVN sources, or to fetch a tarball of the sources, click one of links above under ", "\n        ", "\n            ", "\n        "]},
{"details": ["\n    Name: blue", "\n    Created: Nov 22, 2009", "\n    Updated: Feb  6, 2010", "\n        SVN Updated: Dec  3, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A 16-bit classical CPU based loosely on Caxton Foster's Blue CPU from the book \"Computer Architecture\". Includes a cross assembler and a very novel front panel for the Digilent Spartan 3 board. \n        ", "\n            The project has a wiki at ", ".\r\n\r\n\n        ", "\n            \n        "]},
{"details": ["\n    Name: xmatchpro", "\n    Created: Mar  4, 2006", "\n    Updated: Dec 15, 2016", "\n        SVN Updated: Jan  6, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            If you have problems downloading the latest version can also be obtained from:\r\n", "\r\n", "\r\n", "The use of lossless data compression can bring about a number of increasingly important benefits to an electronic system. The term \u2018lossless\u2019 means that the original data can be exactly recreated after a decompression operation, and should not be confused with audio and video compression systems (such as JPEG and MPEG) which are lossy and hence only recreate an approximation of the original data. \r\n", "The most obvious benefit of data compression is a reduction in the volume of data which must be stored. This is important where the storage media itself is costly (such as memory) or other parameters, such as power consumption, weight or physical volume, are critical to product feasibility. Using data compression \r\n", "reduces the total storage requirement, thus effecting a cost saving. \r\n", "\r\n", "There are also two other positive effects that data compression brings. The first of these is a reduction in the bandwidth required to transmit a given amount of data \u2013less data must be transmitted when in compressed form, and hence less bandwidth is required. This can effect a cost saving in cabling operations, where a lower bandwidth link will be sufficient to meet demand. The second effect is that given a fixed bandwidth, the total time required to transmit compressed data is less than for uncompressed data. This can lead to a performance benefit, as the bandwidth of a link appears greater when transmitting compressed data and hence more data can be transmitted in a given amount of time. \n        ", "\n            The X-MatchPROvw compressor/decompressor processor is a fully contained unit having a simple architecture and uncomplicated interface.\r\n", "\r\n", "The X-MatchPROvw design is a dictionary style compressor based around a dictionary implemented in the form of a content addressable memory (CAM). The length of the physical CAM varies with values ranging from 16 to 1024 tuples (4-byte locations) trading complexity for compression. Typically, the device complexity increases by a factor of 1.5 each time the dictionary doubles. The physical dictionary size is, then, variable to be able to adapt algorithm complexity to the resources available in the selected FPGA. The logical length of the dictionary always starts at zero (empty) and grows as new data needs to be accomodated. The logical width of the dictionary also adapts to the data input ranging from 2-bytes up to 4-bytes to improve compression. \r\n", "\r\n", "The dictionary adaptively stores the most recent phrases that have occurred in the data stream. Compression is achieved by replacing repeated phrases with references to the dictionary (these are codewords witch are sorter than the phrase itself). A number ot techniques such as partial matching and internal run length coding are used to improve compression.\r\n", "\r\n", "The coding section is active during compression. This generates the required codewords and forms successive codewords into fixed 32-bit width words for writing to external medium. The decoding section is responsible for the reverse process \u2013data is read from the external medium and generates the required dictionary references to allow the decompressed data to be recreated. The process is fully lossless and the compression process is automatically verified using CRC codes.  \n        ", "\n            Features\r\n", "\u2022 New version targets Xilinx V4/V5 devices at 100 MHz and 140 MHz respectevely. Throughput of 400 Mbytes/second and 560   Mbytes/second in these devices.\r\n", "\u2022 High-speed lossless data compressor supports compression and decompression in a single FPGA. \r\n", "\u2022 Altera APEX20KE prototype implementation available on PCI board. \r\n", "\u2022 Throughput up to 200 Mbytes/second compression/decompression with low latency clocking at 50 MHz on a APEX FPGA. Higher on Stratix or Virtex-4 devices.\r\n", "\u2022 Full-duplex operation enables simultaneous compression/decompression for a combined performance of 400 Mbytes/s. \r\n", "\u2022 Full-duplex architecture enables self-checking test mode using CRC (Cyclic Redundancy Check) codes. \r\n", "\u2022 32-bit high-performance coprocessor-style interface. \r\n", "\u2022 Fully contained 32-bit architecture does not require any external components and supports operation on blocked data. \r\n", "\u2022 Easy migration to ASIC technology enables 3-5 times increase in performance. \r\n", "\u2022 Compression ratio comparable to HiFn LZS and IBM ALDC using comparable dictionary sizes. \r\n", "\r\n", "Applications \r\n", "\u2022 Computer systems. \r\n", "\u2022 Networking products. \r\n", "\u2022 High performance storage devices. \r\n", "\u2022 Data logging equipment. \r\n", "\u2022 Remote sensing applications. \r\n", "\r\n", "To learn more contact us at j.l.nunez-yanez@bris.ac.uk.\r\n", "\r\n", "The opencores version is generic and can target different FPGA and ASIC technologies. If you are having problems downloading the latest version can also be obtained from \r\n", "\n        "]},
{"details": ["\n    Name: wb2hpi", "\n    Created: Dec  2, 2002", "\n    Updated: Feb 20, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            WB Interface for TI 5x DSP (HPI) developed for use with Opencores PCI Bridge.\n        ", "\n            1. Direct access to DSP Control Registers\r\n", "2. Block transfer from DSP address space to WB address space \r\n", "3. Block transfer from WB address space to DSP address space\r\n", "4. Interrupt support (both are maskable)\r\n", "- interrupt after block transfer; and \r\n", "- interrupt from DSP.\r\n", "5. Maped DSP address space to WB address space.\r\n        ", "\n            - Core is finished, testing some parts at the moment\r\n", "- Writing documentation\r\n", "- Test bench for PCI card, with hex editor for DSP memory, was written (Win Platform).  It will be available with core. \r\n", "- Screenshots of software are available. Adopting (Win) driver to be flexible as much as possible at the moment.\r\n", "- Source uploaded\r\n", "- Works (real hw) with new Opencores PCI core.\r\n", "- Updated to work with new Opencores PCI files (again)\n        "]},
{"details": ["\n    Name: timerocd", "\n    Created: Jun 16, 2015", "\n    Updated: Jun 17, 2015", "\n        SVN Updated: Jun 17, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n            ", "TimerOCD (Timer Output Compare Drivers) - Targeting the Spartan-6 XC6SLX9-2C (", "), this project interfaces the FPGA to a microprocessor via SPI and provides an array of 512 high-speed (up to 1.5625MHz timer clock speed) 16-bit Timer Output Compares to drive appropriate output signals.", "The original project was developed to work with a Dual-Resonance Solid-State Tesla Coil (DRSSTC) as a MIDI Interrupter.  It provides generation of up to 256 simultaneous notes per left/right channel (512 total) and makes use of the Block RAM and DSP slices for doing Note Frequency/Power lookup and interpolation.", "As configured, it is designed to run with a 100 MHz input clock and by making use of the Dual-Port memory structure and interlacing memory read/write operations and updating 4 timers at once (odd/even pairs and left/right pairs), it can achieve a timer frequency scaling of 1:64 or a timer clock of 1.5625 MHz -- updating all 512 timers within a single timer clock tick (800 million memory reads and 800 million memory writes per second).  Impressive considering the \"throughput\" of this FPGA is around 71MHz.", "Originally, I implemented the timer compares on little ATmega328 micros, which could only do 6 per processor with a 250kHz timer clock.  After progressing in development, my project ultimately needed an absolute minimum of 32 to 64 per left/right channel.  While I could parallel those processors (which worked fairly well when I prototyped it with four of them), it was more expensive and higher power consumption than a single chip solution.", "I couldn't find any off-the-shelf timer compare chips that were high frequency.  There are chips that can do around 64 or 128 PWM and/or output compares, but they were limited to around 2kHz and are designed for LED drivers.  I needed a minimum of 250kHz (or the more appropriate 1.5625MHz clock) to get full utilization of the 16-bit timers for the music note frequency range of the MIDI band.", "So I developed this FPGA code (in VHDL) to handle all of the timer compares and drive dual fiber optic transmitter outputs for my Tesla Coils -- two identical half-bridge zero-current-switching dual-resonance solid-state coils.", "I'm sharing this project here because it's also useful for all sorts of Timer/PWM applications, not just a MIDI interrupter.  The outputs can be easily remapped to utilize any of the output pins on the FPGA, rather than the dual 256-input 'OR' gate that's used for the interrupter.  In addition to the 8 LEDs and 4 switches on the aforementioned FPGA Development board (which are controllable via SPI in this code), this design only needs the 4 SPI pins and 1 Reset pin (which is technically optional since it can be reset via SPI command).  The rest of the pins are free to be outputs, of which I'm presently using 2 (left and right outputs).", "The SPI commands to the FPGA can be addressed either in Note/Power (Key/Velocity) mode which utilizes the lookup tables for interpolation and Timer On/Off value calculations or it can be addressed directly with the Timer On/Off values to use.", "It's been prototyped and tested and is working flawlessly, at least with a SPI clock of up to 5.25 MHz, which is what I'm using on the STM32F405 processor that I have driving this FPGA.", "While I haven't done a full/extensive set of tests of every mode and I/O combination (for example, it should work with all SPI Clock Polarity/Phase configurations but has only been tested with CPOL=0, CPHA=0), the design is considered complete and stable and will be fully integrated with my MIDI interrupter once I've finished the code for the STM32F405 and do a PCB board turn to bring it all together into a final device.", "The code was developed on a Linux workstation using the Qt Creator IDE.  A .config file for Qt Creator is provided.  I have also included the Makefile to compile and simulate in ghdl/gtkwave.  The overall project was synthesized and IP Core Blocks generated by the Xilinx ISE Webpack 14.7.  I have also included the lookup tables for music note generation for the DRSSTC MIDI Interrupter as .coe files, but these can be easily swapped out for any lookup table desired and/or the timers can be run in direct On-Time/Off-Time mode.", "Please let me know if I overlooked any necessary files by mail to dwhisnant at dewtronics dot com.", "\n            ", "\r\nThe\u00a0SPI\u00a0Interface\u00a0functions\u00a0as\u00a0a\u00a0slave\u00a0device\u00a0with\u00a0the\u00a0following\u00a0stream:", "\r\nMaster\u00a0must\u00a0send\u00a0MSbit\u00a0First:", "\r\n", "\r\nInput\u00a0(9\u00a0bytes\u00a0per\u00a0data\u00a0message\u00a0transfer\u00a0or\u00a01\u00a0byte\u00a0per\u00a0command\u00a0message\u00a0transfer):", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a08-bit\u00a0Command/Address\u00a0Byte:", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C7..C0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C7..C0\u00a0:\u00a0Timer\u00a0Address\u00a0for\u00a0Read\u00a0and\u00a0Write\u00a0operations", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0C7\u00a0C6\u00a0C5\u00a0C4\u00a0C3\u00a0C2\u00a0C1\u00a0C0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+-----\u00a0Timer\u00a0Address\u00a00-63\u00a00x00-0x3F\u00a0(000000-111111)\u00a0(For\u00a0Data\u00a0Mode)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Commands\u00a0(for\u00a0Command\u00a0Mode):", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000000\u00a0=\u00a0Reset\u00a0(performs\u00a0power-on\u00a0reset\u00a0equivalent)\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000001\u00a0=\u00a0RESERVED", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000010\u00a0=\u00a0Switch\u00a0to\u00a0Note/Power/PitchBend\u00a0Run\u00a0mode\u00a0(initial\u00a0default)\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000011\u00a0=\u00a0Switch\u00a0to\u00a0Timer\u00a0On/Off\u00a0Compare\u00a0Value\u00a0Run\u00a0mode\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000100\u00a0=\u00a0Bank\u00a0Select\u00a00\u00a0(Notes\u00a00-63)\u00a0for\u00a0future\u00a0transfers\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000101\u00a0=\u00a0Bank\u00a0Select\u00a01\u00a0(Notes\u00a064-127)\u00a0for\u00a0future\u00a0transfers\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000110\u00a0=\u00a0Bank\u00a0Select\u00a02\u00a0(Notes\u00a0128-191)\u00a0for\u00a0future\u00a0transfers\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0000111\u00a0=\u00a0Bank\u00a0Select\u00a03\u00a0(Notes\u00a0192-255)\u00a0for\u00a0future\u00a0transfers\u00a0on\u00a0Write\u00a0(Read\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0001xxx\u00a0=\u00a0TBD/RESERVED", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Note:\u00a0on\u00a000xxxx\u00a0Commands\u00a0(above)\u00a0and\u00a0with\u00a0Timer\u00a0Address\u00a0in\u00a0the\u00a0Data\u00a0Mode\u00a0the\u00a0Concurrent", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Read\u00a0Nybble\u00a0with\u00a0the\u00a0command\u00a0send\u00a0will\u00a0be\u00a0as\u00a0follows:", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0m\u00a0b\u00a0b", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0-\u00a0-\u00a0-\u00a0-", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|\u00a0|\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|\u00a0+-+--\u00a0Currently\u00a0Selected\u00a0Bank", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a000\u00a0=\u00a0Bank\u00a00", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a001\u00a0=\u00a0Bank\u00a01", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010\u00a0=\u00a0Bank\u00a02", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011\u00a0=\u00a0Bank\u00a03", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0+------\u00a0RunMode\u00a0:\u00a00\u00a0=\u00a0Note/Power/PitchBend,\u00a01\u00a0=\u00a0Timer\u00a0On/Off\u00a0Compare\u00a0Values", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+--------\u00a0Reserved\u00a0for\u00a0001xxx\u00a0command,\u00a0TBD,\u00a0will\u00a0be\u00a0sent\u00a0as\u00a00", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a001xxxx\u00a0=\u00a0Read\u00a0Push\u00a0Button\u00a0Switch\u00a00-3\u00a0Status\u00a0(Read\u00a0Nybble\u00a0is\u00a0concurrent\u00a0with\u00a0sending\u00a0command\u00a0byte,\u00a0Write\u00a0has\u00a0no\u00a0effect)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010xxxx\u00a0=\u00a0Read/Set\u00a0LEDs\u00a00-3\u00a0(Read\u00a0Nybble\u00a0is\u00a0concurrent\u00a0with\u00a0sending\u00a0command\u00a0byte)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011xxxx\u00a0=\u00a0Read/Set\u00a0LEDs\u00a04-7\u00a0(Read\u00a0Nybble\u00a0is\u00a0concurrent\u00a0with\u00a0sending\u00a0command\u00a0byte)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0+-----------------------\u00a0Command/Data\u00a0Select\u00a0(0=Data,\u00a01=Command)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+--------------------------\u00a0R/W\u00a0Mode\u00a0Select", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0=\u00a0Write\u00a0new\u00a0value\u00a0to\u00a0TimerOCD\u00a0and\u00a0concurrently\u00a0Read\u00a0present\u00a0value\u00a0from\u00a0TimerOCD", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0=\u00a0Read\u00a0present\u00a0value\u00a0from\u00a0TimerOCD\u00a0(Data\u00a0received\u00a0during\u00a0read\u00a0operation\u00a0is\u00a0ignored)", "\r\n", "\r\nNote/Power/PitchBend\u00a0Run\u00a0Mode", "\r\n-----------------------------", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a07-Bit\u00a0Note/Key\u00a0and\u00a07-Bit\u00a0Power/Velocity\u00a0for\u00a0Left\u00a0Channel:\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00,N6..N0,0,P6..P0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0N6\u00a0N5\u00a0N4\u00a0N3\u00a0N2\u00a0N1\u00a0N0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+--+--\u00a0Note/Key\u00a00-127\u00a00x00-0x7F\u00a0(0000000-1111111)\u00a0-\u00a0Left\u00a0Channel", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+-----------------------\u00a0Unused", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0P6\u00a0P5\u00a0P4\u00a0P3\u00a0P2\u00a0P1\u00a0P0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+--+--\u00a0Power/Velocity\u00a00-127\u00a00x00-0x7F\u00a0(0000000-1111111)\u00a0-\u00a0Left\u00a0Channel", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+-----------------------\u00a0Unused", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a014-Bit\u00a0Pitch\u00a0Bend\u00a0for\u00a0Left\u00a0Channel:\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00,0,B13..B0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a00\u00a0\u00a0B13\u00a0B12\u00a0B11\u00a0B10\u00a0B9\u00a0B8\u00a0B7\u00a0B6\u00a0B5\u00a0B4\u00a0B3\u00a0B2\u00a0B1\u00a0B0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0+---+---+---+---+--+--+--+--+--+--+--+--+--+--\u00a0Pitch\u00a0Bend\u00a00000/2000(NoBend)/3FFF\u00a0-\u00a0Left\u00a0Channel", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+--+------------------------------------------------\u00a0Unused", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a07-Bit\u00a0Note/Key\u00a0and\u00a07-Bit\u00a0Power/Velocity\u00a0for\u00a0Right\u00a0Channel:\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00,N6..N0,0,P6..P0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0N6\u00a0N5\u00a0N4\u00a0N3\u00a0N2\u00a0N1\u00a0N0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+--+--\u00a0Note/Key\u00a00-127\u00a00x00-0x7F\u00a0(0000000-1111111)\u00a0-\u00a0Right\u00a0Channel", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+-----------------------\u00a0Unused", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0P6\u00a0P5\u00a0P4\u00a0P3\u00a0P2\u00a0P1\u00a0P0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+--+--\u00a0Power/Velocity\u00a00-127\u00a00x00-0x7F\u00a0(0000000-1111111)\u00a0-\u00a0Right\u00a0Channel", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+-----------------------\u00a0Unused", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a014-Bit\u00a0Pitch\u00a0Bend\u00a0for\u00a0Right\u00a0Channel:\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00,0,B13..B0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a00\u00a0\u00a0B13\u00a0B12\u00a0B11\u00a0B10\u00a0B9\u00a0B8\u00a0B7\u00a0B6\u00a0B5\u00a0B4\u00a0B3\u00a0B2\u00a0B1\u00a0B0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0+---+---+---+---+--+--+--+--+--+--+--+--+--+--\u00a0Pitch\u00a0Bend\u00a00000/2000(NoBend)/3FFF\u00a0-\u00a0Right\u00a0Channel", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+--+------------------------------------------------\u00a0Unused", "\r\n", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0**\u00a0A\u00a0Note\u00a0Value\u00a0of\u00a00\u00a0or\u00a0Power\u00a0Level\u00a0of\u00a00\u00a0is\u00a0considered\u00a0\"OFF\"\u00a0and\u00a0will\u00a0disable\u00a0the\u00a0timer\u00a0compare\u00a0channel", "\r\n", "\r\n", "\r\nTimer\u00a0On/Off\u00a0Value\u00a0Run\u00a0Mode", "\r\n---------------------------", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a0Timer\u00a0ON\u00a0Value\u00a0for\u00a0Left\u00a0Channel:\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15..T0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15\u00a0T14\u00a0T13\u00a0T12\u00a0T11\u00a0T10\u00a0T9\u00a0T8\u00a0T7\u00a0T6\u00a0T5\u00a0T4\u00a0T3\u00a0T2\u00a0T1\u00a0T0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+---+---+---+---+---+---+--+--+--+--+--+--+--+--+--+--\u00a0\u00a0\u00a0\u00a0Timer\u00a0ON\u00a0Value\u00a00x0000\u00a0-\u00a00xFFFF\u00a0-\u00a0Left\u00a0Channel", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a0Timer\u00a0OFF\u00a0Value\u00a0for\u00a0Left\u00a0Channel:\u00a0\u00a0\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15..T0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15\u00a0T14\u00a0T13\u00a0T12\u00a0T11\u00a0T10\u00a0T9\u00a0T8\u00a0T7\u00a0T6\u00a0T5\u00a0T4\u00a0T3\u00a0T2\u00a0T1\u00a0T0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+---+---+---+---+---+---+--+--+--+--+--+--+--+--+--+--\u00a0\u00a0\u00a0\u00a0Timer\u00a0OFF\u00a0Value\u00a00x0000\u00a0-\u00a00xFFFF\u00a0-\u00a0Left\u00a0Channel", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a0Timer\u00a0ON\u00a0Value\u00a0for\u00a0Right\u00a0Channel:\u00a0\u00a0\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15..T0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15\u00a0T14\u00a0T13\u00a0T12\u00a0T11\u00a0T10\u00a0T9\u00a0T8\u00a0T7\u00a0T6\u00a0T5\u00a0T4\u00a0T3\u00a0T2\u00a0T1\u00a0T0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+---+---+---+---+---+---+--+--+--+--+--+--+--+--+--+--\u00a0\u00a0\u00a0\u00a0Timer\u00a0ON\u00a0Value\u00a00x0000\u00a0-\u00a00xFFFF\u00a0-\u00a0Right\u00a0Channel", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0*\u00a016-Bit\u00a0:\u00a0Timer\u00a0OFF\u00a0Value\u00a0for\u00a0Right\u00a0Channel:\u00a0\u00a0\u00a0\u00a0(Data\u00a0Mode\u00a0Only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15..T0\u00a0:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0T15\u00a0T14\u00a0T13\u00a0T12\u00a0T11\u00a0T10\u00a0T9\u00a0T8\u00a0T7\u00a0T6\u00a0T5\u00a0T4\u00a0T3\u00a0T2\u00a0T1\u00a0T0", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0+---+---+---+---+---+---+--+--+--+--+--+--+--+--+--+--\u00a0\u00a0\u00a0\u00a0Timer\u00a0OFF\u00a0Value\u00a00x0000\u00a0-\u00a00xFFFF\u00a0-\u00a0Right\u00a0Channel", "\r\n", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0**\u00a0Writing\u00a0either\u00a0Timer\u00a0On\u00a0or\u00a0Timer\u00a0Off\u00a0to\u00a00\u00a0is\u00a0considered\u00a0\"OFF\"\u00a0and\u00a0will\u00a0disable\u00a0the\u00a0timer\u00a0compare\u00a0channel", "\r\n", "\r\n", "\r\n-----------------------------------------------------------------------------------------", "\r\n", "\r\ntmrMemBlkLeftXX/tmrMemBlkRightXX\u00a0Memory\u00a0Mapping:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Each\u00a0Configured\u00a0as\u00a0256\u00a0x\u00a016-bit\u00a0True\u00a0Dual-Port\u00a0RAM\u00a0Memory", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Port\u00a0A\u00a0=\u00a0All\u00a0Read/Write\u00a0processing\u00a0(xferdataproc\u00a0only)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Port\u00a0B\u00a0=\u00a0All\u00a0Read-Only\u00a0processing\u00a0(tmrupdproc\u00a0only)", "\r\n\u00a0\u00a0\u00a0\u00a0(Address\u00a0is\u00a08-bits)", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0A7\u00a0A6\u00a0A5\u00a0A4\u00a0A3\u00a0A2\u00a0A1\u00a0A0", "\r\n\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+------------\u00a0\u00a0\u00a0\u00a0Subtimer\u00a0Index\u00a0(0-63)\u00a00x00-0x3F", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0+--+--+---------------------------\u00a0\u00a0\u00a0\u00a0Entry\u00a0Selection:", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a000\u00a0=\u00a0Note\u00a0and\u00a0Power\u00a0Data\u00a0(as\u00a0sent/received\u00a0to/from\u00a0SPI)\u00a0(Read/Written\u00a0on\u00a0SPI\u00a0side)\u00a0(Note\u00a0in\u00a0MSB,\u00a0Power\u00a0in\u00a0LSB)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a001\u00a0=\u00a0Pitch\u00a0Bend\u00a0Value\u00a0(as\u00a0sent/received\u00a0to/from\u00a0SPI)\u00a0(Read/Written\u00a0on\u00a0SPI\u00a0side)\u00a0(right-justified)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a010\u00a0=\u00a0Timer\u00a0ON\u00a0Compare\u00a0Value\u00a0(Calculated\u00a0during\u00a0SPI\u00a0receive\u00a0and\u00a0written\u00a0then,\u00a0Read\u00a0on\u00a0signal\u00a0generation\u00a0timer\u00a0processing)", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a011\u00a0=\u00a0Timer\u00a0OFF\u00a0Compare\u00a0Value\u00a0(Calculated\u00a0during\u00a0SPI\u00a0receive\u00a0and\u00a0written\u00a0then,\u00a0Read\u00a0on\u00a0signal\u00a0generation\u00a0timer\u00a0processing)", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Block\u00a0Mapping:", "\r\n\u00a0\u00a0\u00a0\u00a0--------------", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrMemBlkLeft00/tmrMemBlkRight00\u00a0-\u00a0Holds\u00a0notes\u00a00-63", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrMemBlkLeft01/tmrMemBlkRight01\u00a0-\u00a0Holds\u00a0notes\u00a064-127", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrMemBlkLeft02/tmrMemBlkRight02\u00a0-\u00a0Holds\u00a0notes\u00a0128-191", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrMemBlkLeft03/tmrMemBlkRight03\u00a0-\u00a0Holds\u00a0notes\u00a0192-255", "\r\n", "\r\n", "\r\ntmrCTMemBlkLeftXX/tmrCTMemBlkRightXX\u00a0Memory\u00a0Mapping:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Each\u00a0Configured\u00a0as\u00a064\u00a0x\u00a016-bit\u00a0Simple\u00a0Dual-Port\u00a0RAM\u00a0Memory", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0Port\u00a0A\u00a0=\u00a0All\u00a0Read/Write\u00a0processing\u00a0(used\u00a0exclusively\u00a0by\u00a0tmrupdproc)", "\r\n\u00a0\u00a0\u00a0\u00a0(Address\u00a0is\u00a06-bits)", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0A5\u00a0A4\u00a0A3\u00a0A2\u00a0A1\u00a0A0", "\r\n\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0+--+--+--+--+--+-------\u00a0\u00a0\u00a0\u00a0Subtimer\u00a0Index\u00a0(0-63)\u00a00x00-0x3F", "\r\n", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrCTMemBlkLeft00/tmrCTMemBlkRight00\u00a0-\u00a0Holds\u00a0notes\u00a00-63", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrCTMemBlkLeft01/tmrCTMemBlkRight01\u00a0-\u00a0Holds\u00a0notes\u00a064-127", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrCTMemBlkLeft02/tmrCTMemBlkRight02\u00a0-\u00a0Holds\u00a0notes\u00a0128-191", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tmrCTMemBlkLeft03/tmrCTMemBlkRight03\u00a0-\u00a0Holds\u00a0notes\u00a0192-255", "\r\n", "\r\n-----------------------------------------------------------------------------------------", "\r\n", "\r\ncmpFreqMemBlk\u00a0Memory\u00a0Mapping:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Timer\u00a0Output\u00a0Compare\u00a0FREQ\u00a0Values", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(OFF\u00a0Values)\u00a0=\u00a0(FREQ\u00a0Value)\u00a0-\u00a0(ON\u00a0Value)", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Configured\u00a0as\u00a0128\u00a0x\u00a016-bit\u00a0Dual\u00a0Port\u00a0ROM\u00a0Memory", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(Address\u00a0is\u00a07-bits)", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0A6\u00a0A5\u00a0A4\u00a0A3\u00a0A2\u00a0A1\u00a0A0", "\r\n\u00a0\u00a0\u00a0\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0+--+--+--+--+--+--+------\u00a0\u00a0\u00a0\u00a0Note\u00a0Value\u00a00-127\u00a0(0\u00a0is\u00a0reserved\u00a0for\u00a0output\u00a0disabled\u00a0compare\u00a0value\u00a0of\u00a00)", "\r\n", "\r\n", "\r\n-----------------------------------------------------------------------------------------", "\r\n", "\r\ncmpOnMemBlk\u00a0Memory\u00a0Mapping:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Timer\u00a0Output\u00a0Compare\u00a0ON\u00a0Values", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Configured\u00a0as\u00a016384\u00a0x\u00a016-bit\u00a0Dual\u00a0Port\u00a0ROM\u00a0Memory", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0(Address\u00a0is\u00a014-bits)", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0A13\u00a0A12\u00a0A11\u00a0A10\u00a0A9\u00a0A8\u00a0A7\u00a0A6\u00a0A5\u00a0A4\u00a0A3\u00a0A2\u00a0A1\u00a0A0", "\r\n\u00a0\u00a0\u00a0\u00a0---\u00a0---\u00a0---\u00a0---\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--\u00a0--", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0+--+--+--+--+--+--+------\u00a0\u00a0\u00a0\u00a0Note\u00a0Value\u00a00-127\u00a0(0\u00a0is\u00a0reserved\u00a0for\u00a0output\u00a0disabled\u00a0compare\u00a0value\u00a0of\u00a00)", "\r\n\u00a0\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0\u00a0|\u00a0\u00a0|\u00a0\u00a0|", "\r\n\u00a0\u00a0\u00a0\u00a0+---+---+---+---+--+--+---------------------------\u00a0\u00a0\u00a0\u00a0Power\u00a0Value\u00a00-127\u00a0(0\u00a0is\u00a0reserved\u00a0for\u00a0output\u00a0disabled\u00a0compare\u00a0value\u00a0of\u00a00)", "\r\n", "\r\n-----------------------------------------------------------------------------------------", "\r\n", "\r\nFor\u00a0PitchBend\u00a0calculations,\u00a0the\u00a0top-two\u00a0bits\u00a0(bit\u00a0B13\u00a0and\u00a0B12)\u00a0of\u00a0the\u00a0PitchBend\u00a0determine\u00a0which\u00a0note", "\r\n\u00a0\u00a0\u00a0\u00a0compare\u00a0stores\u00a0are\u00a0used\u00a0in\u00a0the\u00a0PitchBend\u00a0calculation\u00a0as\u00a0follows:", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0B13\u00a0B12", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0---\u00a0---", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0Use\u00a0Note-2\u00a0and\u00a0Note-1", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a00\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0Use\u00a0Note-1\u00a0and\u00a0Note", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a00\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0Use\u00a0Note\u00a0and\u00a0Note+1", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a01\u00a0\u00a0\u00a01\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0--\u00a0Use\u00a0Note+1\u00a0and\u00a0Note+2", "\r\n", "\r\n\u00a0\u00a0\u00a0\u00a0Notes\u00a0in\u00a0the\u00a0extremes\u00a0of\u00a0the\u00a0Note\u00a0values\u00a0(i.e.\u00a0outside\u00a0of\u00a0the\u00a0meaningful", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a088\u00a0note\u00a0piano\u00a0range\u00a0where\u00a0our\u00a0compares\u00a0wrap\u00a0anyway)\u00a0are\u00a0excluded\u00a0from", "\r\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0the\u00a0pitch\u00a0bend\u00a0calculations", "\r\n", "\r\n", "\r\n-----------------------------------------------------------------------------------------", "\r\n"]},
{"details": ["\n    Name: simple_pic", "\n    Created: Dec  2, 2002", "\n    Updated: Mar  4, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 0 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Simple programmable interrupt controller. It supports up to 8 interrupt sources. Polarity and sensitivity (either edge or level) is programmable per interrupt source. The core features an 8bit wishbone interface. Wider wishbone interfaces are easily supported by using multiple instances.\r\n", "Very simple, very small.\n        ", "\n            - Up to 8 interrupt sources\r\n", "- Sensitivity (edge/level) programmable per interrupt source\r\n", "- Polarity programmable per source\r\n", "- Static synchronous design\r\n", "- Fully synthesisable\r\n", "- 48 LUTs in a Spartan-II, 83 LCELLs in an ACEX\n        ", "\n            Design is finished and available in Verilog from OpenCores CVS.\r\n        "]},
{"details": ["\n    Name: simple_gpio", "\n    Created: Dec  2, 2002", "\n    Updated: Sep  7, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Simple General Purpose IO port. It supports up to 8 GPIO pins. Each pin is individually programmable as either input or output. The core features an 8bit wishbone interface. Wider wishbone interfaces are easily supported by using multiple instances (e.g. 4 simple GPIO cores provide a 32bit wishbone interface).\r\n", "Very simple, very small.\n        ", "\n            - Up to 8 GPIO pins per core\r\n", "- Each GPIO pin individually programmable as either input or output\r\n", "- Static synchronous design\r\n", "- Fully synthesisable\r\n", "- 11 LUTs in a Spartan-II, 43 LCELLs in an ACEX\n        ", "\n            Design is finished and available in Verilog from OpenCores CVS.\n        "]},
{"details": ["\n    Name: statled", "\n    Created: Sep  8, 2010", "\n    Updated: Sep 14, 2010", "\n        SVN Updated: Sep  9, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A simple module to get the most of your on board heartbeat LED. Change or add more sequences easily in parameters file.   \n        "]},
{"details": ["\n    Name: systemc_rng", "\n    Created: Aug 19, 2004", "\n    Updated: Apr  9, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A SystemC/Verilog random number generator based on the combination of a LFSR and a CASR with very good statisticall properties.\r\n", "Based on the Thomas E. Tkacik work available at:\r\n", "\r\n", "\r\n", "\r\n", "This work is given by Universidad Rey Juan Carlos (Spain)\r\n", "www.gdhwsw.urjc.es\n        ", "\n            - Very good statisticall properties\r\n", "- Synthesizable\n        ", "\n            - Done\n        "]},
{"details": ["\n    Name: dbg_interface", "\n    Created: Sep 25, 2001", "\n    Updated: Aug  5, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Debug Interface is used for development purposes (debugging). It is an interface between the CPU(s), peripheral cores and any commercial debugger/emulator. The external debugger or BS tester connects to the core via JTAG port that is fully IEEE 1149.1 compatible. For that reason ", " needs to be used together with this core.\n        ", "\n            - New version tested with a test bench and in real HW. (April 8, 2004)\r\n", "- Old debug (development) was separated into two different projects. Debug interface is rewritten, documentation updated. Use rel_22 tag for downloading. [January 27, 2004]\r\n", "- All files were updated [February 4, 2002] \r\n", "- Development Interface was thoroughly tested (functional simulation and in real hardware).\r\n", "- GDB debugger was connected to the Development Interface.\r\n", "- Boundary Scan is supported. BS chain of the chip where Debug Interface is used, must be defined prior to its use. \r\n", "- Specification is finished: DbgSupp.pdf (about 200 KB) (see Downloads).\r\n", "- Datasheet is ready: Debug Support Datasheet (prl.).pdf (see Downloads).\n        ", "\n            - 08/04/2004 IM New version. Use rel_25 tag for  downloading. Documentation updated.\r\n", "- 17/01/2004 IM New version. Use rel_22 tag for downloading. Documentation updated.\r\n", "- 12/02/2002 IM Datasheet written.\r\n", "- 04/02/2002 IM Documentation and code updated (small fixes to make the core smaller, faster and of course more stable). \r\n", "- 04/12/2001 IM Documentation and code updated (small fixes, wishbone master interface added) \r\n", "- 20/9/2001 IM Documentation and code updated (final release) \r\n", "- 13/9/2001 IM Documentation and code updated \r\n", "- 23/5/2001 IM Documentation updated \r\n", "- 8/5/2001 IM Initial web page + first check-in \n        ", "\n            Feel free to send me comments, suggestions and bug reports. \n        "]},
{"details": ["\n    Name: simple_fm_receiver", "\n    Created: Jan  3, 2005", "\n    Updated: Mar 19, 2010", "\n        SVN Updated: Jun 27, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Simple implementation of FM Receiver to demodulate square wave signal modulated\r\n", "in FM. This design uses PLL to demodulate FM modulated signal.\n        ", "\n            - Synthesizable\r\n", "  - This design can be synthesize using Xilinx 6.3i\r\n", "  - This design can be simulated and synthesized using ", " (Alliance 5.0)\r\n", "- Simple\r\n", "  - Use it to understand PLL to see how FM Receiver works.\r\n", "  - Good for introduction in design process.\r\n", "  - Modular design, can be use for other design.\n        "]},
{"details": ["\n    Name: sc2v", "\n    Created: Oct  8, 2004", "\n    Updated: Nov 30, 2015", "\n        SVN Updated: Nov 30, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            - Full source code\r\n", "- PDF documentation\r\n", "- Written using lex and yacc tools\n        ", "\n            The sc2v translator is a software tool that translates a SystemC RT description into a Verilog equivalent one.\r\n", "The sc2v translator is based on lex and yacc tools. \r\n", "You need lex and yacc installed in order to compile sc2v.\r\n", "\r\n", "\r\n", "This work is given by Universidad Rey Juan Carlos (Spain)\r\n", "www.gdhwsw.urjc.es\n        ", "\n            - Version 0.5\r\n", "- TODO: See README File\r\n", "\r\n", "- LOOKING FOR CONTRIBUTORS\n        "]},
{"details": ["\n    Name: tlc2", "\n    Created: Jun 17, 2008", "\n    Updated: Jun 18, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The goal of this project is to provide a simple traffic light controller for different transport modeling purposes like model railways. \r\n", "I repeat \"modeling purposes\", don't even think about using it in real-world applications :)\r\n", "\r\n", "\n        ", "\n            - Very simple, stand-alone Traffic Light Controller\r\n", "- Through generics parameterizable light timing lengths\r\n", "- Testbench written in VHDL.\r\n", "- Makefile for synthesis with XST (Xilinx) and simulation with Modelsim (Mentor Graphics).\n        ", "\n            The main phase of the project is already finished, but a lot of additional features still need to be added. \r\n", "- The fixed time control mechanism could be extended with a sensor based dynamic control. \r\n", "- A parameterizable interface for modeling different kinds of road intersections would be a nice feature. \r\n", "- Specifications are still needed!\n        "]},
{"details": ["\n    Name: ptc", "\n    Created: Sep 25, 2001", "\n    Updated: Nov 17, 2006", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            PWM/Timer/Counter (PTC) IP core is a user-programmable PWM, Timer and Counter controller. Its use is to implement functions like Pulse Width Modulation (PWM), timer and counter facilities. \r\n        ", "\n            The following lists the main features of PTC IP core: \r\n\r\n- 32-bit counter/timer facility \r\n- single-run or continues run of PTC counter  Programmable PWM mode \r\n- System clock and external clock sources for timer functionality \r\n- HI/LO Reference and Capture registers \r\n- Three-state control for PWM output driver \r\n- PWM/Timer/Counter functionalities can cause an interrupt to the CPU  \r\n- WISHBONE SoC Interconnection Rev. B compliant interface \r\n\r\nMore information about the WISHBONE SoC and a full specification can be found ", ". \r\n\r\nFor further information, questions and general discussions related to the PTC core, please visit the Cores Mailing list.\n        ", "\n            - Verilog RTL and verification suite under development \r\n", "- The Specification is complete: ptc_spec.pdf (see Downloads) \n        "]},
{"details": ["\n    Name: fpgaconfig", "\n    Created: Jan  7, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Configure Altera and Xilinx FPGAs using a small low cost micro-controller and commodity SD/MMC/SPI flash memory.\r\n", "\r\n", "There are already solutions available that use a CPLD and SD/MMC/SPI flash memory, but this scheme uses a very small C8051 micro-controller in place of the CPLD, and this has several advantages.\r\n", "1. Smaller. C8051 is available in a 4mm x 4mm package.\r\n", "2. Very few additional components. eg C8051 has internal oscillator.\r\n", "3. Less programming headers. Only one small header required.\r\n", "4. A local microprocessor can be connected to the C8051 UART port, and program the flash memory using a few simple commands.\r\n", "\r\n", "Downloads configuration files at 2Mbps. For example a Cyclone EP1C20 can be configured in under 2 seconds. \r\n", "\r\n", "The total solution is very compact requiring only 2 ICs, 1 programming header, 1 resistor, and 2 capacitors.\r\n", "\r\n", "To program the SD/MMC/SPI flash memory on your target hardware, you can purchase the Base2Designs USB2Flash programming adapter (", "\r\n", "\n        ", "\n             - Low cost.\r\n", " - Customer can upgrade hardware by replacing SD card.\r\n", " - Wide choice of flash memory manufacturers.\r\n", " - Large flash memory capacity.\r\n", " - Flash memory can be used to store large software images.\r\n", " - Fail safe in field re-programming.\r\n", "\n        ", "\n            Release 1.0 available. Tested with Altera and Xilinx FPGAs. Download from ", "\r\n", "If there is enough interest I will port the C8051 firmware to a USB capable microcontroller. This would allow end customers to upgrade their hardware directly from a PC.\r\n", "\n        ", "\n            FILE: fpgaConfig_system_block_diag.gif\n", "DESCRIPTION: \n", "\n        ", "\n            FILE: altera_config.png\n", "DESCRIPTION: \n", "\n        ", "\n            See fpgaConfig used in a complete project at:\r\n", "\n        "]},
{"details": ["\n    Name: scct", "\n    Created: Jun 10, 2015", "\n    Updated: Dec  3, 2015", "\n        SVN Updated: Jun 15, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            SCCT is a Simple Capture/Compare Timer written in Verilog. It provides multiple capture/compare channels that use a common counter. Events occurring in the single channels thus can be related to a global time base. SCCT is developed as an IP core that can be attached to the Altera Avalon bus. \n        "]},
{"details": ["\n    Name: ps2", "\n    Created: Sep 25, 2001", "\n    Updated: Mar 10, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The PS/2 interface project (ps2_interface) is interface hardware to allow using a ps2 mouse or keyboard in your project. The code is written in Verilog, and was sythesized into a Xilinx SpartanII XC2S200 chip. Debugging was done with an HP16500 series logic analyzer, and there is no testbench for these interfaces.\r\n", "\r\n", "For the keyboard interface, there is translation from scan codes into ASCII characters, for those scan codes that have ASCII equivalents. Also, the keyboard interface traps the left/right shift scan codes, and produces uppercase ascii when appropriate. This means that the keyboard interface can be used with a serial port core to create an ASCII terminal type of interface on chip. The keyboard interface is bi-directional, so the user can send commands to change the operation of the keyboard, or light up the \"Num Lock\", \"Caps Lock\" and \"Scroll Lock\" LEDs as desired.\r\n", "\r\n", "The mouse interface implements \"hot plugging\" of the mouse. This means that the mouse may be unplugged and then re-connected, and the interface hardware will recognize this, and issue the command to put the mouse into \"streaming mode\" so that it starts sending out data packets. The position updates from the mouse are provided in terms of two 10-bit signed quantities: an X-increment and a Y-increment. In actual use, the Y-increment appears to be negative of the sense you would expect (i.e. moving the mouse up produces a negative increment...) For simplicity, this interface only sends one command to the mouse, which is the command to put it into streaming mode.\r\n", "\r\n", "The design team of ps2_interface welcomes any kind of help and feedback on these cores. If you are interested in further development of this project, please contact us.\n        ", "\n            - These cores have been coded completely, synthesized and tested for correct operation (and debugged!) inside a Xilinx XC2S200 chip. The tools used for development were the Xilinx Foundation 3.1i (non-ISE) tools. \r\n", "- These cores were also tested using the free Xilinx Webpack ISE (9/10/01) tools. However, the \"rs232_syscon.v\" module has to be modified to work with ISE (only important for the \"soc\" type downloads). The ASCII characters must be coded as numbers in ISE... \r\n", "- There are no technology-dependent elements used in these cores. \r\n", "- The cores consume about 100 Xilinx Virtex slices each (depending on parameters) \r\n", "- The cores are parameterized to allow changing timer values to accomodate different clock speeds. \r\n", "- The code has comments. The interface to the mouse and keyboard use tri-state I/O for the bi-directional clk and data lines. These lines must have pullup resistors! (the value is not very critical.) \r\n", "- The interface is currently implemented using state-machines (no processor is involved.) \r\n", "- \"Debounce\" states are provided in the state machines, to make the interfaces more tolerant of different types of mice and keyboards.\r\n", "\r\n", "In the future, a bare bones version of the keyboard interface could be implemented which implements only receive, to save on resource utilization and eliminate the bi-directional interface. For the mouse interface, this is impossible, since the mouse requires a \"streaming mode\" command in order to begin sending its data packets.\n        "]},
{"details": ["\n    Name: round_robin_arbiter", "\n    Created: Mar 25, 2010", "\n    Updated: Mar 26, 2010", "\n        SVN Updated: Mar 26, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: scalable_arbiter", "\n    Created: Aug  5, 2008", "\n    Updated: Jan  8, 2010", "\n        SVN Updated: Nov 16, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            A scalable synchronous round-robin arbiter. The arbiter is designed to run at reasonable clock speeds with up to hundreds of request lines, and it grants in just a few clock cycles. The arbiter's interface has individual request and grant lines for each requesting device, as well as a binary encoded grant that can be used to control a bus multiplexer.\r\n", "\r\n", "The basic structure is a tree of small arbiters connected to form a larger arbiter. The tree structure yields linear size scaling and logarithmic delay scaling with respect to the number of request lines. Most of the implementation is in instantiating and interconnecting the arbiter tree. The actual logic boils down to a simple two-input arbiter.\r\n", "\r\n", "I started this project because I could not find a general purpose arbiter implementation with a configurable number of inputs that scales well. There is not much code for the arbiter implementation. Test benches and a demo instantiation are included. There are also some extras that are not particularly related to the arbiter. I just figured that they would be better off here than anywhere else. It might be better to combine this project with a larger, library type of project, but I did not see such a project in Verilog on OpenCores.\r\n", "\r\n", "The code is provided under the ISC license, which is a BSD-style license. Everyone is welcome to use and contribute.\n        "]},
{"details": ["\n    Name: mmac97", "\n    Created: Aug  6, 2010", "\n    Updated: Aug  7, 2010", "\n        SVN Updated: Aug 24, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\r\n", "\r\n", "\n            "]},
{"details": ["\n    Name: random_pulse_generator", "\n    Created: Mar 26, 2015", "\n    Updated: Apr 22, 2015", "\n        SVN Updated: Mar 27, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Poisson process generator. The time between each pair of consecutive pulses has an exponential distribution with desired rate. \u0422h\u0435 auxiliary pseudo-random uniform generator is based on 32-bit LFSR. The deign is tested on MICROSEMI IGLOO2 FPGA. \r\nHistogram of the number of clocks between output pulses:\r\n", "\r\nResult of simulation for the rate of one pulse per 16 clocks (parameter LN2_PERIOD=16):\r\n", "\r\n\n        "]},
{"details": ["\n    Name: ps2_keyboard_interface", "\n    Created: Oct 22, 2010", "\n    Updated: Dec  2, 2010", "\n        SVN Updated: Dec  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project is a Logic Unit that works as an interface between the PS/2 keyboard and any other microprocessor. It outputs the scan code of the key being pressed, it count the number of pressings.\r\n", "As an FPGA test , this project includes displaying the last 2 keys pressed on 7-Segment Display Units, it displays the numbers of pressings on some other LEDs.\n        ", "\n            Till Now, it outputs the Hexa Scan Code on the 7-Segment Display Units on an FPGA Kit for test and debugging purposes.\n        "]},
{"details": ["\n    Name: parallelcrcgen", "\n    Created: Jul  9, 2009", "\n    Updated: Jul 30, 2014", "\n        SVN Updated: May  1, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            \u00a0 CRC Generator is a command-line application that generates Verilog or VHDL code for a parallel CRC of any data width between 1 and 1024 and polynomial width between 1 and 1024. The CRC can be custom or protocol specific, for example PCI Express, USB5, USB16, 802.3, SATA. ", " \u00a0 The code is written in C and is cross-platform compatible", "\r\n\u00a0 There is an online version of the tool at ", "\r\nIt's more convenient to access, but the online tool is slower to generate the code for CRC with large data and polynomial widths.\r\n", "\r\n", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: or1200gct", "\n    Created: Sep 23, 2004", "\n    Updated: Apr  9, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            \n        ", "\n            \n        ", "\n            This is a Tcl/Tk script to configure OpenRisc 1200 options. \r\n", "I use it to configure the core and I think it could be usefull for other people.\r\n", "The look is very similar to LEON graphicall configuration tool.\r\n", "\r\n", "For comments, feedback, patches or whatever you want javier.castillo@urjc.es\r\n", "This tool is provided under the GPL license  Universidad Rey Juan Carlos (Spain)\r\n", "www.gdhwsw.urjc.es\n        "]},
{"details": ["\n    Name: opl3_20", "\n    Created: Nov 26, 2014", "\n    Updated: Jun  9, 2016", "\n        SVN: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Reverse engineered SystemVerilog RTL version of the Yamaha OPL3 (YMF262) FM Synthesizer chip. Design is complete and working on the Digilent ZYBO board.\r\n", "\r\n", "See it in action:\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "GitHub:\r\n", "\n        "]},
{"details": ["\n    Name: debouncer_vhdl", "\n    Created: Aug  9, 2011", "\n    Updated: May 22, 2017", "\n        SVN Updated: Sep 19, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The core is tested and is being used in FPGA hardware in several projects.\r\n", "\n            This core is being used in the SPI_MASTER_SLAVE verification test circuit: ", "\r\nTo get the latest version: ", "\r\nIf you have issues you like to be addressed, place a request in the bugtracker: ", "\r\nIf you find this core useful, please let me know: ", "\r\n", "\r\nIf you find the LGPL license to be unfit for your purposes, please let me know and we can study changing the license to another open-source hardware license.", "\r\n\r\n\r\n\n        ", "\n            ", "\r\nThis block is a general-purpose multiple input de-bouncing circuit.", "\r\nIt handles multiple inputs, like mechanical switch inputs, and outputs a de-bounced, stable registered version of the inputs.", "\r\nA 'new_data' one-cycle strobe is also available, to sync downstream logic.\r\n"]},
{"details": ["\n    Name: lpd8806", "\n    Created: Apr 24, 2013", "\n    Updated: Aug 20, 2014", "\n        SVN Updated: Apr 25, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Have you ever wanted to add some color to your project?  Then this might be your answer.  The LPD8806 RGB LED strings are available for low cost from various sites on the internet, and they come in strips which can be cut or joined to the desired length.  Since the Red/Green/Blue (RGB) LEDs on the strip are driven by a serial controller IC that is also on the strip, your project can set each LED color independently of the others.\r\n", "\r\n", "The connections to the LED strip include 4 wires: +5V, GND, clock and data.  It turns out that these LED strips will also work using +3.3V as the supply voltage!\r\n", "\r\n", "The format of the serial data stream used to drive the LEDs is given in the comments inside the VHDL code, and it can also be found by browsing the internet.  The color settings are 7-bits for each color, for a total of 2^21 combinations, over 2 million different colors.\r\n", "\r\n", "The VHDL module in this project was recently used in a Lattice Semiconductor FPGA.  However, it does not include architecture specific macros, so it should be easy to use on any given FPGA or CPLD.  It is parameterized so that the user can determine how many LEDs to drive, and the desired update rate to the LED string.\r\n", "\r\n", "The color data is provided to the module by an input data bus, using an address to select which LED and which color is being loaded.\r\n", "\r\n", "My VHDL coding style uses the \"unsigned\" type instead of the \"std_logic_vector\" type.  It is easy to translate between the two using functions in \"convert_pack.vhd\", or you can go through and modify the code to use std_logic_vector instead.\r\n", "\n        ", "\n            The module is ready to simulate and synthesize.\r\n", "\r\n", "It was used as part of a larger project...  Since I'm not including the full code for the entire project, I am currently only providing the LPD8806 module code plus an example of how it is instantiated and used, but without a nice testbench.\r\n", "\r\n", "Don't worry, the code works.  Just give it a try.  If you create a testbench, please send it to me and I'll post it for others to use.\r\n", "\r\n", "NOTE:\r\n", "There is an \"extra\" module provided in the code, which can be used to send single bytes of data to the LPD8806 string.  If you want to use this module, then you'll need to provide the signals \"sel_led\", \"bus_we\" and \"bus_dat_wr(7 downto 0)\".  Then you can send individual bytes, and see the separate green, red and blue LEDs light up individually in order as each new byte is received down the chain.  However, if you don't want to do that, then just delete that part of the code.\n        "]},
{"details": ["\n    Name: keyboardcontroller", "\n    Created: Jul  1, 2005", "\n    Updated: May  3, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The controller scans the keyboard by making a different column in \"rows\" logic-0\r\n", "therefor the inputs \"cols\" have to be PULL-UP high. It processes the inputs \"cols\" and\r\n", "the newly found keychange (keypress or keyrelease) is converted to the corresponding\r\n", "scancode (translated set2). Note that an interrupt pin is attached as well to make it\r\n", "possible to connect this controller to a PIC. \r\n", " \r\n", "Also note that the keyboard_controller uses an internal clock divider to divide\r\n", "the system clock of 50 Mhz to 100 kHz. Should you want to use an other frequency\r\n", "than 100 kHz please do not forget to change Constants.vhd  \r\n", "\n        ", "\n            - Simple debounce algorithm, it checks for stable inputs in last #nr samples\r\n", "- Ghosting protection\r\n", "- Module is easy to understand and build out of sub-modules\r\n", "\n        ", "\n            - Currently used for input processing of a toy-keyboard \n        "]},
{"details": ["\n    Name: lfsrcountergenerator", "\n    Created: Jun 22, 2009", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Jul  9, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            \u00a0 LFSR Counter Generator is a command-line application that generates Verilog or VHDL code for an LFSR counter of any value up to 63 bit wide. The code is written in C and is cross-platform compatible.", "\r\n\r\n\u00a0 There is an online version of the tool at ", "It's more convenient to access, but the online tool is slower to generate the code for large counter values.", "\n        "]},
{"details": ["\n    Name: keypad_scanner", "\n    Created: Apr  1, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a very small and simple module, which scans through an X-Y matrix of keys, and produces a \"snapshot\" of bits which represent the sampled state of the keyswitches during the scan.\r\n", "\r\n", "There is memory in the module, so that the outputs are held constant during a scan, and updated simultaneously.  The keys are sampled sequentially, but the memory stores up all of the keyswitch data until the final output \"snapshot\" is produced.\r\n", "\r\n", "This module is parameterized Verilog, and is recommended for use with small matrix type keypads.  It has been tested in real hardware.\r\n        ", "\n            - Parameterized Verilog code, tested in hardware\r\n", "- Commented code, but no testbench\r\n", "- Small module, easy to use and understand\r\n", "- No support for \"ghost key\" detection (when three or more keys are pressed, a fourth \"phantom key\" can sometimes appear.  This is true for most matrix type keyboards.)\r\n", "\r\n        "]},
{"details": ["\n    Name: jtag", "\n    Created: Sep 25, 2001", "\n    Updated: Jan 25, 2018", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This implementation of the Test Access Port (TAP) is fully IEEE 1149.1 compliant. It includes a TAP controller, a 4-bit instruction register and three test data registers: idcode register, bypass register and boundary scan register. Boundary scan register is connected to eight pins (2 inputs, 2 outputs, 2 tristatable outputs and 2 bidirectional pins). Besides the Verilog code, a BSDL file is also provided. The number of pins can be easily increased by following the instructions. The design had been tested with the JTAG Technologies testing equipment (The TAP controller was implemented in Xilinx 95144XL). The design will be expanded in the future to support additional instruction and debug capabilities. \n        ", "\n            - New release of the TAP controller. Sections used for debugging were put in a separate project (", ")\r\n- New release of the specification document.\r\n- A description of a Boundary Scan Implementation(57KB) is avaliable in Adobe PDF format (see Downloads). \r\n- ", " is finished. \r\n- Verilog and BSDL files can be accessed via ", ". \r\n\n        ", "\n            - nothing at the moment\n        "]},
{"details": ["\n    Name: ima_adpcm_encoder", "\n    Created: Nov  5, 2008", "\n    Updated: Apr 27, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\n        ", "\n            This project features a full-hardware sound compressor using the well known algorithm: IMA ADPCM.\r\n", "\r\n", "The core acts as a slave WISHBONE device.\r\n", "\r\n", "The output is perfectly compatible with any sound player with the IMA ADPCM codec (included by default in every Windows). Includes a testbench that takes an uncompressed PCM 16 bits Mono WAV file and outputs an IMA ADPCM compressed WAV file. \r\n", "\r\n", "Compression ratio is fixed for IMA-ADPCM, being 4:1.\r\n", "\r\n", "PLEASE NOTICE THAT THIS CORE IS LICENSED UNDER ", " (Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported). That means you may use it only for NON-COMMERCIAL purposes. \r\n", "\n        ", "\n            - IMA ADPCM Compression (4 bits per sample)\r\n", "  - Input must be 16 bits PCM sound samples\r\n", "  - Only one channel (mono)\r\n", "  - Output includes standard WAV headers\r\n", "  - Selectable sample rate and number of seconds of recording\r\n", "- Fully Wishbone compliant core (acts as a Wishbone slave)\r\n", "- Testbench included that takes a 16 bits PCM Mono WAV file and writes to disk another WAV file of the sound compressed with IMA ADPCM.\n        ", "\n            - 05/11/2008: Project created\n        "]},
{"details": ["\n    Name: gsc", "\n    Created: Jul 31, 2007", "\n    Updated: Feb 22, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Description of project..\n        ", "\n            - feature1\n", "  - feature1.1\n", "  -feature1.2\n", "-feature2\n        "]},
{"details": ["\n    Name: vectorial_generator", "\n    Created: Mar 22, 2013", "\n    Updated: Mar 31, 2013", "\n        SVN Updated: Mar 30, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Vectorial generator:\r\n", "\r\n", "-Interface: bit or bus\r\n", "-Configuration: dynamic\r\n", "-Applications: waveform generator, serial or parallel communication\r\n", "\r\n", "Examples:\r\n", "\r\n", "-Included in the own .vhd headfile\r\n", "\r\n", "Configuration:\r\n", "\r\n", "-It is necessary to adjust the following type which defines the input size (it affects to area resources):\r\n", "\r\n", "    SUBTYPE valores_vector  IS INTEGER RANGE -1 TO nat_synth_65536'high;  -- values range for each sample (always from -1)      \r\n", "    TYPE    vector_integer  IS ARRAY (nat_synth_128'high DOWNTO 0) OF valores_vector; -- number of samples*2\r\n", "\r\n", "where:\r\n", "\r\n", "    SUBTYPE nat_synth_65536 IS NATURAL RANGE 0 TO 65535;\r\n", "    SUBTYPE nat_synth_2048  IS NATURAL RANGE 0 TO 2047;\r\n", "(...) \r\n", "    SUBTYPE nat_synth_16    IS NATURAL RANGE 0 TO 15;               \n        "]},
{"details": ["\n    Name: hwlu", "\n    Created: Apr 16, 2004", "\n    Updated: Jul  9, 2011", "\n        SVN Updated: Apr  3, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Tha main purpose of the hardware looping unit (HWLU) is to enhance program control units found in modern microprocessors, by efficiently handling loop increments and branches in nested loop structures. It is based on recently published work (details can be found in the specification document). The main advantage of the presented architecture is that successive last iterations of nested loops are performed in a single cycle. This architecture can be useful in the case that all data processing in context of a nested loop structure is performed in the inner loop, which is rather often in multidimensional signal processing applications as performance-critical code in image coding and video compression standards.\r\n", "\n        ", "\n            Find more details at:\r\n", "\r\n", "\n        ", "\n            - status1\n", "- status2\n        "]},
{"details": ["\n    Name: ffr16", "\n    Created: Aug  5, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The aim of this Core is to track the first file saved \r\n", "into a FAT16 volume and to read the information from it offering those data to a Wishbone bus trough a Wishbone slave interface. The Core has an IDE interface that permits the attachment of devices as Compact Flash (no DMA support). It uses about 300 Xilinx Spartan II slices (if Area optimization is chossen about 285). \r\n", "\r\n", "Internally it has two Modules that can be used indepently. Both of them are implemented using a Picoblaze Programmable State Machine, using Xilinx BlockRams for instructions. Those modules are: \r\n", "\r\n", "1 - HOST ATAPI UNIT (HAU): Controls IDE signals and manages the ATAPI protocol for sector reading. For a sector read, it only needs the LBA (Logic Block Address) as input, answering with the words of that sector. This module can be used in embedded systems that do not require any specific FAT format. As the control state machine is implented in \"software\", modifications (write support, for example) are easy to implement. \r\n", "\r\n", "2 - FAT PROCESSOR UNIT (FAU): It requests to HAU the necessary sectors to track and read the first valid file which has been stored into the IDE device that uses a FAT16 volume. \r\n        ", "\n            FILE: FFR16.jpg\n", "DESCRIPTION: FFR16 internal module division and interfaces\n", "\n        ", "\n            - Small area requeriments.\r\n", "- Written in VHDL and in KCPSM assembler.\r\n", "- Co-simulation facilities (KCPSM assembler generates VHDL simulable file).\r\n", "- Mix & Run in SoPC due to the use of a Wishbone interface is used. Spartan II and 50 Mhz clock\n        ", "\n            - Design is finished and available in VHDL from OpenCores CVS. \r\n", "- Documentation is no still available.\n        "]},
{"details": ["\n    Name: pulse_processing_algorithm", "\n    Created: Sep 13, 2011", "\n    Updated: Dec  5, 2011", "\n        SVN Updated: Sep 21, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: mmcfpgaconfig", "\n    Created: Dec 27, 2004", "\n    Updated: Jan  9, 2005", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            IP Core for FPGA Configuration Controller from MMC Card. Can configure an FPGA in serial mode from continous blocks stored on MMC Card. Smallest version of the IP Core only needs 21 PLD Macrocells.\n        ", "\n            - FPGA Configuration modes supported\r\n", "  - Master Serial (Xilinx) > FPGA tested\r\n", "  - Slave Serial\r\n", "- Small Size\r\n", "  - Minimal Core is 20 CoolRunner PLD-Macrocells\r\n", "- Removable Media for Bitstream Storage\r\n", "  - MMC Cards are supported (no SD-Cards!)\r\n", "\r\n", "\n        ", "\n            - Xilinx Master Serial mode support tested with real HW (XC9536XL as config controller configuring VP20)\r\n", "- \n        "]},
{"details": ["\n    Name: wbfmtx", "\n    Created: Mar 22, 2016", "\n    Updated: Jun 15, 2016", "\n        SVN Updated: Jun 15, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "After watching a friend demonstrate how a Raspberry PI GPIO pin could be used to transmit an FM signal for a short distance, I wondered if the same could be done with an FPGA GPIO pin.  This project is that attempt.  This transmitter is by no means \"approved\" by the FCC or any other regulating body, so please only use it in a lawful manner.  (My hardware transmits a signal that can only be heard within a couple inches of the receiver.)\n        ", "\n            You'll find the core in the rtl/ directory.  I finally had the guts to test it this morning (14 June, 2016).  It works!!  \r\n", "The only caveat was that I needed to strap together multiple GPIO I/O outputs to the output of this device, and even then it didn't transmit for more than a couple of inches, still ... that was enough to prove that the concept works.\n        "]},
{"details": ["\n    Name: cdc_ufifo", "\n    Created: Dec  2, 2010", "\n    Updated: Jan 28, 2011", "\n        SVN Updated: Dec  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Clock Domain Crossing micro FIFO (Verilog/SystemVerilog):\r\n", "    cdc_ufifo provide an minimalist fifo. Most advantage - not use RAM blocks.\r\n", "it can be 4 buffer data cells minimum.\r\n", "by default used implementation without ram, only standart register cells used, and it can be selected if need. most slowest stage is the output multiplexor\r\n", "Shadowed outputs: provide an register after multiplexer to remove data unsynchronized changes from outputs when skiped some cycles.\r\n", "\n        ", "\n            CycloneII project works on up to 50 MHz data transfers\n        "]},
{"details": ["\n    Name: bubblesortmodule", "\n    Created: Mar 28, 2014", "\n    Updated: Mar 30, 2014", "\n        SVN Updated: Mar 30, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            simple fast bubble sort module in verilog\n        "]},
{"details": ["\n    Name: wbif_68k", "\n    Created: Dec  2, 2002", "\n    Updated: Feb 14, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a Motorola DragonBall/68K to Wishbone bridge. The core translates the 16bit DragonBall/68K bus into a full featured 16bit Wishbone master bus.\n        ", "\n            - 16bit Motorola DragonBall/68K Interface\r\n", "- 16bit full featured RevB.3 Wishbone Classic Master interface\r\n", "- programmable address-bus size\r\n", "- static synchronous design\r\n", "- fully synthesisable\r\n", "- 6LUTs in a Spartan-II, 32LCELLs in an ACEX\n        ", "\n            Design is finished and available in Verilog for download from OpenCores CVS.\n        "]},
{"details": ["\n    Name: boundaries", "\n    Created: Jul  2, 2004", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This project is a collection of small designs involved with clock boundaries.\r\n", "The clock_switch designs are based on an eetimes article.\r\n", "The bc_fifo_basic design is based on ideas from generic_fifo_dc_gray.\n        ", "\n            - debouncer: debounce a mechanical switch.\r\n", "- clock_switch2_basic: select 1 of 2 clocks, no glitches.\r\n", "- clock_switch3_basic: select 1 of 3 clocks, no glitches.\r\n", "- clock_switch4_basic: select 1 of 4 clocks, no glitches.\r\n", "- clock_switch8_basic: select 1 of 8 clocks, no glitches.\r\n", "- oc_fifo_basic: a one-clock fifo\r\n", "- bc_fifo_basic: a boundary-crossing fifo\r\n", "- clock_detect: a clock-active detector\r\n", "- arbiter: a simple parameterized round-robin arbiter\r\n", "- random_ff: a ff simulation model for async boundaries\n        ", "\n            - None of these designs have been verified in silicon.\r\n", "\n        "]},
{"details": ["\n    Name: 16x2_lcd_controller", "\n    Created: Jul 29, 2012", "\n    Updated: Nov 28, 2012", "\n        SVN Updated: Nov 28, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Controller for 16 character - 2 line LCD displays as used on various Xilinx evaluation boards.\n        ", "\n            - 4-bit LCD data interface ", "\r\n- One 128bit-wide std_logic_vector input for each diplay line (16x8bit=128). Everything you send to those inputs goes directly to the display.\n        ", "\n            - Tested on Xilinx ML501 and ML507 ", "\r\n- Virtex5: 37 flip flops, 228 LUTs, >300MHz\n        "]},
{"details": ["\n    Name: freq_div", "\n    Created: May  9, 2010", "\n    Updated: Jan 21, 2016", "\n        SVN Updated: Jul 23, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            In order to operate the circuit correctly it must first be reset (asynchronously).  \r\nBelow is a timing diagram that illustrates the reset pulse timing requirements.\r\n", "\r\nNote: the circuit only needs to be reset once to operate properly.  Every time the divide factor N changes, the circuit automatically resets itself.\r\n", "\n        ", "\n            The adjustable frequency divider is designed in two parts:\r\n", "\r\n"]},
{"details": ["\n    Name: a_vhdl_8253_timer", "\n    Created: Aug  3, 2008", "\n    Updated: May 14, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            a VHDL version of the Intel 8254 timer.\r\n", "\r\n", "Note: uses a synchronous (Wishbone) processor interface, rather than an asynchronous of the Intel 8254.\r\n", "\r\n", "Design assumes asynchronous interface/counter clocks \u2013 includes Boolean generics (for each counter) if the same clock is used for interface and counter, or if the clocks are synchronous (different frequency, but with aligned rising edges)\r\n", "\n        ", "\n            Uses parts from the gh_vhdl_library project\n        ", "\n            added version with AMBA APB interface 16 Aug 2008\n        "]},
{"details": ["\n    Name: wb_mcs51", "\n    Created: Mar  3, 2008", "\n    Updated: Jul 25, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Interface an 8051-compatible microcontroller with the Wishbone bus.\n        ", "\n            - Multiplexed 8051 address/data bus to Wishbone Master\r\n", "- Very simple, very small.\r\n", "- Since 8051 has no way to add additional wait-states via an external pin, the Wishbone must be fast enough to complete the cycle in time for the 8051.\n        ", "\n            - Tested with Silicon Labs C8051 Microcontroller and Xilinx Coolrunner2 CPLD.\r\n", "- Tested with Silicon Labs C8051 Microcontroller and Xilinx Spartan3 FPGA.\r\n", "- this core is used in the Altair32 Front Panel: www.altair32.com\n        "]},
{"details": ["\n    Name: wb_flash", "\n    Created: Jun  3, 2008", "\n    Updated: May 19, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Wishbone to Parallel FLASH interface with integral wait-state generator.  This design has been used with the Intel StrataFlash Xilinx Spartan 3E Starter Kit.  Provides an 8-bit data interface to the FLASH, and a 32-bit Wishbone Slave Interface with byte enables.\r\n", "\r\n", "The StrataFlash on the S3E Starter Kit can be programmed using the PicoBlaze RS-232 StrataFlash\u2122 Programmer downloadable from the following site:\r\n", "\r\n", "\r\n", "\n        ", "\n            - Compatible with Intel StrataFlash J3 on Xilinx Spartan 3E Starter Kit\r\n", "  - Supports byte-mode operation.\r\n", "- 32-bit Wishbone Slave Interface\r\n", "\n        ", "\n            - Tested on Xilinx Spartan 3E Starter Kit\r\n", "\n        "]},
{"details": ["\n    Name: zbt_sram_controller", "\n    Created: Oct 17, 2008", "\n    Updated: Sep  4, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a ZBT SRAM controller which is Wishbone rev B.3 compatible (classic + burst r/w operations). \r\n", "\r\n", "PLEASE NOTICE THAT THIS CORE IS LICENSED UNDER ", " (Creative Commons Attribution-Noncommercial-Share Alike 3.0 Unported). That means you may use it only for NON-COMMERCIAL purposes.\r\n", "\r\n", "It has been simulated and verified on a Xilinx Virtex-5 FPGA board of type ML-506.\r\n", "\r\n", "This core is Wishbone compliant, using registered feedback cycles. \r\n", "\r\n", "The only quirk is that, in burst operations, the \"wb_tga_i\" input must be '0' during the last (or single) 4 words burst (the last four clock cycles, being the fourth the one in which wb_cti = \"111\" indicates the WB end of burst).\r\n", "\r\n", "In short: keep \"wb_tga_i\" low unless you want to read 4 more words in another burst immediately following the current one.\r\n", "\r\n", "This is necessary in order to make the perfect overlap between ZBT read/write burst cycles and Wishbone's registered feedback cycles.\r\n", "\r\n", "It is fully functional, but any bug reports are very welcome.\r\n", "\r\n", "In the next image a typical multiple burst operation is shown (it's the same for read/write, so wb_we_i, wb_dat_i, wb_dat_o are omitted for clarity), where 12 words are read from memory, which means 3 bursts of 4 words each.\r\n", "\r\n", "1.- In the first cycle (the first one where wb_cti_i=\"010\") signals wb_cyc_i, wb_stb_i, wb_adr_i, wb_we_i and wb_dat_i (for writes) are set.\r\n", "\r\n", "2.- As we are going to read/write 3 bursts (of 4 words each), the wb_tga_i signal must be at '1' during the first two bursts.\r\n", "\r\n", "3.- Don't change any signals until wb_ack_o rises.\r\n", "\r\n", "4.- When wb_ack_o = '1' then increment wb_adr_i every cycle.\r\n", "\r\n", "5.- (This is the only step not in the WISHBONE specs.) After the first two bursts are done, lower the wb_tga_i signal in order to signal the ZBT SRAM Controller that the last burst starts now.\r\n", "\r\n", "6.- In the last cycle wb_cti_i must be \"111\" to signal a Wishbone end of burst and, after that, wb_cyc_i and wb_stb_i must be lowered (or stay risen in order to initiate a new transaction).\r\n", "\r\n", "The fifth step is the only one not in the WB specs. for registered feedback cycles. The rest are normal operation as defined in the specifications.\r\n", "\n        ", "\n            - This core differs from others at OpenCores in that it makes the best overlap between Wishbone registered feedback burst cycles and the ZBT SRAM burst R/W cycles, so that the fastest access (a continuous burst) can be achieved.\r\n", "\r\n", "- Also Wishbone classic cycles can be used (for single word R/W) although the core wasn't optimized for them (i.e.: for a read, it takes three wait cycles to output a single word).\n        ", "\n            - 17/10/2008: I'll upload the source and testbench in a few days (after cleaning it up a bit ;)\r\n", "- 30/10/2008: Source code uploaded (pending to do a nice Wishbone documentation)\r\n", "\r\n", "\r\n", "This core has been developed under a project of the Spanish Ministry of Science.\r\n", "\n        ", "\n            FILE: ZBTSRAM61NLP_NVP25636A_51218A.pdf\n", "DESCRIPTION: Datasheet for ISSI IS61NLP ZBT SRAM (used in Xilinx ML506 board)\n", "\n        ", "\n            ", "\n        "]},
{"details": ["\n    Name: versatile_fifo", "\n    Created: Mar 31, 2009", "\n    Updated: Feb 11, 2014", "\n        SVN Updated: Nov  4, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\n", " The FIFO implementation outlined in this document can easily be configured to suit the following \r\n", "\r\nThis FIFO can easily be extended to have common wishbone interface for all individual FIFO channels.\r\n"]},
{"details": ["\n    Name: srl_fifo", "\n    Created: Jan  2, 2008", "\n    Updated: Feb 28, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            - Simulated and ( 16 and 32 ) programmed into a Spartan 3 FPGA\r\n", "- Synthesised with ISE 10.1 \r\n", "\r\n", "- looking at a generic srl fifo now ise can handle such\r\n", "\n        ", "\n            Synchronous FIFO's based upon the SRL feature found in Xilinx FPGA's.\r\n", "\r\n", "Built to be small. \r\n", "\r\n", "In a Spartan 3, the 8 bit wide , 16 bit deep FIFO utilises\r\n", "19 Luts\r\n", "of which 8 are used as SRL, 11 as Logic.\r\n", "\n        ", "\n            Pure VHDL, no instantiated components, all inferred\r\n", "small size\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: usb_nand_reader", "\n    Created: Jul 13, 2016", "\n    Updated: Jan 20, 2017", "\n        SVN Updated: Oct 17, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: wb_3p_spram_wrapper", "\n    Created: Nov  7, 2008", "\n    Updated: Jan 23, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a wrapper for an inferred single port RAM, that converts it into a Three-port RAM with one WISHBONE slave interface for each port.\r\n", " \r\n", "Very useful as a drop-in module to create configuration registers for any core.\r\n", "\n        ", "\n            - Generics for data and address widths of internal RAM\r\n", "- Included inferred single port ram (but ready to use an instantiated SPRAM component, i.e.: generated by coregen)\r\n", "- Wait states are reduced to the very minimum (writes immediately acked)\r\n", "- Provides a way to lock access to only one port at a time (by keeping wb_cyc line high in the port of the locking master)\r\n", "- Priority switching to avoid deadlocks (when one port is freed, the next port's pending request will be serviced)\r\n", "\r\n", "\n        ", "\n            - 07/11/2008: Project created in OpenCores\n        ", "\n            The interface includes the standard WISHBONE lines: wb_clk_i and wb_rst_i (active high asynchronous reset).\r\n", "\r\n", "Apart from these two, there are three independent WISHBONE slave ports, each with the following lines (N goes from 1 to 3):\r\n", "- wbN_cyc_i\r\n", "- wbN_stb_i\r\n", "- wbN_we_i\r\n", "- wbN_adr_i\r\n", "- wbN_dat_i\r\n", "- wbN_dat_o\r\n", "- wbN_ack_o\r\n", "\r\n", "IMPORTANT: To achieve the best performance, memory writes are implemented with immediate acks. This means that no read is performed during a write, so wb_dat_o MUST be ignored when a write is acked.\r\n", "\r\n", "OPERATION:\r\n", "\r\n", "Let's define the situation as one in which there are three masters (A,B, and C) connected to this core, trying to do simultaneous operations on the spram, each one connected to one of the WB ports (A -> wb1, B -> wb2, and C -> wb3). \r\n", "\r\n", "Of course, if one port is not used, its cyc and stb lines MUST be tied low to prevent the core from deadlocking. Take note also that if one port is not used, the core won't see its performance affected, that is, it will work as if it were a two port wrapper, instead of three ports.\r\n", "\r\n", "\r\n", "NORMAL OPERATIONS:\r\n", "\r\n", "In case there is no need to make atomic operations, a master connected to a port of this core can work as if there weren't any other masters connected to other ports.\r\n", "Plus, the core switches the port priority the moment a master (that was using the memory) drives low its cyc and stb lines.\r\n", "\r\n", "That is, for example: master B does an operation (R/W), and it is acked by this core. Then, if master B drives low its cyc and stb lines, and in the next cycle master B and master C rise their cyc and stb lines simultaneously, master C will be the one serviced, not master B again. This way a greedy master won't take up the bus.\r\n", "\r\n", "\r\n", "\r\n", "ATOMIC OPERATIONS (port locking):\r\n", "\r\n", "Let's suppose that master B wants to make a set of atomic operations consisting of one read, then a pause of 20 cycles, then a write, then another pause of 5 cycles and then another write. This master (B) needs to know that no other master connected to this core (A or C) does any read or write to the memory, while this set of atomic operations is being performed.\r\n", "\r\n", "In order to make atomic operations, master B (which is connected to, for example, the 2nd WB port) would need to drive high the wb2_cyc and wb2_stb lines, to perform the first read of the set of atomic operations. After receiving the ack from this core, master B will drive low ONLY the line wb2_stb during the 20 pause cycles master B to prepare the next write it needs to do.\r\n", "\r\n", "Then, master B should drive high again the stb line and perform the write (of course rising also the \"we_i\" line and putting the right data on \"dat_i\" and \"adr_i\" lines), remember that the cyc line was already up, to lock the memory on to this port.\r\n", "\r\n", "After receiving the ack for this write, the master B of this example needs another 5 cycles of processing in which it won't make any other operations on the RAM, so after the second ack (the one corresponding to the second WB operation, the write) it will drive low ONLY the wb2_stb line, keeping cyc high, that way the memory bus is locked on to this port, and it won't service requests, again, from other ports.\r\n", "\r\n", "After the five cycles, master B makes its last operation of the example, another write, by driving high the stb line (and with the rigth we_i, dat_i and adr_i lines, obviously) and waiting to be acked by this core, meaning that the memory was written. After receiving this third, and last, ack master B will drive low its wb2_cyc and wb2_stb lines, because it has ended the atomic set of operations, so that master A and C can keep on using the memory.\r\n", "\r\n", "I short: Keeping the wbN_cyc line high with the wbN_stb line low (after being acked once) will signal to this core that the memory must be kept locked on to master N and no other request from other ports will be serviced until the cyc line is lowered again.\r\n", "\r\n", "A WISHBONE slave port N may be considered locked onto its master X when: \r\n", "\r\n", "1) this slave port N acks one time\r\n", "2) the wbN_cyc line is not driven low by master X.\r\n", "\r\n", "From this point on, the acked master may make any operations on this slave port, knowing for sure that no other master will be able to access the memory until the cyc line is driven low again. (the \"slave acks one time\" requirement is because up until that moment, the master can not be sure that there is another master already locking this slave)\r\n", "\r\n", "In simple terms, any group of atomic operations must be preceded by a read, and the cyc line must not be driven low until the end.\n        ", "\n            ", "\n        "]},
{"details": ["\n    Name: wb_size_bridge", "\n    Created: Mar 16, 2009", "\n    Updated: Feb  4, 2010", "\n        SVN Updated: Mar 29, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This IP provides a 8-bit or 16-bit bridge for a 32-bit WishBone interface. There is no buffering. The 32-bit transaction is delayed until the transaction is complete. An example using the wb_size_bridge is included that interfaces to an asynchronous memory. The asynchronous memory module has configurable setup times, hold times, and big/little endian support.\r\n", "\n        "]},
{"details": ["\n    Name: synchronous_reset_fifo", "\n    Created: Oct  9, 2011", "\n    Updated: Nov 23, 2017", "\n        SVN Updated: Dec 19, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: fifo_srl_uni", "\n    Created: Mar 19, 2010", "\n    Updated: Apr 19, 2010", "\n        SVN Updated: Mar 21, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: openhmc", "\n    Created: Sep 30, 2014", "\n    Updated: May 12, 2015", "\n        SVN Updated: Aug 10, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\n\r\nopenHMC is an open-source project developed by the Computer Architecture Group (CAG) at the University of Heidelberg in Germany. It is a vendor-agnostic, AXI-4 compliant Hybrid Memory Cube (HMC) controller that can be parameterized to different data-widths, external lane-width requirements, and clock speeds depending on speed and area requirements.\r\n\r\nThe main objective of developing the HMC controller is to lower the barrier for others to experiment with the HMC, without the risks of using commercial solutions.\r\n\r\nFor more information check the official openHMC documentation, available here on opencores.org or on the official project website ", "\n        ", "\n            The openHMC controller is presented as a high-level block diagram in the figure below. The asynchronous input and output FIFOs allow the user to access the memory controller from a different clock domain. On the transceiver side, a registered output holds the data reordered on a lane-by-lane basis; allowing seamless integration with any transceiver types. A register-file provides access to control and monitor the operation of the memory controller.\r\n\r\n", "\r\n\r\n\r\n", "\r\n\r\nThe openHMC controller implements the following features as described in the HMC specification Rev 2.0:\r\n\r\n- Full link-training, sleep mode, and link retraining \r\n- 16Byte up to 128Byte read and write (posted and non-posted) transactions\r\n- Posted and non-posted bit-write and atomic requests\r\n- Mode Read and Write\r\n- Full packet flow control\r\n- Packet integrity checks (sequence number, packet length, CRC)\r\n- Full link retry\n        "]},
{"details": ["\n    Name: single_port", "\n    Created: Jan  7, 2003", "\n    Updated: Dec 27, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The main purpose of this project was two-fold. The first purpose was to implement a client-server test architecture based on Bergeron's work in VHDL. The main advantage to this verification method is greater stress-test ability and removes the need to create test script language to test the DUT. \r\n", "The second purpose was to bench-mark the running speed of the ASRAM implemented as three different architectures.\r\n", "1. Linked-list\r\n", "2. Bit-vector \r\n", "3. regular std_logic_vector implementation.\r\n", "\r\n        ", "\n            - Demonstrates client-server testbench architecture in VHDL.\r\n", "- bit-vector array memory core\r\n", "- standard-logic array memory core\r\n", "- dynamic linked-list memory core.\r\n        ", "\n            Completed.\r\n        "]},
{"details": ["\n    Name: dram", "\n    Created: Sep 25, 2001", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Parameterisable DRAM model, i.e. scalable data and address widths. Simulation assertions can be toggled on/off. Uses !RAS/!CAS control sequence for modelling DRAM activity. Refresh is monitored with data corrupted to \"UU ... \" \n        ", "\n            - VHDL code is available (see Downloads)\n        ", "\n            - Damon P Thompson\n        "]},
{"details": ["\n    Name: opb_psram_controller", "\n    Created: Feb  9, 2008", "\n    Updated: Feb 16, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The OPB PSRAM-Controller connect a Pseudo-Staic-RAM, also named CellularRAM\u2122 to the OPB-Bus. \n        ", "\n            Design\r\n", "- max. 80 Mhz Memory Clock for a Spartan-3 1500 FPGA\r\n", "- synchronous design, no DCM/DLL needed\r\n", "Performance with micron MT45W8MW16BGX-701\r\n", "- 32-Bit Write: 3 Clock cycles\r\n", "- 32-Bit Read: 8 Clock cycles\r\n", "\n        ", "\n            - Design Phase done\r\n", "- Simulation Tests done\r\n", "- Real-World Tests done\r\n", "\n        "]},
{"details": ["\n    Name: nand_controller", "\n    Created: May 26, 2015", "\n    Updated: Dec  7, 2017", "\n        SVN Updated: Jun 30, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 4 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please see this document for ", "\n        ", "\n            Please see the ", " document for interface specifications.\r\nIt is highly recommended to read the ", " first.\n        "]},
{"details": ["\n    Name: memory_cores", "\n    Created: Sep 25, 2001", "\n    Updated: Oct 14, 2001", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Check the memory cores site for more documentation at ", ".\n        ", "\n            - VHDL codes are stable and available on the CVS \r\n- Some cores need test benchs \r\n- we need more memory cores with different features \r\n- we need more people to test the cores on real hardware \r\n- You can download the memory codes from the CVS using the module name \"memory_cores\" and for new cores use module name \"memory_cores2\". \r\n- ", "\n        "]},
{"details": ["\n    Name: memory_sizer", "\n    Created: Dec 19, 2001", "\n    Updated: Dec 21, 2001", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            ", "The memory_sizer project is designed to automatically handle accesses to and from memory.  It does not handle refreshing DRAM at all, but it does automatically generate the cycles needed to fulfil a memory request by a processor.  For example, it can load 32-bit words from byte wide memory (if you want to boot from a single byte-wide flash chip, for instance).  Alternatively, it could load 16-bit words from byte wide memory.  It also handles loading and storing bytes from 32-bit wide memory and 16-bit memory, although the memory in this case must support the use of \"byte enables.\"  This is done dynamically, so that multiple widths of memory may be shared in the same address space.  Moreover, memory_sizer can load and store data using misaligned adresses (as does the power PC architecture!) which is a very difficult proposition, if you need to do misaligned accesses, because it involves splitting an access across the boundaries of the given memory.  The memory_sizer handles these misaligned accesses automatically.  Also, memory_sizer can do \"little endian\" or \"big_endian\" accesses.  A single input to the module determines which mode is used.", "One particularly nice feature of this block is that it is scalable in size by changing the parameters.  This means that if you want to generate accesses which are 64-bits wide, 128-bits wide, or even 256-bits wide, you may do so.  Simply change the appropriate parameters, and the memory_sizer module will produce the appropriate access cycles, with address and byte enables being generated automatically, for both loads and stores.  Of course, it will then consume more resources, there is no escaping that!", "If you wish to simplify this module, in order to save resources on your target chip, then simply tie the unused inputs to the desired state to constrain them, and the synthesis tools will \"optimize away\" the unneeded portions of the logic.  For instance, if you do not want little_endian/big_endian support, just tie that input to zero or one, and the resulting synthesis will take up less space, and run faster.", "The code is written in Verilog, and was sythesized into a Xilinx SpartanII XC2S200 chip.  Debugging was done in actual hardware, with an HP16500 series logic analyzer, and there is no simulation testbench for these modules.", "The design team of memory_sizer welcomes any kind of help and feedback on these cores.  If you are interested in further development of this project, please contact us.", "\n        ", "\n            "]},
{"details": ["\n    Name: hpdmc", "\n    Created: Oct 26, 2008", "\n    Updated: Aug 26, 2010", "\n        SVN Updated: Aug 26, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\r\n", "\r\nFast DDR SDRAM controller with features targeted at high-bandwidth burst-oriented applications such as live video processing. The core has been re-used by several projects and institutions, such as the NASA as part of a software-defined radio system for the ISS (CoNNeCT experiment).\n        ", "\n            - Current design is targeted at 32-bit wide DDR SDRAM.", "\r\n- Dedicated non-standard high-speed bus for efficient memory access (FML).", "\r\n- Pipelined accesses to hide DRAM latencies.", "\r\n- WISHBONE to FML bridge available with cache support.", "\r\n- FML arbiter with pipelining support available for high-speed DMA.", "\r\n- Fully synchronous controller (memory clock = controller clock) to avoid clock domain crossing latencies.", "\r\n- CSR bus interface for configuration.", "\r\n- Low level interface to the SDRAM chip is possible (\"bypass\" mode).", "\r\n- SDRAM initialization sequence performed by the system CPU to save hardware resources and maximize flexibility.", "\r\n- Timing parameters configured at runtime.", "\r\n- Page hit detection supports multiple open banks.", "\r\n- Automatic refresh with programmable refresh interval.", "\r\n\n        ", "\n            - ", "\r\n- ", "\r\n- ", "\r\n\n        "]},
{"details": ["\n    Name: generic_fifos", "\n    Created: Sep 24, 2002", "\n    Updated: Jan  5, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Generic, multi-purpose FIFOs. Available as single clock and dual clock version, binary, lfsr, and gray encoded (dual clock only). All are parameterizable and use generic_memories for memory. These FIFOs are fully portable from FPGAs to ASICS.\n        ", "\n            - Written in Verilog\r\n", "- Fully Synthesizable (FPGA & ASIC libraries)\r\n", "- Parameterized\r\n", "- Single and Dual Clock \r\n", "\r\n        ", "\n            - All FIFOs that are release are done. They have been simulated and most of them have been used in one way or another in one of my projects.  Some have been verified in real hardware.\r\n", "- October 2003, Added a dual clock FIFO that is gray code encoded (fully parameterizable)\n        ", "\n            To use this IP core, you must also download the generic_memories models. ", "\n        ", "\n            "]},
{"details": ["\n    Name: ddr3_sdram", "\n    Created: Oct 24, 2012", "\n    Updated: Jul  2, 2017", "\n        SVN: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The project files are checked in to SVN, available here:", "\r\n", "\n        ", "\n            This is a controller core for DDR3 SDRAM.", "\r\n", "\n            The testbench consists of a MicroBlaze MCS microcontroller with one module of glue logic to adapt it to the DRAM controller.", "\r\nThe glue logic module multiplexes the 256 bit data busses of the DRAM controller down to the 32 bit data busses of the MicroBlaze MCS.", "\r\nThe MB MCS only has 1GB of address space available in its IO port interface and the DRAM controller supports DIMMS of up to 8GB.  The glue logic accounts for this by using a GPIO port from the MB MCS to provide the high order address bits, allowing SW running on the MB MCS to use a bank switching scheme to fully access DIMMS larger than 1GB.", "\r\n", "\r\n\n        "]},
{"details": ["\n    Name: ddr2_sdram", "\n    Created: Aug 20, 2011", "\n    Updated: Jun  3, 2012", "\n        SVN Updated: Jun  3, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project implements a DDR2-SDRAM Controller on a Xilinx Spartan-3A Board\n        ", "\n            ", "\n        ", "\n            After a Power on :\r\n", "==================\r\n", "\r\n", "1. Init-Sequenz for the RAM\r\n", "2. Automaic Write-Sequenz (writes 16 Datawords each 64Bit to the RAM)\r\n", "3. Automatic Read-Sequenz (reads the first Dataword from the RAM)\r\n", "4. Display the Dataword at the 8Bit LEDs\r\n", "\r\n", "\r\n", "Switch-0 :\r\n", "==========\r\n", "\r\n", "> SW0 is used as a Reset-Switch\r\n", "\r\n", "\r\n", "Switch-1 to 3 :\r\n", "===============\r\n", "\r\n", "> SW1 to SW3 selects witch part of the Dataword\r\n", "  is shown at the LEDs\r\n", "\r\n", "\r\n", "Button north :\r\n", "==============\r\n", "\r\n", "> increments the Adresspointer\r\n", "\r\n", "\r\n", "Button south :\r\n", "==============\r\n", "\r\n", "> decrements the Adresspointer\r\n", "\r\n", "\r\n", "Button east :\r\n", "=============\r\n", "\r\n", "> reads a single Dataword (64Bit) from the actual adress\r\n", "\r\n", "\r\n", "Button west :\r\n", "=============\r\n", "\r\n", "> writes a fixed Dataword (64Bit) to the actual adress\r\n", "\r\n", "\r\n", "Status LED :\r\n", "============\r\n", "\r\n", "> LED is permanent blinking\n        ", "\n            Plattform :     XILINX Spartan-3A\r\n", "FPGA :          XC3S700A-FGG484\r\n", "Language :      VHDL\r\n", "ISE :\t\tISE-Design-Suite V:13.1\r\n", "IP-Core :\tMIG V:3.6.1\r\n", "DDR2-SDRAM :\tMT47H32M16 (64 MByte)\n        ", "\n            Burst Length = 4\r\n", "Data Width = 16 Bit\r\n", "\r\n", "> with these settings each Data access reads (and writes)\r\n", "  a 64Bit Dataword (4 x 16 Bit)\n        ", "\n            Read :\r\n", "======\r\n", "\r\n", "> to Read one Dataword (64Bit)\r\n", "  22 Clockzycles are needed\r\n", "\r\n", "Write :\r\n", "=======\r\n", "\r\n", "> to Write one Dataword (64Bit)\r\n", "  25 Clockcycles are needed\n        ", "\n            20.08.2011 : Version 7.0 : Project start\n        "]},
{"details": ["\n    Name: ddr_sdr", "\n    Created: Dec 20, 2002", "\n    Updated: Jan 12, 2018", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The ddr_sdr controls read and write access of a programmable \r\n", "logic device to a single 256 Mbit memory device. The 32-bit \r\n", "wide user interface basically accepts two commands, read or \r\n", "write. The control logic initializes the memory after reset \r\n", "and issues refresh commands from time to time to ensure data \r\n", "integrity. The data width to the memory device is 16 bits \r\n", "wide and performs a double data rate operation at 100 MHz \r\n", "clock rate.\r\n", "\n        ", "\n            - Version 1.0 available\n        "]},
{"details": ["\n    Name: cf_interleaver", "\n    Created: Apr  1, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nMemory interleavers are common components often found in signal processing applications.  They are useful for buffering and reordering data and typically form the separation between design stages.  Interleavers can be used for:\r\n\r\n- Transposing Images for Image Processing\r\n- Buffering Noncontinuous Input Data \r\n- Data Shuffling Between FFT Ranks\n        ", "\n            The memory interleaver consists of 2 interleaving memories: one memory loads input data, while the other dumps output data -- On a swap signal the 2 memories switch roles.\r\n", "\r\n", "The interface to an interleaver is:\r\n", "- Inputs\r\n", "  - clock : Main clock.\r\n", "  - swap : Pulse to swap memories (input become output, output becomes input).\r\n", "  - write : Write enable to input memory.\r\n", "  - addr : Address to input memory.\r\n", "  - data : Data to input memory.\r\n", "- Outputs\r\n", "  - sync_primary : Pulse to indicate an interleaver swap.\r\n", "  - sync_secondary : Pulse to indicate address 0 is output.\r\n", "  - data : Data dumped from output memory.\r\n", "\r\n", "Input data to the interleaver is addressable.  Output data is dumped one memory location after another starting at address 0.\r\n", "\r\n", "Each file is stand-alone and represents a specific configuration. \r\n", "The 2 configuration parameters are: \r\n", "- Address Width (Memory Depth)\r\n", "- Data Width\r\n", "\r\n", "The configuration parameters are coded in the file names: cf_interleaver_8_32.v \r\n", "- 8 : Address Width \r\n", "- 32 : Data Width\r\n", "\r\n", "Current configurations: \r\n", "- cf_interleaver_6_8\r\n", "- cf_interleaver_7_8\r\n", "- cf_interleaver_8_8\r\n", "- cf_interleaver_9_8\r\n", "- cf_interleaver_10_8\r\n", "- cf_interleaver_11_8\r\n", "- cf_interleaver_12_8\r\n", "- cf_interleaver_6_16\r\n", "- cf_interleaver_7_16\r\n", "- cf_interleaver_8_16\r\n", "- cf_interleaver_9_16\r\n", "- cf_interleaver_10_16\r\n", "- cf_interleaver_11_16\r\n", "- cf_interleaver_12_16\r\n", "- cf_interleaver_6_32\r\n", "- cf_interleaver_7_32\r\n", "- cf_interleaver_8_32\r\n", "- cf_interleaver_9_32\r\n", "- cf_interleaver_10_32\r\n", "- cf_interleaver_11_32\r\n", "- cf_interleaver_12_32\r\n", "- cf_interleaver_6_64\r\n", "- cf_interleaver_7_64\r\n", "- cf_interleaver_8_64\r\n", "- cf_interleaver_9_64\r\n", "- cf_interleaver_10_64\r\n", "- cf_interleaver_11_64\r\n", "- cf_interleaver_12_64\n        "]},
{"details": ["\n    Name: brsfmnce", "\n    Created: Aug 11, 2013", "\n    Updated: Nov  1, 2013", "\n        SVN Updated: Aug 14, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This module implements a synchronous FIFO using Block RAM resources such as those found in SRAM-based FPGAs. This module has been used in several products/projects based on Xilinx Spartan 3AN FPGAs. It can be adapted to other development environments and FPGAs, but only Xilinx ISE and Xilinx Spartan 3A/3AN FPGAs has been used to date.\r\n", "\r\n", "All components used in this module are inferred, including the Block RAM. This allows the depth and width to be set by parameters. Furthermore, the state of the memory, the write pointer, and FIFO flags can be initialized. This allows FIFO to be preconditioned with a copyright notice, configuration data, etc.\n        ", "\n            The BRSFmnCE has been used in several projects/products. It is generally used as a deep FIFO for UARTs. The following synthesis and Map/PAR results effectively summarize the resource utilization of the BRSFmnCE in a XC3S200A-4VQG100I FPGA. This FPGA is not the only one in which BRSFmnCE has been used, but it allows the characterization of the resource requirements of the BRSFmnCE.\r\n", "\r\n", "\r\n", "Number of Occupied Slices: 30\r\n", "Number of Slice FFs:       35\r\n", "Number of 4-input LUTs:    32\r\n", "Number of RAMB16BWE:        1\r\n", "\r\n", "Reported Speed (Synthesizer): 167 MHz\r\n", "Reported Speed (MAP/PAR):     187 MHz         \n        "]},
{"details": ["\n    Name: yadmc", "\n    Created: Aug  1, 2008", "\n    Updated: Aug  7, 2010", "\n        SVN Updated: Aug  7, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "Please do not ask me about this core! It is old and totally unsupported. HPDMC support, however, is available from the ", " mailing list.\n        "]},
{"details": ["\n    Name: sdr_ctrl", "\n    Created: Jan  3, 2012", "\n    Updated: Jun 17, 2014", "\n        SVN Updated: Jun 17, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Feature:\r\n", "\u2022 8/16/32 Configurable SDRAM data width\r\n", "\u2022 Wish Bone compatible\r\n", "\u2022 Application clock and SDRAM clock can be async\r\n", "\u2022 Programmable column address\r\n", "\u2022 Support for industry-standard SDRAM devices and modules\r\n", "\u2022 Supports all standard SDRAM functions\r\n", "\u2022 Fully Synchronous; All signals registered on positive edge of system clock\r\n", "\u2022 One chip-select signals\r\n", "\u2022 Support SDRAM with four bank\r\n", "\u2022 Programmable CAS latency\r\n", "\u2022 Data mask signals for partial write operations\r\n", "\u2022 Bank management architecture, which minimizes latency\r\n", "\u2022 Automatic controlled refresh\r\n", "\u2022 Static synchronous design\r\n", "\u2022 Fully synthesizable\r\n", "\n        ", "\n            ", "\n        ", "\n            ", "\n        ", "\n            Stable RTL ver 0.1 is available\n        ", "\n            1. Design and implementation language used in the IP\r\n", " Design implementation is done Verilog and System verilog language\r\n", "\r\n", "2. What are the SDRAM Bus width are supported by the IP?\r\n", " This IP Supports 8/16/32 Bit interface\r\n", "\r\n", "3. What are the Application Bus width are supported by the IP?\r\n", "  This IP Supports only 32 bit Application Bus width\r\n", "\r\n", "4. Can Application clock and SDRAM clock be Asynchronous to each other?\r\n", " Yes, IP support both Synchronous and Asynchronous Application clock and SDRAM clock\r\n", "\r\n", "5.Is the application layer is compatible to wish-bone standard?.\r\n", " Yes, Application Layer is wishbone compatible.\r\n", "\r\n", "6.Is SDRAM cores is also available with custom interface?\r\n", " Yes. SDRAM core is separately available with automated test-bench.\r\n", "\r\n", "7.Test bench scripts are compatible to which tool?\r\n", " Verification scripts are compatible to model simulator\r\n", "\n        "]},
{"details": ["\n    Name: mytwoqcache", "\n    Created: Oct 26, 2012", "\n    Updated: Nov 26, 2012", "\n        SVN Updated: Nov 26, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            I implemented 2Q cache strategy from paper \"2Q:  A Low Overhead High Performance Buffer Management Replacement Algorithm\" written by Theodore Johnson and Dennis Shasha. It is written in VHDL and supports my FORTH-processor, which runs on a Spartan 3A DSP board from Xilinx. I think it can be adapted for other processors easily.\r\n", "\r\n", "parameters, user defineable:\r\n", "- blocksizeld   ld of size of tagram\r\n", "- ldways        ld of number of tagrams (n-way associative)\r\n", "- ldcachedwords ld of number of 32-bit words in one cacheline\r\n", "\r\n", "defineable too:\r\n", "- ldram            ld of depth of cacheram\r\n", "- ldqueuelength    ld of depth of fifo (2Q strategy)\r\n", "\r\n", "YOU have to redefine subtype RAMrange in global.vhd:\r\n", "As example, Your RAM is 128 MB then\r\n", " subtype RAMrange     is natural range 26 downto 0;\n        "]},
{"details": ["\n    Name: sdram_16bit", "\n    Created: Jul 12, 2015", "\n    Updated: Jul 20, 2015", "\n        SVN Updated: Jul 13, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This IP core is that of a small, simple SDRAM controller used to provide a 32-bit pipelined Wishbone interface to a 16-bit SDRAM chip.\r\n", "\r\n", "When accessing open rows, reads and writes can be pipelined to achieve full SDRAM bus utilization, however switching between reads & writes takes a few cycles.\r\n", "\r\n", "The row management strategy is to leave active rows open until a row needs to be closed for a periodic auto refresh or until that bank needs to open another row due to a read or write request.\r\n", "\r\n", "This IP supports supports 4 open active rows (one per bank).\n        ", "\n            Verified under simulation against a couple of SDRAM models and on the miniSpartan6+ board which features the AS4C16M16S.\r\n", "\r\n", "The supplied testbench works with the free version of Modelsim.\r\n", "\r\n", "Test project for the miniSpartan6+:\r\n", "\r\n", "\r\n", "\n        ", "\n            SDRAM_MHZ - Clock speed (verified with 50MHz & 100MHz)\r\n", "SDRAM_ADDR_W - Total SDRAM address width (cols+rows+banks)\r\n", "SDRAM_COL_W - Number of column bits\r\n", "SDRAM_READ_LATENCY - Read data latency (use 3 for 100MHz, 2 for 50MHz)\r\n", "SDRAM_TARGET - Target XILINX or SIMULATION\n        ", "\n            With the default configuration...\r\n", "\r\n", "- the design contains 184 flops.\r\n", "- synthesizes to > 160MHz on Xilinx Spartan 6 LX9 (speed -3)\r\n", "- can hit up-to 92% of maximum bus rate for sequential accesses taking into account row open/close and refreshes.\n        "]},
{"details": ["\n    Name: srdydrdy_lib", "\n    Created: Dec 22, 2009", "\n    Updated: Apr 20, 2013", "\n        SVN Updated: May 11, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            The srdy-drdy library provides a group of components all built around a common data-transfer protocol.  This protocol is used in datapath applications and provides bidirectional flow control.\r\n", "\r\n", "Components in the library provide basic timing closure, clock domain crossing, basic and advanced buffering, and some arbitration and specialized components.  The components in the library have been used in multiple successful tape-outs and FPGA designs.\n        "]},
{"details": ["\n    Name: rng_lib", "\n    Created: Sep  2, 2004", "\n    Updated: Jan 14, 2016", "\n        SVN Updated: Jan 14, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This library has functions for generating good quality random numbers in a VHDL testbench environment. The functions will NOT synthesize.\n        ", "\n            - Based on a combination of 3 Tausworthe generators.\r\n", "- Distributions:\r\n", "  - Uniform (continous)\r\n", "  - Gaussian (continous)\r\n", "  - Exponential (continous)\r\n", "- For use in test benches\n        ", "\n            - Version 1.0 released.\r\n", "\n        "]},
{"details": ["\n    Name: openverifla", "\n    Created: Jul 31, 2007", "\n    Updated: Mar  3, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n                openVeriFLA is an FPGA integrated logic analyzer.\r\n", "It can be used for in-circuit debugging and verification\r\n", "of the FPGA based applications.\r\n", "The FPGA part is written in verilog. The PC part \r\n", "is written in java and is platform independent.\r\n", "    Being simple and well documented, the openVeriFLA library\r\n", "is well suited for didactical purposes and academic use.\r\n", "\r\n", "    For more information, please unzip the project archive\r\n", "and read the reference manual.\r\n", "\n        ", "\n            - on-the-fly capture, graphical display, testing automation\n        ", "\n            - ready to use\n        ", "\n            FILE: verifla_keyboard_protocol_verification_50procent.jpg\r\n", "DESCRIPTION: The FPGA capture of a keyboard controller signals\n        "]},
{"details": ["\n    Name: gh_vhdl_library", "\n    Created: Sep  4, 2005", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Perhaps more of a collection of part than a true library, this is a set of VHDL parts that may be used as a set of building blocks for larger designs.\r\n", "\n        ", "\n            counters, shift registers, pulse stretchers (high, low, and programmable) and other MSI parts\r\n", "six fixed length LFSR's (24, 36, 48, 64 bits and two that are set with Generics)\r\n", "two Programmable length LFSR's\r\n", "clocked delay lines (fixed and programmable)\r\n", "control registers (individual bits may be set, cleared, or inverted)\r\n", "GPIO\r\n", "Pulse Generator\r\n", "Burst Generator\r\n", "Parity generator\r\n", "Sweep Generator\r\n", "CIC filter\r\n", "NCO's (some using a CORDIC, others using a Look up tables)\r\n", "CORDIC (with 20 bit or 28 bit atan function)\r\n", "(-)Sin/Cos look-up tables (12 bit, 14 bit, and 16 bit) \r\n", "baud rate generator\r\n", "FIR Filters (Serial and parallel - most with generics, some that do not use multipliers)\r\n", "three MAC's (Multiply Accumlator - one with generics)\r\n", "TVFD filter\r\n", "FIFO's (sync and async)\r\n", "Dual port RAM (1 write port, 2 read ports) \r\n", "Four byte dual port RAM (2nd port of 32, 16, or 8 bits)\r\n", "FASM RAM (Synchronous write port, Asynchronous read port(s))\r\n", "\r\n", "Random Number Generator \r\n", "Random number scaler (2)\r\n", "\r\n", "Six \u201cIn place\u201d Multipliers\r\n", "      (two with two signed inputs, two with two unsigned inputs, \r\n", "        and two with both- a signed input and an unsigned input\r\n", "        two of those have all bits on output)\r\n", "\r\n", "Complex adder, multipliers\r\n", "digital attenuator\r\n", "\r\n", "VMEbus Slave interface Modules (A32D32,A24D16,A16D16)\r\n", "\r\n", "Pulse Width Modulator\r\n", "\r\n", "\n        ", "\n            Waiting for suggestions  \r\n", " \r\n", "\n        "]},
{"details": ["\n    Name: extension_pack", "\n    Created: Jan  6, 2006", "\n    Updated: Oct 25, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This project contains files you can use to expand upon the basic IEEE packages you normally use for creating testbenches and RTL code.\n        ", "\n            automatic count stop/start value generation functions.  You enter a time duration and clock frequency and the value is automatically computed.  Your choice of binary or LFSR number spaces.\r\n", "\r\n", "LFSR counters created by function call.\r\n", "\r\n", "clock generation procedures\r\n", "\r\n", "type and number conversion functions:\r\n", "\r\n", "synthesizable binary_to_BCD and BCD_to_binary functions\r\n", "synthesizable BCD_to_seven_segment display functions\r\n", "string value to std_logic_vector: \"32\"  ->  \"0100000\"\r\n", "\n        ", "\n            Production Ready.  Please let me know of ANY problems you find.\n        ", "\n            VHDL Library\r\n", "\n        "]},
{"details": ["\n    Name: cde", "\n    Created: Aug 16, 2013", "\n    Updated: Aug 17, 2013", "\n        SVN Updated: Aug 17, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Common Design Environment (CDE) is a library of modules that usually require replacement with specific hard \r\n", "macros when the design is retargeted to a IC process. By using modules from the CDE library it will be possible\r\n", "to easily make this substitution with an ip-Xact enabled tool flow without having to touch the original rtl code.\r\n", " \n        "]},
{"details": ["\n    Name: viterbi_decoder_axi4s", "\n    Created: Jan 16, 2012", "\n    Updated: Apr 16, 2015", "\n        SVN Updated: Feb 17, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 8 reported / 7 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            A fully configurable VHDL Viterbi decoder compliant with the AXI4-Stream interface.\r\nMost standards using convolutional codes like Wifi or GSM are easy to implement by configuring some generic parameters.\r\nThe decoder supports a high throughput even on low-cost devices.\r\nSee the ", " for more information about the core.\n        ", "\n            ", "\n            ", "\n            ", "\r\nComparison for Viterbi communications performance in various standards.", "\r\nFrame length is set to 400, while the LLR input bit length is 4 and no windowing is used.\n        ", "\n            Creonic GmbH - Germany ", "\r\nSite: www.creonic.com", "\r\nTel: +49 631 3435988-0\n        "]},
{"details": ["\n    Name: ultimate_crc", "\n    Created: May  5, 2005", "\n    Updated: Jan 14, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 6 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Ultimate CRC is a CRC generator/checker. Using generics the core can be fully customized. It creates a function of the data input and the CRC register using XOR-logic. Although the levels of logic gets very high for wide data inputs, the throughput still benefits from this architecture, as can be seen from the synthesis page.\r\n", "\n        ", "\n            ", "\n            Revision 1.0 released.\n        "]},
{"details": ["\n    Name: rs_dec_enc", "\n    Created: Feb  1, 2010", "\n    Updated: Feb  2, 2010", "\n        SVN Updated: Feb  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nThis core implements Reed-Solomon decoder for the 8-bit wide symbols. The core is designed to occupy fewer amounts of logic blocks, be fast and parametrizable.\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: rs_decoder_31_19_6", "\n    Created: Feb  7, 2006", "\n    Updated: Dec  1, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            -  Hard-decision decoding scheme\r\n", "-  Codeword length (n) : 31 symbols\r\n", "-  Message length (k) : 19 symbols\r\n", "-  Error correction capability (t) : 6 symbols\r\n", "-  One symbol represents 5 bit\r\n", "-  Uses GF(2^5) with primitive polynomial p(x) = X^5 + X^2 + 1\r\n", "-  Generator polynomial, g(x) = a^15 + a^21*X + a^6*X^2 + a^15*X^3 + a^25*X^4 + a^17*X^5 + a^18*X^6 + a^30*X^7 + a^20*X^8 + a^23*X^9 + a^27*X^10 + a^24*X^11 + X^12.  Note: a = alpha, primitive element in GF(2^5) and a^i is root of g(x) for i = 19, 20, ..., 30\r\n", "-  Uses Verilog description with synthesizable RTL modelling\r\n", "-  Consists of 5 main blocks: SC (Syndrome Computation), KES (Key Equation Solver), CSEE (Chien Search and Error Evaluator), Controller and FIFO Register\r\n", "\n        ", "\n            -  High speed decoding algorithm.\r\n", "-  Can output corrected received word while input new received word.\r\n", "-  Synchronous timing.\r\n", "-  dataoutstart (start of output data block) and dataoutend (end of output data block) signal to synchronize to other core outside the decoder.\r\n", "-  Have decoding failure flag if error is uncorrectable.\n        ", "\n            - design has been simulated successfully\r\n", "- uploaded v1.0\r\n", "- Please do not send me email asking about all aspects of Reed-Solomon encoder-decoder (algorithms, architectures, implementation, simulation problems, etc.), since I do not provide any kind of technical supports. You can still freely download the source code though.\r\n", "\n        "]},
{"details": ["\n    Name: reed_solomon_codec_generator", "\n    Created: Jul 21, 2011", "\n    Updated: Jan 19, 2017", "\n        SVN Updated: Jul 28, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            "]},
{"details": ["\n    Name: rsencoder", "\n    Created: Jun 26, 2004", "\n    Updated: Sep 10, 2015", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            - RTL done and design verified using testbench.\r\n", "- Will upload soon.\r\n", "- June 27th 2004, updated. Please click on 'Downloads' (top right on this page).\r\n", " - June 29 2004, There was a typo in reed_solomon.v file.  The output ports d0, d1, d2, d3 actually refer to q0, q1, q2, q3 (see readme.txt file). Sorry for the confusion. Corrected now. \n        ", "\n              -  User defined generator polynomial.  \r\n", "  -  Allows experimentation with diferent generator polynomials for best implementation.\r\n", "  -  Replacable Galois field multiplier submodule for a different primitive polynomial.\r\n", "  -  Can be used for shortened codes.\r\n", "  -   Achieved > 200MHZ ( = 1.6 Gbps) on  Altera's Stratix FPGA.   \r\n", "   \r\n", " \n        ", "\n            Reed Solomon Encoder synthesizable IP core compatible with G709, DVB1, DVB2 standards. Implements (n, k) code where n-k = 16 ( 8 byte error correction capable code). The verilog is written in such a way as to be easily parameterized for different values of n and k. If there is any interest for parameterization, let me know and  I will create a version 2 core. Otherwise the core \"as is\" can be used to implement for example, a (255, 239) or (204, 188) codes. The underlying galois field is GF(2^8)   with primitive polynomial,  x^8+x^4+x^3+x^2+1.  \n        "]},
{"details": ["\n    Name: reed_solomon_decoder", "\n    Created: Jul  5, 2009", "\n    Updated: Nov 23, 2009", "\n        SVN Updated: Apr 11, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            \u2022 Reed Solomon Decoder (204,188), with T=8.\r\n", "\u2022 Input codeword length is 204 bytes and output length is 188 bytes.\r\n", "\u2022 Corrects up to 8 byte errors per input codeword.\r\n", "\u2022 Code generator polynomial: (x + \u03bb) (x + \u03bb^2) (x + \u03bb^3) ... (x + \u03bb^16).\r\n", "\u2022 Field generator polynomial: x^8+ x^4+ x^3+ x^2+1.\r\n", "\u2022 This version of the Reed Solomon core is distributed under the GPL license.\r\n", "   An optimized and considerably more advanced version, which may be\r\n", "   customized on request for different code generator polynomials, is\r\n", "   available under a commercial license.\r\n", "\r\n", "\n        ", "\n            \u2022 Design estimated Gate count is 52,400 gates and total memory bits are 12,432 bits.\r\n", "\r\n", "\u2022 Synthesis Results on Xilinx Spartan 3A DSP:\r\n", "\r\n", "     o Number of occupied slices:             3,397/23,872 (14%).\r\n", "     o Best achievable clock is               12.084 ns.\r\n", "     o Total block RAMs RAMB16BWERs: 11/126 (8%).\r\n", "\r\n", "\u2022 Synthesis Results on Altera Stratix III L150F1152C2:\r\n", "\r\n", "     o Logic utilization              5 %.\r\n", "     o Combinational ALUTs             3,372 / 113,600 (3 %).\r\n", "     o Memory ALUTs                    256 / 56,800 (     o Dedicated logic registers: 2,935 / 113,600 (3 %).\r\n", "     o Total block memory bits         12,432 / 5,630,976 (     o Best achievable clock is        3.977 ns.\r\n", "\n        ", "\n            o Verilog RTL files.\r\n", "o Simulation test bench.\r\n", "o MATLAB script to generate test vectors.\r\n", "\n        ", "\n            Varkon Semiconductors\r\n", "Tel:   1-732-447-8611\r\n", "Web Site: varkonsemi.com\r\n", "\n        "]},
{"details": ["\n    Name: pci_express_crc", "\n    Created: Dec  8, 2007", "\n    Updated: Dec 17, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Functional Description\r\n", "\r\n", "Designers commonly use Cyclic Redundacy Codes (CRC) as an alternative to parity and checksum calcutions for checking and correcting errors in data transmissions.\r\n", "\r\n", "The CRC method for error detection and correction treats the data frame as a huge binary number.  The binary number is divided (at the CRC generation end) by a fixed binary number (the CRC generator polynomial)  and the resulting remainder of this division (CRC value) is appended to the end of the data frame.  The receiver upon reception of the data frame repeats the calculation and compares its calculated CRC value the CRC value attached to the data frame.  The traditional method for implementing a CRC generator uses a shift register with XOR gates and feedback taps.\r\n", "\r\n", "The classic serial implementation is widely used, but it is too slow for PCI Express LCRC and Gigabit Ethernet where bit rates can top 100 Mb/sec.  The alternative method is parallel CRC calculations.  This parallel conversion effectively divides the input clock frequency by 8, 16, or 32.\r\n", "\n        ", "\n            -feature1\t             Verilog LCRC code for PCI Express TLP packets\r\n", "-reature1.1\t16 bit data in 32 bit LCRC out\r\n", "\n        "]},
{"details": ["\n    Name: cf_ldpc", "\n    Created: May 13, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nThe core is provided in Verilog, Vhdl, C, and Python.\r\n\r\nLow-density parity-check (LDPC) codes are forward error correction codes invented by Robert Gallager in the early 60's.  LDPC codes have record breaking error correction performance and approach Shannon's limit for channel capacity.\n        ", "\n            This LDPC error corrector implements Gallager's \"A\" algorithm: an iterative, hard-decision decoder that opts for simplicity over performance.  The architecture elaborates all logic required to implement the message-passing algorithm from message nodes, to check nodes, then back to message nodes -- one iteration occurs every clock cycle.\r\n", "\r\n", "The core is primarily meant as an LDPC evaluation platform, as the fully parallel architecture may be inappropriate for synthesis of large block length LDPC decoders.\r\n", "\r\n", "The Confluence source code generates an LDPC error corrector given an arbitrary parity-check matrix.  This core implements Gallager's (20, 3, 4) parity-check matrix:\r\n", "\r\n", "1 1 1 1 . . . . . . . . . . . . . . . .\r\n", ". . . . 1 1 1 1 . . . . . . . . . . . .\r\n", ". . . . . . . . 1 1 1 1 . . . . . . . .\r\n", ". . . . . . . . . . . . 1 1 1 1 . . . .\r\n", ". . . . . . . . . . . . . . . . 1 1 1 1\r\n", "1 . . . 1 . . . 1 . . . 1 . . . . . . .\r\n", ". 1 . . . 1 . . . 1 . . . . . . 1 . . .\r\n", ". . 1 . . . 1 . . . . . . 1 . . . 1 . .\r\n", ". . . 1 . . . . . . 1 . . . 1 . . . 1 .\r\n", ". . . . . . . 1 . . . 1 . . . 1 . . . 1\r\n", "1 . . . . 1 . . . . . 1 . . . . . 1 . .\r\n", ". 1 . . . . 1 . . . 1 . . . . 1 . . . .\r\n", ". . 1 . . . . 1 . . . . 1 . . . . . 1 .\r\n", ". . . 1 . . . . 1 . . . . 1 . . 1 . . .\r\n", ". . . . 1 . . . . 1 . . . . 1 . . . . 1\n        "]},
{"details": ["\n    Name: hamming_gen", "\n    Created: Oct 27, 2006", "\n    Updated: Mar 21, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 7 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This C++ program generates VHDL package with hamming encoder and decoder. It also generates a simple testbench that can be used to evaluate the generated Hamming code.\r\n", "\r\n", "my email is ale_amory@opencores.org\n        ", "\n            - It is a easy to use command-line program \r\n  - HammingGen \\ \\ \\\r\n- It generates two types of Hamming code\r\n  - SEC - Single Error Correction\r\n  - SEC-DED - Single Error Correction and Dual Error Detection\r\n- It is easy to modify the original design\r\n\r\n\r\n\n        ", "\n            Generated Code for a Hamming SEC with 32 bits\r\n\r\n- FUNCTION hamming_encoder_32bit(data_in:data_ham_32bit) RETURN parity_ham_32bit;\r\n- FUNCTION hamming_decoder_32bit(data_parity_in:coded_ham_32bit) RETURN data_ham_32bit;\r\n\r\nConsider the folowing resgister description\r\n\r\n", " ieee;\r\n", " ieee.std_logic_1164.all;\r\n\r\n", " test ", "\r\n  ", " (\r\n    datain   : ", "  std_logic_vector(15 ", " 0);\r\n    clock    : ", "  std_logic;\r\n    dataout  : ", " std_logic_vector(15 ", " 0);\r\n    error    : ", " std_logic_vector(1 ", " 0)\r\n  );\r\n", ";\r\n\r\n", " test ", " test ", "\r\n  ", " temp   : std_logic_vector(15 ", " 0);\r\n\r\n", "\r\n\r\n  ", "(clock)\r\n  ", "\r\n    ", " (clock'event and clock='1') ", "\r\n      temp end if;\r\n  ", ";\r\n\r\n  dataout end architecture;\r\n\r\n\r\nThe fault-tolerant version of this code is:\r\n\r\n", " ieee;\r\n", " ieee.std_logic_1164.all;\r\n", " WORK.", ".all;\r\n\r\n", " test ", "\r\n  ", " (\r\n    datain   : ", "  std_logic_vector(15 ", " 0);\r\n    clock    : ", "  std_logic;\r\n    dataout  : ", " std_logic_vector(15 ", " 0);\r\n    error    : ", " std_logic_vector(1 ", " 0)\r\n  );\r\n", ";\r\n\r\n", " test ", " test ", "\r\n  ", " temp   : ", ";\r\n\r\n", "\r\n\r\n  ", "(clock)\r\n  ", "\r\n    ", " (clock'event and clock='1') ", "\r\n      temp ", ";\r\n    ", ";\r\n  ", ";\r\n\r\n  dataout ", ";\r\n  \r\n", ";\r\n\n        ", "\n            - Support correction of more than one faults\n        "]},
{"details": ["\n    Name: gppd", "\n    Created: May 11, 2012", "\n    Updated: May 11, 2012", "\n        SVN Updated: May 11, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a behavioral SystemC model for Polyphase Decimation filters. It can be used as for system design and functional verification. It has been tested with Matlab and Octave as well. If you need any further illustrations or further modifications, don't hesitate to contact me. It can be used effectively for class instruction. It is a good practice for SystemC beginners and DSP student/engineers as well.\r\n", "\r\n", "Feel free to contact me whenever you have further requests or comments.\r\n", "\n        "]},
{"details": ["\n    Name: ldpc_decoder_802_3an", "\n    Created: Feb 20, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            LDPC decoder for 10GBase-T Ethernet (802.3an), based on Gallager's A algorithm.  See also ", " (802.3an LDPC Encoder).\n        ", "\n            FILE: ldpc_decoder_802_3an.tar.gz\n", "DESCRIPTION: Verilog 802.3an LDPC Decoder and Testbench\n", "\n        "]},
{"details": ["\n    Name: ldpc_encoder_802_3an", "\n    Created: Feb 16, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            LDPC Encoder for 10GBase-T Ethernet (802.3an).  See also ", " (802.3an LDPC Decoder).\n        ", "\n            FILE: ldpc_encoder_802_3an.v.gz\r\n", "DESCRIPTION: Verilog 802.3an LDPC Encoder\r\n", "\n        "]},
{"details": ["\n    Name: viirf", "\n    Created: Jun  5, 2017", "\n    Updated: Jun  5, 2017", "\n        SVN Updated: Nov 28, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            This project comprises the VHDL description and configuration script of a configurable IIR filter. \r\n", "\r\n", "The VIIRF can implement any transfer function (highpass, lowpass etc.) that can be represented as a cascade of second-order sections (SOS), which is an numerically very stable form of implementation. \r\n", "\r\n", "The configuration script takes the (floating-point) SOS-matrix (and gain-matrix G, if required) and configures the (quantized) filter. It also simulates a step-response and generates testbench-files. \r\n", "\r\n", "No vendor-specific language constructs (e.g., Block-RAM or DSP-cores) are used, such that the filter is usable in any development environment. \r\n", "\r\n", "The sources and documentation are hosted at GitHub:\r\n", "\n        "]},
{"details": ["\n    Name: qo", "\n    Created: Aug 26, 2009", "\n    Updated: Jun  8, 2014", "\n        SVN Updated: Jun  8, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project is a digital signal processing (DSP) implementation of a circuit that provides periodic samples of both sine and cosine waveforms.  Technically, it is called a \"discrete-time discrete-amplitude binary recursion oscillator.\"  Although that description sounds complex, the operation of the circuit is not complicated.  This particular implementation uses a multiplier and an adder, and can be configured to produce sine/cosine output at the desired frequency and with the specified number of bits per sample.\r\n", "\r\n", "The sine and cosine outputs represent the projections of a rotating vector, or complex phasor if you like, along the real and imaginary axes of a 2-dimensional Cartesian coordinate space.  The vector is rotated a fixed amount with each new sample.  Is this just as clear as mud?\r\n", "\r\n", "Well, it does take some multipliers to implement the rotation matrix, but otherwise, it's a fairly quick implementation...\r\n", "\r\n", "The number of samples per cycle is given as a generic quantity, and the initial values for the vector are zero for sin_o, and +1 for cos_o.  The numerical quantities are represented as signed 2's complement numbers, in Q1.(AMPL_BITS-1) notation.\r\n", "\r\n", "The frequency of the oscillator has been fixed at the lowest possible value. The intention is that by varying the sample rate, sine and cosine waves of different frequencies can be produced.  For example, if the system clock is at 50 MHz, and SAMPLES_PER_CYCLE=1000, then it should be possible to create output at 50 kHz by setting the clk_en_i input to '1'.  For lower frequencies, just provide a stream of clock enable pulses at the appropriate rate.\r\n", "\r\n", "This VHDL code has been tested via simulation, and synthesis in actual hardware.  The rounding technique used in this module did not keep the output amplitude from decaying, so a once-per-cycle \"amplitude reset\" is included to ensure that the output is stable over time.\r\n", "\n        "]},
{"details": ["\n    Name: pipelined_fft_64", "\n    Created: Jan  5, 2010", "\n    Updated: Feb 25, 2010", "\n        SVN Updated: Jan 27, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nPipelined FFT/IFFT 64 points IP core is a unit to perform the Fast Fourier Transform (FFT). It performs one dimensional 64 \u2013 complex point FFT. The data and coefficient widths are adjustable in the range 8 to 16.\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: pipelined_fft_128", "\n    Created: Feb  1, 2010", "\n    Updated: Feb  2, 2010", "\n        SVN Updated: Feb  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nPipelined FFT/IFFT 128 points IP core is a unit to perform the Fast Fourier Transform (FFT). It performs one dimensional 128 \u2013 complex point FFT. The data and coefficient widths are adjustable in the range 8 to 16.\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: pipelined_fft_256", "\n    Created: Feb  1, 2010", "\n    Updated: Jul 30, 2014", "\n        SVN Updated: Feb  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nPipelined FFT/IFFT 256 points IP core is a unit to perform the Fast Fourier Transform (FFT). It performs one dimensional 256 \u2013 complex point FFT. The data and coefficient widths are adjustable in the range 8 to 16.\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: lp_iir_filter", "\n    Created: Feb  1, 2010", "\n    Updated: Feb  2, 2010", "\n        SVN Updated: Feb  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nLow-Pass IIR Filter IP core is a unit to perform the Infinite Impulse Responce (IIR) low pass filter which pass frequency is tuned dynamically\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: pid_controller", "\n    Created: Jul 10, 2012", "\n    Updated: Feb  3, 2015", "\n        SVN Updated: Dec 26, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The PID controller IP core performs digital proportional\u2013integral\u2013derivative controller (PID controller) algorithm. The algorithm first calculates the error between a measured value (PV) and its ideal value (SP), then use the error as an argument to calculate the manipulate value(MV). The MV will adjust the process to minimize the error. It can be used to calculate duty cycle for PWM (Pulse Width Modulation).\r\n", "\r\n", "Features\r\n", "\u2022 16-bit signed coefficient and data input: Kp, Ki, Kd, SP and PV.\r\n", "\u2022 32-bit signed u(n) output.\r\n", "\u2022 Containing one high speed 32-bit prefix-2 Han-Carlson adder and one high speed pipelined 16x16-bit multiplier.\r\n", "\u2022 Latency from input of PV to finished calculation and update of u(n) is 9 clock cycles.\r\n", "\u2022 Ki, Kp, Kd, SP, PV can be updated anytime after reset.\r\n", "\u2022 After every update of Kp or Kd, register Kpd which stores Kp+Kd will be calculated and updated.\r\n", "\u2022 After every update of PV, calculation and update of e(n), e(n-1), sigma and u(n) will be triggered in sequence.\r\n", "\u2022 Overflow register records overflow signals when calculating Kpd, e(n), e(n-1), u(n) and sigma.\r\n", "\u2022 Using 2278 of 4608 (49%) Core Cells in Actel A2F200M3F FPGA and running at 100MHz clock frequency.\r\n", "\u2022 Wishbone B4 compliant interface. Support 16-bit, 32-bit and 64-bit bus width.\r\n", "\n        "]},
{"details": ["\n    Name: waveform_gen", "\n    Created: Oct 22, 2008", "\n    Updated: Jul 26, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This core is a straight forward implementation of a Numerically Controlled Oscillator (NCO) - also referred to as a Direct Digital Synthesizer (DDS).  In addition to generating the standard SIN/COS output waveforms, it also generates Square and Sawtooth outputs with very little extra resource.  NCOs form an essential component in many Digital Comms applications - especially in digital modulation, up/down conversion and the generation of complex signals.  This core is also great for test-benches as it provides a simple way to generate input stimuli for Filters, DSP circuits etc.  The following Mean-square plot shows an example output tone of 1.7MHz for a 100MHz sample frequency. The ", " fully documents how to use and configure the NCO core.", "\n            - 12-bit signed output data samples\r\n", "- 32-bit phase accumulator\r\n", "- Phase resolution of 2Pi/2^12\r\n", "- Frequency resolution of Fs/2^32 (Fs = sample frequency)\r\n", "- ~70 dB Signal-to-Noise Ratio (SNR)\r\n", "- ~70 db Spurious Free Dynamic Range (SFDR)\r\n", "-  Simultaneous SIN, COS, SQUARE and SAWTOOTH outputs\r\n", "- 2 clock-cycle latency\r\n", "- Sample rates of 500MHz or better (Xilinx Virtex 5 / Altera Stratix III)\n        ", "\n            - Basic version fully tested and complete\r\n", "- Future optimizations to improve SNR/SFDR will be considered\n        ", "\n            Simon Doherty is a Senior Design Consultant at ", " If you require further assistance regarding the implementation of this core, you may contact me directly via my Opencores email alias at sdoherty@opencores.org. Alternatively you may contact me through customer support at ZIPcores.\r\n", "\n        "]},
{"details": ["\n    Name: dct_idct", "\n    Created: Feb  1, 2010", "\n    Updated: Oct 10, 2012", "\n        SVN Updated: Feb  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nDCT soft core is the unit to perform the Discrete Cosine Transform (DCT). It performs twodimensional 8 by 8 point DCT for the period of 64 clock cycles in pipelined mode.\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: lowpowerfir", "\n    Created: Mar 27, 2003", "\n    Updated: Jan 28, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This project was undertaken to produce a low power FIR filter for inclusion in a VHDL target library. The design was completed using OrCAD's Capture CIS, from this the VHDL code has been extracted. This method has allowed complete testing of the system.\r\n", "\r\n", "The power consumption of various arithmetic architectures has been investigated, and the results have been provided in the intial report (FIRLowPowerConsiderations.doc). These results have enabled the correct power/performance optimization for the FIR filter design.\r\n", "\r\n", "The design was produced at the gate level, enabling low-power architecture to be implemented using the extracted VHDL netlists. Each part of the design is explained within the design report (FIRLowPowerFinalReport.doc), along with the techniques for the operation of the system.\n        ", "\n            - Simple operation\r\n", "- Programmable with up to 15 taps\r\n", "- Operates at sample frequency\r\n", "- Low power design, low control logic overhead\r\n", "- Power considerations and design reports available\r\n        ", "\n            - Filter complete and fully tested, VHDL source and testbenches available\r\n", "- Low-power analysis report available\r\n", "- FIR filter design report available\n        "]},
{"details": ["\n    Name: ima_adpcm_enc_dec", "\n    Created: Sep 17, 2011", "\n    Updated: Dec 12, 2014", "\n        SVN Updated: Jan 19, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            The IMA ADPCM audio compression algorithm belongs to the Adaptive Differential Pulse Code Modulation type algorithms. The algorithm is based on a simple adaptive quantization of the difference between the input and a predictor. Each 16-bit input sample is converted to a 4-bit coded information which yields a compression ratio of \u00bc. We will not go through detailed description of the algorithm in this document. There are many online pages describing the algorithm, just Google \u201cIMA ADPCM\u201d.\r\n", "\r\n", "The main advantage of the IMA ADPCM compression algorithm is its simplicity. The algorithm is not limited to voice signals and can operate at any input sampling rate thus enabling compression of high quality audio as well. \r\n", "\r\n", "The implementation in this project does not follow any standard protocol format for the compressed information. The encoder uses a very simple interface to input 16-bit samples and output coded information nibbles (4-bits). A similar interface is used by the decoder to input the coded information nibbles and output 16-bit reconstructed samples. \r\n", "\r\n", "A bit exact fixed point Scilab implementation of the algorithm is supplied with the core and is used to generate files used during verification. Detailed description of the verification process is given in the Test Bench Description chapter.\r\n", "\r\n", ".\n        "]},
{"details": ["\n    Name: hilbert_transformer", "\n    Created: Dec 28, 2008", "\n    Updated: Dec  5, 2017", "\n        SVN Updated: Apr  5, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Hilbert Transform is an important component in communication systems, e.g. for single sideband modulation/demodulation, amplitude and phase detection, etc. It can be formulated as filtering operation which makes it possible to approximate the Hilbert Transform with a digital filter. Due to the non-causal and infinite impulse response of that filter, it is not that easy to get a good approximation with low hardware resource usage. Therefore, different filters with different complexities have been implemented.\r\nThe detailed discussion can be found in \"Digital Hilbert Transformers or FPGA-based Phase-Locked Loops\" (http://ieeexplore.ieee.org/xpl/freeabs_all.jsp?arnumber=4629940). \r\n\r\nThe design is fully pipelined for maximum throughput. \r\n\r\n"]},
{"details": ["\n    Name: robust_fir", "\n    Created: Mar 23, 2011", "\n    Updated: Jun 18, 2012", "\n        SVN Updated: Jul  3, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Generic FIR filter. Builds optimized filter according to number of multipliers, supports serial or parallel architecture. Supports delays in input. Builds Verilog FIR filter according to input parameters: multiplier number, filter order, etc. The source files are written in RobustVerilog, a free RobustVerilog parser can be downloaded from ", "\n        "]},
{"details": ["\n    Name: fft_fir_filter", "\n    Created: Feb  1, 2010", "\n    Updated: Apr 27, 2011", "\n        SVN Updated: Feb  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nFFT-based FIR Filter is a unit to perform the finite impulse responce filter based on the Fast Fourier Transform (FFT). It performs the convolution of the unlimited signal sequence with the synthesized impulse responce of the length of Ni=N/2 samples, where N = 64, 128, 256, 512, 1024. The data and coefficient widths are tunable in the range 8 to 18.\r\n", "\r\n", "\r\n", "\r\n", "\r\n"]},
{"details": ["\n    Name: gfir", "\n    Created: Apr 12, 2012", "\n    Updated: Apr 13, 2012", "\n        SVN Updated: Apr 13, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is an elementary generic structural VHDL code for FIR digital filters in transposed-form and direct-form implementations. \r\n", "\r\n", "This project covers a wide spectrum of design aspects, in particular design and both functional and formal verification. \r\n", "\r\n", "The project is developed in VHDL and modeled in SystemC. The SystemC model is used for functional and formal verification.\r\n", "\r\n", "TCL scripts for GHDL and SystemC is included within the project files.\r\n", "\r\n", "This code could be considered for VHDL classes or DSP classes for amateurs or beginners. \r\n", "The developed code was synthesized for FPGA and ASIC (0.13um CMOS) using: \r\n", "Xilinx \t\tISE \r\n", "Synopsys \tDesign Compiler \r\n", "Cadende \tRTL Encounter \r\n", "\r\n", "Further, it was implemented using Xilinx Spartan-3E FPGA utilizing the Spartan-3E Starter Kit. It was tested using Xilinx ChipScope and a complete lab setup, as well. The filter output was converted to analog output using the on-board DAC to trace it on a Spectrum analyser. \n        "]},
{"details": ["\n    Name: dds_synthesizer", "\n    Created: Dec 22, 2008", "\n    Updated: Feb 23, 2016", "\n        SVN Updated: Apr  5, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The DDS IP core (dds_synthesizer) is a implementation of a direct digital frequency synthesizer (DDS) (also called number controlled oscillator, NCO) which produces a sinewave at the output with a specified frequency and phase (adjustable at runtime).\r\n\r\nOnly one quater of the sinewave is stored in the LUT, the rest is computed by simple operations (negating, subtraction), resulting in a reduced memory requirement.\r\n\r\nThe resolution of the frequency tuning word (FTW), the phase and the amplitude defined seperately. Several precomputed look-up tables are provided as combinations from 8 to 16 bit phase and amplitude resolution. The frequency resolution can is defined as generic. A matlab script for generating the LUTs for different resolutions is included.\r\n\r\nThe design is fully pipelined for maximum throughput. \r\n\r\n", "\r\n\r\nIf you find something interesting, feel free to contact me: pluto[at]ls68.de\n        "]},
{"details": ["\n    Name: fir_filter_generator", "\n    Created: Dec 29, 2005", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL core generator\r\n", "\r\n", "FIRGEN Project generates optimized VHDL codes for FIR Filters and Multiplier arrays\r\n", "using \"Nonrecursive Signed Common Subexpression Algorithm\".\r\n", "\r\n", "program writen on C++\r\n", "--------------------------\r\n", "firgen [OPTION..]\r\n", "Available options are :\r\n", "-w Input Data Width\r\n", "-m Generate Only Multipliers Array\r\n", "-a Generate Asynchronus Multipliers array (no CLK signal)\r\n", "-e Use CLK_EN input\r\n", "-c filter coefficients, coma separated\r\n", "-o Output File Name\r\n", "-? Help\r\n", "\r\n", "Example For Use:\r\n", "----------------\r\n", "FirGen -w 16 -c 1,2,3,4,5 -o my_fir\r\n", "\r\n", "this command generates 2 output files\r\n", "my_fir.vhd - Main Fir module\r\n", "my_fir_mult.vhd - Multipliers Array (DIn*C1, DIn*C2,..., DIn*Cn)\r\n", "\r\n", "Input data width is 16 bit\r\n", "Filter Coefitions : 1,2,3,4,5\n        ", "\n            FIR Filter Generator\r\n", "Multiplyer Array Generator with common input\n        ", "\n            Stable and ready for use Ver1.1\r\n", "Asynchronus operation\r\n", "and CLK_En features added\r\n", "\r\n", "------------------------------------------------------------------\r\n", "Download URL:\r\n", "\r\n", "\r\n", "------------------------------------------------------------------\r\n", "note : May be you will need to install cygwin from www.cygwin.com to be able\r\n", "         run this program.\n        "]},
{"details": ["\n    Name: fir_filter", "\n    Created: Mar 22, 2013", "\n    Updated: Aug 13, 2015", "\n        SVN Updated: Apr 12, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            VHDL Parametrizable FIR Filter\r\n", "\r\n", "Implementation:\r\n", "\r\n", "-Direct Form II\r\n", "-Real format entry for normalized coeficients\r\n", "-Internal fixed-point implementation (configurable resolution)\r\n", "\r\n", "Simulation:\r\n", "\r\n", "-Matlab file (.m) \r\n", "-VHDL testbench and macro (.do) for simulation\r\n", "\r\n", "===========================================================\r\n", " EXAMPLE\r\n", "===========================================================\r\n", "\r\n", "duv_FIR_low_area : ENTITY WORK.FIR_low_area\r\n", "\r\n", "GENERIC MAP(       \r\n", "..data_length...=>..12,....-- input/output length \r\n", "..data_signed...=>..true,..-- input/output type (signed or unsigned)\r\n", "..improv_t........=>..false,.-- minimal timing improvement (+1 cycle delay)        \r\n", "..bits_resol.......=>..16,....-- bits for decimal representation of coeffients\r\n", "..taps..............=>..5,.....-- order+1, 2 taps (coefficients) as minimum \r\n", "..coefficients....=>..(.......-- normalized coefficients (bo,b1, ..., bN)\r\n", "............................-0.11735685282030676,\r\n", ".............................0.23471370564061372,\r\n", ".............................0.7066280917835991,\r\n", ".............................0.23471370564061372,\r\n", "............................-0.11735685282030676,\r\n", ".............................OTHERS=>0.0)....-- (always end with \"others=>0.0\")\r\n", "\r\n", "PORT MAP(\r\n", "..areset.....=>..areset,..-- active high                            \r\n", "..sreset.....=>..'0',.......-- active high    \r\n", "..clock_fs..=>..CLK,                              \r\n", "..enable....=>..'1',                                  \r\n", "..xn..........=>..input,....-- FILTER INPUT  (fixed-point or whole number)\r\n", "..yn..........=>..output...-- FILTER OUTPUT (keeps same format as input)\r\n", "  );\r\n", "\r\n", "\r\n", "ENJOY!!!\n        "]},
{"details": ["\n    Name: cic_core", "\n    Created: Feb 21, 2011", "\n    Updated: Nov  4, 2014", "\n        SVN Updated: Mar  7, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Cascaded integrator-comb (CIC) digital filters are computationally efficient implementations of narrowband lowpass filters and are often embedded in hardware implementations of decimation and interpolation in modern communications systems.\r\n", "\r\n", "NB: core is written in SystemVerilog.\n        "]},
{"details": ["\n    Name: cic", "\n    Created: Jun  6, 2012", "\n    Updated: Jun  8, 2012", "\n        SVN Updated: Jun  8, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a structural model for cascaded integrator comb (CIC) decimation filters. The filter consists of integrator, downsampler and comb stages. Each block is developed in behavioral manner, however, the top-level is developed in structural hierarchal manner. A test-bench is included for each single block and for the top-level entity as well.\n        "]},
{"details": ["\n    Name: all-pole_filters", "\n    Created: Jun 10, 2011", "\n    Updated: Dec  1, 2016", "\n        SVN Updated: Nov 22, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The circuits found here implement digital leapfrog filters as described in .\" target=\"_blank\">http://en.wikibooks.org/wiki/Signal_Processing/Digital_Filters>. \r\n", "All filters are of lowpass type. They are optimised in terms of area.\r\n", "\r\n", "This kind of filter structure is the digital counterpart of an analog lumped-elements ladder filter. It simulates the functioning of an all-pole lowpass filter under the assumption of a large oversampling. The circuit implements the integral relations between voltages and currents of the capacitors and the inductances with the help of accumulators. This corresponds to simplify the Z-transform to z = 1 + sT.\r\n", "\r\n", "The relative values of the filter coefficients specify the transfer function shape (Butterworth, Chebyshev, ...). The amplitude of the coefficients specify the cutoff frequency. In the circuits provided here, this amplitude is set by a shift value given as a generic.\r\n", "\r\n", "The filter provided are\r\n", "  - a 3rd order Butterworth with no multiplier (coefficients are only shifts)\r\n", "  - a 6th and an 8th order Bessel with coefficients optimised to 2 shifts and an addition\r\n", "  - a generic filter where the coefficient multiplications are executed iteratively\n        "]},
{"details": ["\n    Name: cf_fir", "\n    Created: Mar 30, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nFinite impulse response (FIR) filters are common in DSP applications and consist of a delay bank (filter taps) and a sum-of-products.\n        ", "\n            The filter architecture consists of a delay bank and a pipelined sum-of-products network.  All arithmetics are lossless -- multipliers produce precision with the sum of the operands and each adder extends precision by 1 bit.\r\n", "\r\n", "The filter has a synchronous reset to reinitialize the filter taps.  The reset does not affect the pipeline registers in the sum-of-products network.\r\n", "\r\n", "The filter includes ports for the filter coefficients; typically hardwired to constants.\r\n", "\r\n", "Each file is stand-alone and represents a specific configuration.\r\n", "The 3 configuration parameters are:\r\n", "  - Filter Order (# of delay taps)\r\n", "  - Input Precision\r\n", "  - Coefficient Precision\r\n", "\r\n", "The configuration parameters are coded in the file names: cf_fir_3_16_8.v\r\n", "  - 3  : Filter order.\r\n", "  - 16 : Input precision.\r\n", "  - 8 : Coefficient precision.\r\n", "\r\n", "Current configurations:\r\n", "  - cf_fir_3_8_8\r\n", "  - cf_fir_7_16_8\r\n", "  - cf_fir_7_16_16\r\n", "  - cf_fir_12_16_10\r\n", "  - cf_fir_16_16_16\r\n", "  - cf_fir_24_8_8\r\n", "  - cf_fir_24_16_16\r\n", "  - cf_fir_33_16_16\r\n        "]},
{"details": ["\n    Name: linkruncca", "\n    Created: Apr 21, 2016", "\n    Updated: Dec 28, 2017", "\n        SVN Updated: Apr 26, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            LinkRunCCA is a real-time single-pass connected component analysis/ connected component labeling (CCA/CCL) implemented in Verilog HDL. It can be easily connected to any image pixel streaming interface in FPGA design, producing bounding boxes of ALL (no number of box limitation) connected components as soon as completed box is detected. It can operate in maximum streaming throughput (one pixel per cycle) and has very low memory requirement. This implementation is based on the state-of-the-art algorithm from publication in ", "\n        ", "\n            LinkRunCCA uses combination of linked list and run-length-based techniques to label and extract components' feature (bounding box in this case) in one scan. This hardware module accepts binary image/video stream as input and produces bounding boxes of each connected component in the image/video. Bounding box of each connected component is produced immediately as soon as the component is completed. The size of image/video is parametrizable, hence the memory requirement is varied based on image/video size. ", "\r\n", "\r\nDownload command (linux): ", "\r\nsvn co http://opencores.org/ocsvn/linkruncca/linkruncca/trunk ", "\r\n", "\r\nPort and Parameter Descriptions: ", "\r\nInput Ports: ", "\r\nclk       - clock sink ", "\r\nrst       - reset sink ", "\r\npix_in    - input binary image/video stream (1 bit) ", "\r\ndatavalid - valid bit for input stream ", "\r\n", "\r\nOutput Ports: ", "\r\nbox_out       - bounding box of each component ", "\r\ndatavalid_out - valid bit for each bounding box ", "\r\n", "\r\nParameters: ", "\r\nimwidth  - image width ", "\r\nimheight - image height ", "\r\n", "\r\nPerformances:\r\n", "\n            Simulation using Verilator tool is included due to its faster simulation for image processing. Several binary test images are available for testing. The bounding box image is created after the simulation.\r\n", "\r\n", "A simulation script is provided. Prior to simulation, the script detects the simulating image size and generates appropriate headers/parameters for both simulation and verilog hardware.\r\n", "\n        "]},
{"details": ["\n    Name: biquad", "\n    Created: Sep 25, 2001", "\n    Updated: Jul  8, 2015", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            - IIR filter with two poles and two zeros \r\n", "- Data width set by user \r\n", "- Coefficient width set by user up to 16 bits \r\n", "- Wishbone interface for read and write of filter coefficient registers \r\n", "- Multiple filters can be combined to form filters with more than two poles and zeros\r\n        ", "\n            The difference equation for the biquad filter is:\r\n", "\r\n", "y[n] = b10*x[n] + b11*x[n-1] + b12*x[n-2] + a11*y[n-1] + a12*y[n-2]\r\n", "\r\n", "This equation is implemented as shown below: \n        ", "\n            FILE: bquad_blk.gif\n", "DESCRIPTION: \n", "\n        ", "\n            Synthesized with Synopsys FPGA Express version 2000.11-FE3.5.\n        ", "\n            If you use this core please let me know.\n        "]},
{"details": ["\n    Name: xtea", "\n    Created: Apr  7, 2006", "\n    Updated: Jul 21, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a Verilog implementation of the ", ". It works on two 32-bit blocks of data at a time with a 128-bit key.\r\n\r\nA proper OpenCores specification for this unit will be written at some point. ", " compliance is also on the TODO list.\r\n\r\nThis implementation was adapted from the public domain C release of the algorithm from David Wheeler and Roger Needham by ", ". It is licensed under the GNU Lesser General Public License.\n        ", "\n            - a very small, efficient implementation\r\n", "- fast\r\n", "- secure\r\n", "- what more do you need?\n        ", "\n            The current stable release is version 1.0.\r\n\r\nThis release has seperate encipher/decipher units. A test-bench is available and included in the download. Version 1.0 is not licensed under the LGPL - it is public domain.\r\n\r\nEach unit accepts data in data_in1 and data_in2 and a key in key_in. The all_done wire is raised when the results of the operation are ready to be read from data_out1 and data_out2.  They need to be reset before each use.\r\n\r\nThis release has been FPGA-proven on an Altera Stratix EPS1S10F672C6-ES running at 25.175MHz. Higher clock speeds have not been tested.\r\n\r\nPlease report back if you get the design up-and-running (especially if you get it running as an ASIC) or if you have it running at a higher clock speed.\r\n\r\n", " the download page doesn't appear to be working at the moment, but you can ", ".\n        ", "\n            Originally the project was split into seperate encipher/decipher units, but these have now been combined into a single unit. The test-bench has not yet been updated for the new combined unit.\r\n\r\nThe unit accepts data in data_in1 and data_in2, a key in key_in and the mode in mode (1 for encipher, 0 for decipher). The all_done wire is raised when the results of the operation are ready to be read from data_out1 and data_out2. It needs to be reset before each use.\r\n\r\nThis combined unit, as of yet, has ", ".\n        "]},
{"details": ["\n    Name: twofish", "\n    Created: Apr 30, 2006", "\n    Updated: May  8, 2006", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the twofish cipher for 128,192 and 256 bit keys.\r\n", "The implementation is in library-like form; All needed components up to, including the round/key schedule circuits are implemented, giving the flexibility to be combined in different architectures (iterative, rolled out/pipelined etc). Manual in English is included with more details about how to use the components and/or how to optimize some of them. All testbenches are provided (tables, variable key/text, ECB/CBC monte carlo) for 128, 192  and 256 bit key sizes, along with their respective vector files.\n        ", "\n            - implementation for 128, 192 and 256 bits key size\r\n", "- core is provided in separate components\r\n", "- components' interface is simple (connection is described in manual)\r\n", "- core is synthesizable\n        ", "\n            - core tested against all available testvectors\r\n", "- core is ready to be used\n        "]},
{"details": ["\n    Name: threeacompactaes", "\n    Created: May  6, 2011", "\n    Updated: Apr 16, 2013", "\n        SVN Updated: May 11, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            \n        "]},
{"details": ["\n    Name: xteacore", "\n    Created: Jul 25, 2013", "\n    Updated: Aug 21, 2017", "\n        SVN Updated: Jul 27, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the XTEA block cipher (iterative architecture).\n        "]},
{"details": ["\n    Name: systemcmd5", "\n    Created: Aug 27, 2004", "\n    Updated: Apr  9, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            - Implements the MD5 standard\r\n", "- It doesnt make the block padding, you must input the 128 bits blocks padded and in little endian mode\r\n", "- The output is given in little endian\r\n", "\n        ", "\n            - Done\n        ", "\n            A SystemC/Verilog synthesizable MD5 hash core. \r\n", "\r\n", "This work is given by Universidad Rey Juan Carlos (Spain)\r\n", "www.gdhwsw.urjc.es\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: sha256_hash_core", "\n    Created: Jul 14, 2016", "\n    Updated: Dec 30, 2016", "\n        SVN Updated: Oct 15, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\nIf you have any problem donwloading, please email me at \r\n", "\r\n", "\n            The VHDL code is functional, tested and verified at the RTL synthesis level. \r\n", "Hardware verification and performance characterization will follow. \r\n", "FPGA performance tests show synthesis at 80MHz top clock speed. At 74MHz, the engine runs 580Mbps.\r\n", "The project will include source code for an ARM LPC1768 mbed board testing a Spartan-6 Atlys board with the GV_SHA256 core under test, using parallel ports to test the SHA256 engine performance. \r\n", "The hardware verification project will also encapsulate the GV_SHA256 in a fast SPI wrapper for functional testing, as an external SHA256 engine interfaced by a fast SPI bus.\n        ", "\n            ", "\n            This is the GV_SHA256, a fast SHA-256 engine (580Mbps @ 74MHz), fully compliant to the NIST FIPS-180-4 SHA-256 approved algorithm. \r\n", "\r\n", "It is implemented as a single-cycle combinational logic for one iteration of the hash core, with a total of 65 clocks for the full 512-bit block hash operation. \r\n", "The design is fully static, with a clean data path / control path approach. \r\n", "The core has minimal registers, and is a parallel 256-bit processor, that receives a stream of 32-bit words, and delivers a 256-bit parallel hash output. \r\n", "Interfacing with the engine is easy, with flow control signals that facilitate bus interfacing. \r\n", "The testbench includes NIST vectors to verify against all corner cases for the SHA256 algorithm and block padding. \r\n", "This logic synthesizes to system clocks of 72MHz, with ~10 layers of longest combinational logic path, without pipelining, in Spartan-6 (speed grade 2) technology.\r\n", "\r\n", "The main objective is to share the design in order to benefit from the process Verification in several technologies, and maybe get feedback on design glitches for the algorithm optimizations. The implementation is straightforward, with aspect naming after the NIST-180-4 source description, and is optimized for minimum registers, instead of for minimum combinational length. That is a good fit for IoT applications, where silicon area may be more important than maximum clock speed. \r\n", "I have more aggressively optimized versions of the SHA256 family (HMAC_SHA256, HKDF, DRBG), used on our closed-source cyber security ASICs.\r\n", "Algorithm optimizations and parallel adder optimizations reduce the cycles per function and increase the top clock speeds of these crypto functions.\r\n", "\r\n", "This core is the base of the GridVortex Crypto Library, for HMAC-SHA256, HMAC-SHA256-DRBG, HKDF and HMAC-DRBG-KDF cryptographic constructions. \r\n", "The VHDL is written as hand-optimized RTL targeted for ASIC processes, especially IoT ASICs at 130nm/90nm. \r\n", "However, it is easily integrated on FPGA targets. No FPGA hard logic are used in the description. \r\n", "\r\n", "All feedback are highly appreciated. \r\n", "\n        "]},
{"details": ["\n    Name: systemcdes", "\n    Created: Jul  2, 2004", "\n    Updated: Dec  1, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            SystemC DES is a implementation of the DES algorithm in SystemC focusing on low area applications. \r\n", "Implements the encoder and decoder in the same block.\r\n", "It was fully verified using TLM (Transaction Level Modelling Style) defined in the SystemC Verification Library.\r\n", "Verilog translation for synthesis is also provided.\r\n", "The core was tested on a Virtex2 FPGA succesfully.\r\n", "\r\n", "This work is given by Universidad Rey Juan Carlos (Spain)\r\n", "www.gdhwsw.urjc.es\n        ", "\n            - SystemC and Verilog code are provided\r\n", "- Verified using TLM(Transaction Level Modelling Style)\r\n", "- Encoder and decoder in the same block\r\n", "\r\n", "- Synthesis Results:\r\n", "\r\n", "Comparation between SystemC DES project and  DES IP project\r\n", "\r\n", "Synthesis results for a Xilinx XC2V1000FG456-4\r\n", "\r\n", "- DES IP \r\n", "\r\n", "Area:                      11%                                 \r\n", "Freq.:                   167 Mhz                               \r\n", "Cycles per block:      16                                     \r\n", "\r\n", "- SystemC DES\r\n", "\r\n", "Area:                     4%                                  \r\n", "Freq.:                    90 Mhz                               \r\n", "Cycles per block:     16\r\n", "\r\n", "\r\n", "If you need a more troughput choose DES IP core. \r\n", "If you need less throughput but want half area choose SystemC DES\r\n", "\r\n", "\n        ", "\n            - Writing documentation\n        "]},
{"details": ["\n    Name: sha3", "\n    Created: Nov  9, 2012", "\n    Updated: Dec  2, 2016", "\n        SVN Updated: Jan 29, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            SHA-3, originally known as Keccak [1], is a cryptographic hash function selected as the winner \r\n", "of the NIST hash function competition [2]. Because of the successful attacks on MD5, SHA-0 and\r\n", "theoretical attacks on SHA-1, NIST perceived a need for an alternative, dissimilar cryptographic\r\n", "hash, which became SHA-3 [3].\r\n", "\r\n", "NIST requires the candidate algorithms to support at least four different output lengths {224,256,384,512}\r\n", "with associated security levels [4]. \u201cSHA-3 512\u201d, in which output length is 512-bit, \r\n", "has the highest security level among all SHA-3 variants.\r\n", "\r\n", "This project has implemented \u201cSHA-3 512\u201d hash function.\r\n", "\r\n", "This project has implemented two cores, one (high-throughput) core designed to work in\r\n", "high clock frequency (150 MHz) dedicated to ASIC or expensive FPGA (Virtex 6),\r\n", "another (low-throughput) core designed to work in low clock frequency (100 MHz)\r\n", "dedicated to cheap FPGA (Spartan 3). Because in many systems the clock frequency is\r\n", "fixed for the entire chip, so even if the hash core can reach a high frequency it has to be\r\n", "clocked at a lower frequency [5].\r\n", "\r\n", "The code is FPGA-vendor independent, having been fully optimized, using only one\r\n", "clock domain, not using any latch.\r\n", "\r\n", "[1] Guido Bertoni, Joan Daemen, Micha\u00ebl Peeters and Gilles Van Assche,\r\n", "    \u201cThe Keccak sponge function family: Specifications summary\u201d, \r\n", "    ", "\r\n", "\r\n", "[2] \u201cNIST Selects Winner of Secure Hash Algorithm (SHA-3) Competition\u201d, \r\n", "    NIST. Oct. 2012. \r\n", "    ", "\r\n", "\r\n", "[3] \u201cSHA-3\u201d, \r\n", "    Wikipedia, the free encyclopedia, \r\n", "    ", "\r\n", "\r\n", "[4] \u201cAnnouncing request for candidate algorithm nominations for a new cryptographic hash algorithm (SHA-3) family\u201d, \r\n", "    Federal Register Notices 72 (2007), no. 212, 62212\u201362220.\r\n", "    ", "\r\n", "\r\n", "[5] Keccak implementation overview, version 3.2,\r\n", "    ", "\n        ", "\n            ", "\n        ", "\n            ", "The synthesis software is Xilinx ISE version 14.4. ", "The low throughput core has been synthesized targeting a very cheap Spartan 3 (XC3S5000-4FG900).", "The high throughput core has been synthesized targeting an expensive Virtex 6 (XC6VLX240T-1FF1156).", "\n            ", "The low throughput core: 2.4 G bit / second if clock frequency is 100 MHz.", "The high throughput core: 7.2 G bit / second if clock frequency is 150 MHz.", "\n            This project is licensed under the Apache License, version 2.\n        "]},
{"details": ["\n    Name: cryptography", "\n    Created: Mar 24, 2009", "\n    Updated: May 23, 2011", "\n        SVN Updated: Apr 27, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The Cryptographic Algorithm which is most widely used throughout the world \r\n", "for  protecting  information.  Cryptography  is  the  art  of  secret  writing, \r\n", "followed by the guarantee to authenticate data and messages and protect \r\n", "the  systems  from valid attacks  .It  comprises of encryption and decryption \r\n", "operations each associated with a key which is supposed to be kept secret . \r\n", "                                     \r\n", "  We have  implement RC6 Algorithm. Which  is considered as a  secured and \r\n", "elegant  choice  for  AES  due  to  its  simplicity,  security,  performance  and \r\n", "efficiency.    RC6  supports  32  bit  and  64  bit  processing.  An  eight  step \r\n", "operation  is  used  to  encipher  the  64  bit  plain  text  block.  The  encrypted \r\n", "data  is then decrypted by performing the reverse operations on the same. \r\n", "The  hardware  implementation  of  RC6  algorithm  is  done  using  VHDL \r\n", "Hardware Description Language. For  this  implementation Xilinx  foundation \r\n", "series 9.2i software and Spartan-3s400pq208-5 kit are being used. \n        "]},
{"details": ["\n    Name: rsa_512", "\n    Created: Mar  7, 2010", "\n    Updated: Oct 24, 2012", "\n        SVN Updated: Jan 12, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The project presents an open-source implementaion of the 512 bit RSA algorithm. This is a reduced version of a full FIPS Certified capable RSA Crypto-core.\r\n", "\r\n", "  The full version supports all key sizes (512, 1024, 2048, 4096) and includes a complete testbench. It can reach more than 150 operations per second with a 1024 key size in a Spartan 6 FPGA and more than 200 in a Virtex 6.\r\n", "  \r\n", "  The core fits in a XC6SLX25T, which makes it a nice solution for mobile devices needing RSA acceleration.\r\n", "  \r\n", "  For more information contact jcastillo@opencores.org\r\n", "\r\n", "Please read carefully the documentation. Some cores should be generated calculated prior to use.\r\n", "\r\n", "Thanks to Oleg Rasulov for their contributions.\n        "]},
{"details": ["\n    Name: rtea", "\n    Created: Oct  5, 2009", "\n    Updated: Oct  5, 2009", "\n        SVN Updated: Oct  5, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            RTEA (from Ruptor's TEA or Repaired TEA) - a symmetric block encryption algorithm used type \"Feistel cipher\", designed by Marcos el Ruptor, expansion TEA. Fixed some vulnerability in the algorithm. Like other variants of the algorithm TEA, the operation based on work with 32-bit numbers. The algorithm is much simpler and more productive XTEA, while, according to the authors and conducted by the developers according to statistical tests, is more resistant to cryptanalysis ", "\r\n", "\r\n", "Key size 128/256 bits\r\n", "Block size 64 bit\n        "]},
{"details": ["\n    Name: sha256", "\n    Created: Mar  6, 2013", "\n    Updated: Apr 16, 2013", "\n        SVN Updated: Apr 16, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            \n        ", "\n            \n        "]},
{"details": ["\n    Name: sha256core", "\n    Created: Jul 25, 2013", "\n    Updated: Aug  8, 2013", "\n        SVN Updated: Aug  8, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the SHA-256 hashing algorithm. This project includes .do files for performing a simulation on ModelSim.\r\n", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: rc4-prbs", "\n    Created: May 17, 2012", "\n    Updated: Feb 26, 2013", "\n        SVN Updated: Jun  2, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            RC4 PRBS (Generates the RC4 stream, then you have to XOR it with your data to crypt or decrypt it), takes 768 clocks to do key-expansion, then start outputting one-byte of random stream for every clock (output_read signals valid output in K). Based on RC4 implementation in wikipedia.\n        "]},
{"details": ["\n    Name: present", "\n    Created: May  5, 2011", "\n    Updated: Sep 17, 2014", "\n        SVN Updated: Sep 17, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "Present is a lightweight block cipher dedicated to implement in Hardware. It was developed by Knudsen team.", "This cipher operates on the 64 bit text with use of 80 bit key. It uses S/P blocks and xor operations for encryption and key update through 32 rounds.", "In this project I created:", "\r\n- Present module dedicated to 32 bit Hardware (32 bit I/O and working under state machine)", "\r\n\u00a0\u00a0 This is much for 'archive' state due to it was part of my students project, and it is not a 'pure' implementation of PRESENT.\r\n- \"Pure\" Present implementation \"as is\" in the Knudsen article", "\r\n- Present cipher Decoder", "\r\n- Some helpful programs written in Java used for testing VHDL modules", "\r\n- Some modules used for testing communication with PC", "\r\n- Full documentation for each subproject", "\r\n", "These modules were tested on Digilent Spartan 3E Starter Boart (Spartan XC3S500E) - except 32 bit I/O version", "If You have any questions write me an email ", "."]},
{"details": ["\n    Name: present_encryptor", "\n    Created: Jan 18, 2011", "\n    Updated: Feb 18, 2011", "\n        SVN Updated: Feb 17, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Present is a lightweight block cipher designed for hardware constrained applications such as RFID tags and Smart Cards.\r\n", "This cipher is a true example of SPN ciphers. The block size is 64 bits, key size can be either 80 or 128 bits and the number of rounds is 31.\r\n", "The S-Box used in Present is a 4-bit to 4-bit S-Box which is invoked both in the substitution layer and in the key scheduling routine.\r\n", "This project entails an encryption-only implementation of Present cipher with key size equal to 80 bits.\n        "]},
{"details": ["\n    Name: md5_pipelined", "\n    Created: Jul 31, 2014", "\n    Updated: Jan  9, 2018", "\n        SVN Updated: Dec  8, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A high throughput, 64-stage pipelined implementation of MD5 written in Verilog. Completes one hash per cycle.\n        "]},
{"details": ["\n    Name: noekeoncore", "\n    Created: Jul 25, 2013", "\n    Updated: Jul 27, 2013", "\n        SVN Updated: Jul 27, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the NOEKEON block cipher (iterative architecture).\n        "]},
{"details": ["\n    Name: aes_highthroughput_lowarea", "\n    Created: Mar  3, 2010", "\n    Updated: Apr  1, 2012", "\n        SVN Updated: May  6, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The High Throughput Low Area AES IP core implements the Rijndael encryption & decryption algorithm used in the AES standard. The standalone core implements the basic ECB mode described in publication 800-38A by NIST. Other modes can be easily implemented using the core. ", "\r\nThe core implements both key expansion, required each time the key is changed (also after reset or power-up), and encryption/decryption algorithms. The core supports all three key lengths: 128, 192 & 256 bits, selected by an input signal. Encryption or decryption modes of operation are also selected on the fly using an input signal. ", "\r\nThe core can achieve data rates of about 880Mbps with 256 bits key length, 1Gbps with 192 bits key length and 1.2Gbps with 128 bits key length when operated at a clock of 100MHz. ", "\r\nTest bench for basic simulation is provided to demonstrate the core functionality and interfaces. An additional test bench is supplied for verification of the core using the KAT test vectors files for ECB mode. ", " \r\n", "\r\n"]},
{"details": ["\n    Name: aes_pipe", "\n    Created: Mar 22, 2010", "\n    Updated: Jul  9, 2010", "\n        SVN Updated: Jul  8, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "This is a fully pipelined implementation of the AES (rijndael) cipher with 128 bit keysize. Post place and route logs show the maximum speed to be 333 MHz when implemented on a Virtex-5 LX50T speed grade -1 FPGA with 45% LUT utilization and 27% register utilization. This comes out to a maximum throughput of ~ 42Gbps with an average of 1 encryption every cycle. The overall design has a latency of 30 clock cycles. A brief documentation is available ", ".", "P.S. If you download the project and find it to be useful, please do drop me a mail at my address ", ". I will appreciate it very much. :-) ", "\n            "]},
{"details": ["\n    Name: gost28147-89", "\n    Created: Mar 13, 2014", "\n    Updated: Mar 13, 2014", "\n        SVN Updated: May  8, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            The GOST block cipher, defined in standard GOST 28147-89, is a Soviet and Russian government standard symmetric key block cipher.\r\n", "Developed in the 1970s, the standard has been marked \u201dTop Secret\u201d and the downgraded to \u201dSecret\u201d in 1990. Shortly after the dissolution of the USSR, it was declassified and it was released to the public in 1994.\r\n", "wikipedia: ", "\n        ", "\n            Core supported ecb, ecb pipeline, cfb, mac.\n        ", "\n            Core was tested on a Altera Cyclone II\r\n", "ecb mode needs ~200 LUTs\r\n", "ecb pipeline need ~3k LUTs\n        "]},
{"details": ["\n    Name: aes-encryption", "\n    Created: Oct 14, 2010", "\n    Updated: Nov 19, 2010", "\n        SVN Updated: Jan  2, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: desxcore", "\n    Created: Jul 25, 2013", "\n    Updated: Aug 10, 2013", "\n        SVN Updated: Aug 10, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the DESX block cipher (iterative architecture).\n        "]},
{"details": ["\n    Name: gost28147", "\n    Created: Apr 17, 2012", "\n    Updated: Apr 10, 2017", "\n        SVN Updated: Mar 19, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            ", "\n        ", "\n            This is a implementation of the GOST 28147-89 - a Soviet and Russian government standard symmetric key block cipher. \r\n", "GOST 28147-89 has a 64-bit blocksize and 256-bit keysize. \r\n", "\r\n", "This implementation provide trade off size and performance. The goal was to be able to fit in to a low cost Xilinx Spartan series FPGA and still be as fast as possible. As one can see from the implementation results below, this goal has been achieved. \n        ", "\n             - SystemVerilog RTL and TB code is provided \r\n", " - Implements both encryption and decryption in the same block\r\n", " - GOST 28147-89 algorithm focusing on very low area applications\r\n", " - Implementation takes about 32 cycles to encrypt/decrypt a block\r\n", " - EBC-cipher mode support\r\n", " - The core complies to use of S-box according to RFC4357/GOST R34.11-94 or RFC5830 (by synthesis), or S-box switch \"on the fly\" (realtime).\r\n", "\n        ", "\n             - Core implementations have been tested on a Xilinx Spartan-3E FPGA succesfully\r\n", " - This core is done. Initial Release: Apr. 17, 2012 \n        ", "\n            For run synthesize design using Synplify tool use command:\r\n\r\n", "\n            \r\n", "\r\n", "\n            The design uses SystemVerilog as language for RTL-implementation therefore your Design Tools should support SystemVerilog for synthesis and simulation.\n        ", "\n            - Implementation testing with support Botan crypto-lib. It can be used in a DPI-based testbench as golden model or test vector generator\r\n", "- Support for following cipher modes: CBC, CFB, OFB (and maybe CTR) \r\n", "- Adding SoC-buses compatibility for seamless integration\n        ", "\n            - ", "\r\n- ", "\r\n", "\r\n", "\r\nFeel free to send me comments, suggestions and bug reports. \n        "]},
{"details": ["\n    Name: deslxcore", "\n    Created: Jul 25, 2013", "\n    Updated: Aug 10, 2013", "\n        SVN Updated: Aug 10, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the DESLX block cipher (iterative architecture).\n        "]},
{"details": ["\n    Name: deslcore", "\n    Created: Jul 25, 2013", "\n    Updated: Aug 10, 2013", "\n        SVN Updated: Aug 10, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the DESL block cipher (iterative architecture).\n        "]},
{"details": ["\n    Name: des", "\n    Created: Sep 25, 2001", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Simple DES/Triple-DES core. \n        ", "\n            - A simple DES core \r\n", "- Fast and Small Version \r\n", "- Open Source \n        ", "\n            I believe that the core complies to NIST-800-17. However, there has been no formal third party verification. \r\n\r\nThe official NIST specification can be downloaded here: ", ".\r\n\r\nFor the Triple DES, the NIST reference is located here: ", ".\n        ", "\n            Triple DES IP Core\r\n==============\r\n\r\n", "\r\nThis is a sequential implementation and needs 48 cycles to complete  a full encryption/decryption cycle. \r\n- 0.18u UMC ASIC process: 5.5K gates, > 160 Mhz\r\n- Spartan IIe 100-6 : 1450 LUTs (about 60%), 88MHz\r\n\r\n", "\r\nThis is a pipelined implementation that has a 48 cycle pipeline (plus 1 input and 1 output register). It can perform a complete  encryption/decryption every cycle. \r\n- 0.18u UMC ASIC process: 55K Gates, 300MHz (19.2 Gbits/sec)\r\n- Virtex-II-1500-6: 79% utilization, 166Mhz (10.6 Gbits/sec)\r\n\r\n\r\n(Single) DES IP Core\r\n==================\r\n\r\n", "\r\nThis is a sequential implementation and needs 16 cycles to complete  a full encryption/decryption cycle. \r\n- 0.18u UMC ASIC process: >155Mhz 3K Gates \r\n- Xilinx Spartan IIe-50:  >100 MHz 1339 LUTs (87% device utilization)\r\n- Altera APEX 20KE-1: 1106 lcells >27MHz \r\n- Altera FLEX 10K50E-1: 1283 lcells >43MHz \r\n\r\n", "\r\nThis is a pipelined implementation that has a 16 cycle pipeline (plus 1 input and 1 output register). It can perform a complete  encryption/decryption every cycle. \r\n- 0.18u UMC ASIC process: >290Mhz 28K Gates \r\n- Xilinx Spartan IIe-200: 140 MHz 4448 LUTs (94% device utilization)\r\n- Altera APEX 20KE-1: 6688 lcells >53MHz \r\n- Altera FLEX 10K130E-1: 6485 lcells >76 Mhz \n        ", "\n            Nothing special about implementing the core.\n        ", "\n            - Thanks to Sakamoto Yasuhiro for providing a key select unit that is 50% smaller than the original ! It has been updated in the area optimized version, but might also be applicable for other versions.\r\n", "- Added a triple DES version\r\n", "- Added many more test vectors to the single DES version\r\n", "- Added Encrypt/Decrypt input (Thanks to Mark Cynar for providing the code)\r\n", "- Changed Directory Structure\r\n", "- Improved test benches\n        ", "\n            - 10/7/2004  RU - Updated key select unit in the are optimized version\r\n", "- 31/10/2002 RU - Added Triple DES versions\r\n", "- 28/9/2002 RU - Added Xilinx Spartan 2e synthesis results\r\n", "- 10/6/2001 RU - Updated Directory Structure, added encrypt/decrypt, improved test bench \r\n", "- 9/14/2000 RU - Initial release\r\n", "\n        ", "\n            "]},
{"details": ["\n    Name: descore", "\n    Created: Jul 25, 2013", "\n    Updated: Aug 10, 2013", "\n        SVN Updated: Aug 10, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the classic DES block cipher (iterative architecture).\n        "]},
{"details": ["\n    Name: btcminer", "\n    Created: Nov 25, 2011", "\n    Updated: Nov 28, 2012", "\n        SVN Updated: Nov 28, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            BTCMiner is a Bitcoin Miner software which allows you to make money with your ZTEX USB-FPGA Module. Since these FPGA Boards contain an USB interface no additional hardware (like JTAG programmer) is required and low cost FPGA-clusters can be build using standard USB hubs. \n        ", "\n            ", "\n            "]},
{"details": ["\n    Name: basicrsa", "\n    Created: Oct 13, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This core is strictly an encryption/decription engine. No attempt has been made to incorporate key generation, and no plans exist to do so.\r\n", "\r\n", "The core accepts a 1024-bit exponent, a 1024-bit modulus, and a 1024-bit message. After about 1 million clock cycles, it returns the encrypted or decrypted message on the output bus. There is nothing pretty, fast, or efficient about its operation. It simply uses a brute force approach to perform the required modular exponentiation. Operation is described in more detail in comments in the source.\r\n", "\r\n", "BasicRSA was written in VHDL using Xilinx's ISE 5.2i. It has been tested using ModelSim XE for 32-bit data, but has not been verified for larger bus widths, nor has it been tested in actual hardware. This core is intended primarily as a learning vehicle for me, and any comments or suggestions to make it better will be appreciated.\n        ", "\n            - It works for up to 1024-bit modulus (Tested at 32-bit modulus).\r\n", "- It fits in a Xilinx Virtex II XC2V8000.\r\n", "- Clock Rate at 32-bit modulus approximately 16MHz.\r\n", "- Clock Rate at 1024-bit modulus approximately 10MHz.\r\n", "- Cycles required to complete operation at n-bit modulus, slightly greater than n-squared clocks.\n        ", "\n            - Long carry chains in adders and subtracters are the main reason for the low clock rates.\r\n", "- Experimentation has determined that carry lookahead adders automatically synthesized by ISE are about as good as it gets. Pipelining partial adders could improve throughput, but only at a tremendous cost in gate count.\r\n", "- Project status has been changed to \"Stable\" because no improvements have been discovered or suggested to the author.\n        "]},
{"details": ["\n    Name: b163arith", "\n    Created: Jul 25, 2013", "\n    Updated: Sep 28, 2013", "\n        SVN Updated: Sep 28, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Bit-serial multiplication on the NIST B-163 curve. \r\n", "\r\n", "This implementation utilizes DSP481E blocks (Artix-7 FPGA).\n        "]},
{"details": ["\n    Name: basicdes", "\n    Created: Oct 13, 2003", "\n    Updated: Nov  6, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The BasicDES Cryptography Core is a small, fast implementation of the DES-56 encryption standard. It perfoms single DES encryption and decryption functions in ECB mode, and can accept a new key for each operation without performance cost. With additional wrapper logic, CBC, CFB and Triple DES modes can also be supported. \n        ", "\n            The DES-56 cypher is a block cypher operating on 64-bit blocks. A 64-bit key is used, of which every eighth bit is ignored, giving an actual key size of 56 bits. Using a predetermined convolution pattern, 16 round keys are generated from the  cypher key. In ECB mode, each block is processed without reference to the preceding or succeeding block, as follows:\r\n", "\r\n", "- An initial data convolution swaps the bits of the message block in a specific pattern. \r\n", "- 16 identical rounds of encryption processing are performed. For each round: \r\n", "- The 64-bit input block is considered as two 32-bit blocks, called left and right. \r\n", "- The right block is output without further processing as the left block for the next round. \r\n", "- The right block is expanded from 32 to 56 bits, and exclusive-ored with the current round key. \r\n", "- The resulting 56 bit string is substituted in 6-bit groups with 4-bit S-boxes, giving a 32-bit result. \r\n", "- The bits of this string are swapped according to a fixed convolution pattern, and the result is exclusive-ored with the left block. \r\n", "- The resulting 32-bit block is output as the right input block for the next round. \r\n", "\r\n", "After 16 rounds have been completed, a final data convolution swaps the bits of the output block in a fixed pattern to produce the cyphertext. \r\n", "\r\n", "Decryption is simply the encryption process with the round keys applied in reverse order.\n        ", "\n            - ECB mode encryption/decryption\r\n", "- Each operation is independent. Encryption and decryption operations can be interleaved as required. \r\n", "- Zero time key processing. A new key can be specified for each operation without affecting performance. \r\n", "- Each 64-bit encryption or decryption operation is completed within 17 clock cycles, from rising edge of DS to rising edge of RDY.\r\n", "- Maximum clock rate is approximately 179MHz.\r\n", "- Maximum sustainable throughput is approximately 670 Mbps. \r\n", "Device Utilization and Performance \r\n", "The Virtex2 implementation of this core occupies approximately: \r\n", "- 789 slices \r\n", "- 1457 4-input LUT's \r\n", "- 17,047 equivalent gates \n        ", "\n            - Documentation has been improved.\r\n", "\r\n", "\r\n", "Perttu Fagerlund has added the following:\r\n", "- Key handling has been improved by Perttu Fagerlund. The 1.2 core occupies less than half the logic cells that the 1.1 core occupied. The utilization statistics listed above are for  the 1.1 version.\r\n", "- Optional functionality for the RDY signal in 1.2: The rdy signal will be set low at reset. Otherwise, it behaves as in version 1.1.\r\n", "- Optional signals in the interface: RDY_NEXT_CYCLE, when high, indicates that output data will be valid on the following clock. RDY_NEXT_NEXT_CYCLE, when high, indicates that output will be ready on the second following clock. These signals may be commented out or left unconnected depending on your requirements.\r\n", "\r\n", "\r\n", "Note: The test bench is for the 1.1 version. It does not use the optional signals defined in the 1.2 version.\r\n", "\n        ", "\n            - RST - The reset signal is used to set all internal signals to a known state and prepare the core for operation. It should be strobed high at least once after power on and before attempting the first cryptographic operation. \r\n", "\r\n", "- IKEY - part of the input data set, the 64-bit input cypher key must be presented with each input data block. The core expects this bus to be valid on the rising edge of the DS signal. \r\n", "\r\n", "- IMSG0 - part of the input data set, the 64-bit input message block must be presented for each cryptographic operation. The core expects this bus to be valid on the rising edge of the DS signal. \r\n", "\r\n", "- DECRYPT - part of the input data set, the DECRYPT signal indicates the direction of the cryptographic operation. When 0, the core expects the imsg0 bus to hold plaintext to be encrypted to cyphertext. When 1, the core expects the imsg0 bus to hold cypertext to be decrypted to plaintext. This signal must be valid on the rising edge of the DS signal. \r\n", "\r\n", "- DS - the DS signal is the data strobe. When momentarily strobed high, it indicates the input data set is valid, and signals the core to start a cryptographic operation. Only the rising edge of this signal has meaning: all other states are ignored. \r\n", "\r\n", "- ODATA - the 64-bit output data bus is used to export the result of the cryptographic operation from the core. This bus is guaranteed to carry valid data on the rising edge of the RDY signal. \r\n", "\r\n", "- RDY - the RDY signal has two purposes: first, when high, it indicates that the core is idle and ready to receive input data. Second, when this signal transitions from low to high it indicates that the result of the last cryptographic operation is valid and available on the ODATA bus. The ODATA bus retains its last assigned value until the next rising edge of RDY, or until RST is asserted.\n        "]},
{"details": ["\n    Name: aes_128_192_256", "\n    Created: May 10, 2006", "\n    Updated: Nov 24, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Description of project..\n        ", "\n            - AES encoder\r\n", "  - 128/192/256 bit\r\n", "- AES decoder\r\n", "  - 128/192/256 bit\n        ", "\n            - Key Expansion added\r\n", "- Encoder added\r\n", "- Decoder added\r\n", "- Documentation added\r\n", "\n        "]},
{"details": ["\n    Name: threeaesc", "\n    Created: Sep 28, 2013", "\n    Updated: Sep 29, 2013", "\n        SVN Updated: Sep 29, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Three different implementations of the AES-128 (VHDL).\n        "]},
{"details": ["\n    Name: avs_aes", "\n    Created: May 17, 2009", "\n    Updated: Oct 11, 2017", "\n        SVN Updated: Apr 19, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 6 reported / 5 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            I know there are plenty of AES (Rijndael) implementations around. I created my own anyway because I was unhappy with either the implementation language (I don't know Verilog and I think its an ugly language), the documentation or the performance/resource usage of the ones I found on the net. ", "\n            1.) @anybody with Wishbone experience: can you write an interface or adapt it to whishbone? It should be no problem for the standard signals, however I found no clue how to handle IRQ for wishbone.\r\n", "Possibly check it with openrisc?\r\n", "2.) Write a VHDL configuration for choosing the architectures used in the generate statements. especially to switch between Altera M4K-Block bases sbox-ROMs and generic ones.\r\n", "3.) Increase performance for configurations with both encrypt and decrypt datapath. currently keyexpansion is shared and result signals are multiplexed which leads to drastic decline of f_max. (95MHz for encrypt vs. 65MHz for encrpyt+decrypt).\r\n", "\n        "]},
{"details": ["\n    Name: aes-128_pipelined_encryption", "\n    Created: Sep  6, 2013", "\n    Updated: Jun 30, 2016", "\n        SVN Updated: Sep  8, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 4 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The AES-128 pipelined cipher module uses AES algorithm which is a symmetric block cipher to encrypt (encipher) information. Encryption converts data to an unintelligible form called ciphertext .Here the AES algorithm is capable of using cryptographic keys of 128bit to do this conversion .This module is optimized for speed as it pipeline hardware to perform repeated sequence called round. This module synthesized  on Xilinx virtex 6 6vcx240tff784-2 board using ISE. Fuctional and gate level simulation were done using AES validation suite (AESVS) vectors \n        ", "\n            -128 bit data\r\n", "-128 bit Cipher Key\r\n", "-One Clock domain\r\n", "-Optimized for speed\r\n", "-Pipelined architecture\r\n", "-Generic RTL (vendor independent)\n        "]},
{"details": ["\n    Name: aes_crypto_core", "\n    Created: Dec  7, 2004", "\n    Updated: Mar 26, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This Core implements the Advanced Encryption Standard (Rijndael Algorithm) according to the NIST standard as documented in FIPS-197.\r\n", "This AES core is developed for a key size of 128 bits and operates in ECB mode. \r\n", "The project contains a synthesizable RTL along with a Test Bench set up to verify the Core with test vectors as described in the FIPS document.\n        ", "\n            Input and Key size of 128 bits.\r\n", "Operation in ECB mode.\r\n", "Performance adheres to FIPS-197.\r\n", "Core with high speed and low latency.\r\n", "RTL and TB in VHDL.\r\n", "\n        ", "\n            Core verified in simulation and uploaded.\n        "]},
{"details": ["\n    Name: tiny_aes", "\n    Created: Oct 13, 2012", "\n    Updated: Dec 14, 2015", "\n        SVN Updated: Feb 21, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            AES (Advanced Encryption Standard) is a specification published by \r\n", "the American National Institute of Standards and Technology in 2001, as FIPS 197.[1]\r\n", "\r\n", "AES describes a symmetric-key algorithm, in which the same key is used for \r\n", "both encrypting and decrypting the data. The block size is restricted to 128 bits. \r\n", "The key size can be 128, 192, or 256 bits. [1]\r\n", "\r\n", "AES operates on a 4\u00d74 matrix of bytes, called the state. Some rounds of transformation \r\n", "converts the plaintext into the final cipher-text. The number of rounds is six plus \r\n", "the key size divided by 32. One round reads the state into four 4-byte variables \r\n", "y_0,y_1,y_2,y_3; transforms the variables; xor\u2019s them by a 16-byte round key; \r\n", "and puts the result into z_0,z_1,z_2,z_3.[3]\r\n", "\r\n", "When targeting a variable-length plaintext, the plaintext must first be partitioned \r\n", "into separate cipher blocks, and then be encrypted under some mode of operation, \r\n", "generally using randomization based on an additional initialization vector.[4]\r\n", "\r\n", "The cipher feedback (CFB) mode, output feedback (OFB) mode are specified in FIPS 81. \r\n", "The counter (CTR) mode is specified by NIST in SP800-38A.[4] The advantage of these \r\n", "modes is only using encryption algorithm for both encryption and decryption. \r\n", "So the AES hardware price may be reduced by 50% (not need decryption hardware).\r\n", "\r\n", "This project has implemented AES encryption algorithm. \r\n", "\r\n", "This project provides three cores, doing AES-128, AES-192 and AES-256 encryption separately.\r\n", "\r\n", "The cores can be used in cipher feedback (CFB) mode, output feedback (OFB) mode, \r\n", "and counter (CTR) mode. \r\n", "\r\n", "[1]\tAdvanced Encryption Standard, ", "\r\n", "[2]\tJ. Daemen and V. Rijmen. AES proposal: Rijndael. Original AES Submission to NIST, 1999.\r\n", "[3]\tD. J. Bernstein and P. Schwabe. New AES software speed records. In INDOCRYPT 2008, volume 5365 of LNCS, pages 322-336, 2008.\r\n", "[4]\tBlock cipher modes of operation, ", "\r\n", "\n        ", "\n            ", "Suppose you use \"aes_256\" module, and the operation mode is CTR.", "To encrypt something, let \"aes_256.state\" be a successive values of a \"counter\".", "Then \"aes_256.out\" is a binary sequence. Xor the binary sequence to the plain text to get the cipher text.", "To decrypt something, let \"aes_256.state\" be a successive values of the SAME \"counter\".", "Then \"aes_256.out\" is the SAME binary sequence. Xor the binary sequence to the cipher text to get the plain text.", "If you feel it against intuition, please read\r\n", "\r\n", "\n            - Pipeline architecture\r\n", "- Ultra high speed\r\n", "- Fully synchronous design \r\n", "- Fully synthesize-able \r\n", "- ONLY ONE clock domain in entire core \r\n", "- NO latch \r\n", "- All output signals are buffered \r\n", "- Vendor-independent code\n        ", "\n            The maximum frequency is 324.6 MHz (on Xilinx FPGA XC6VLX240T, \r\n", "for all of AES-128, AES-192 and AES-256 implementation).\r\n", "\r\n", "The core can encrypt 128 bit per clock cycle.\r\n", "The throughput is 38.4 G bit /second (=4.8 G bytes/sec) if it is working with a 300 MHz clock.\n        ", "\n            ", "\n        ", "\n            ", "\n            This project is licensed under the Apache License, version 2.\n        "]},
{"details": ["\n    Name: systemcaes", "\n    Created: Jul  2, 2004", "\n    Updated: Apr  9, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            - SystemC and Verilog code is provided\r\n", "- Verified using TLM(Transaction Level Modelling Style)\r\n", "- Encoder and decoder in the same block\r\n", "\r\n", "This work is given by Universidad Rey Juan Carlos (Spain)\r\n", "www.gdhwsw.urjc.es\n        ", "\n            - 128 bits low area implementation uploaded\r\n", "- 192 bits low area implementation uploaded\n        ", "\n            Here you can find two different implementations of AES encryption algorithm:\r\n", "     - A 128 bits AES algorithm focusing on very low area applications.\r\n", "     - A 192 bits AES algorithm focusing on very low area applications.\r\n", "  \r\n", "The 128 bits low area implementation takes about 500 cycles to encrypt/decrypt a block. \r\n", "The 192 bits low area implementation takes about 280 cycles to encrypt/decrypt a block. \r\n", "They don't use memories to store the S-box and have many other architectural improvements to reduce the area comsumption.\r\n", "\r\n", "Implements the encoder and decoder in the same block.\r\n", "\r\n", "The cores were written in SystemC RTL, and verified using TLM(Transaction Level Modelling Style).\r\n", "\r\n", "Verilog synthesizable code  is also provided\r\n", "\r\n", "All implementations have been tested on a Xilinx Virtex2 FPGA succesfully.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: 3des_vhdl", "\n    Created: Oct 27, 2006", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a VHDL implementation of Triple-DES (pipelined) and DES cryptographic algorithms, as recommended by NIST.\r\n", "\r\n", "In our tests the core has been verified to comply with the ", " (NIST FIPS 46-3) (DES)recommendation.\r\n", "\r\n", "This core is provided by:\r\n", " (Coretex Systems, LLC)\n        ", "\n            - Pipelined architecture.\r\n", "\r\n", "- VHDL source code.\r\n", "\r\n", "- Verified in hardware.\r\n", "\r\n", "- Small footprint (the numbers are for Xilinx Virtex 2 FPGA)\r\n", "  - 1742 slices,\r\n", "  - 302 IOBs,\r\n", "  - no block RAMs,\r\n", "  - 1 GCLK.\r\n", "\r\n", "- Fast processing (the numbers assume the pipeline is fully utilized)\r\n", "  - An output each 17 clocks.\r\n", "  - Maximum operating frequency 162 MHz.\r\n", "  - Bandwidth ~581 Mb/s.\r\n", "\n        ", "\n            - The code is verified, documentation to be added.\r\n", "- We are working on an extension to support the Wishbone interface.\n        "]},
{"details": ["\n    Name: yanu", "\n    Created: Jun 10, 2009", "\n    Updated: Jan 26, 2017", "\n        SVN Updated: Jun 15, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            YANU (Yet Another Niosii Uart) has been built from scratch with the efficiency in mind in term of CPU load. A complete uCLinux TTY driver has been developed.\r\n", "Its main feature is that it has a TX and and RX FIFO buffers with a predictive \"event to interrupt\" generation.\r\n", "This will lead to a lower CPU usage needs in high efficiency point to point communication links at high baud rates.\r\n", "It has a fractional prescaler so that almost any baud rate can be generated from any input clock frequency.\r\n", "It detects all the common asynchronous errors (Parity,Framing,Overrun).\r\n", "It is programmable in terms of hardware handshake, number of bits and stop bits; it can generate break conditions, etc...\r\n", "It has an Avalon compliant bus interface and it has been tested successfully in Altera FPGAs (average logic block usage is 330 logic cells in CycloneIII family).\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: fpu", "\n    Created: Sep 25, 2001", "\n    Updated: Sep  1, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a single precision floating point unit. It is fully IEEE 754 compliant. It can currently perform Add/Sub,  Mul and Divide operations, as well as integer to floating point and floating point to integer conversions. It supports four rounding modes: Round to Nearest Even, Round to Zero, Round to +INF and Round to -INF. \r\n", "\r\n", "There is now also a separate FP compare unit. It is located in the fpu/fcmp directory. \n        ", "\n            - A 100% IEEE 754 compliant Floating Point Unit \r\n", "- Usable by the OR1K CPU \r\n", "- Options to extend the core \r\n", "- Free !\n        ", "\n            To the best of my knowledge the FPU is 100% IEEE 754 compliant. I have run over 14Mil. test vectors on it,  that where generated using the SoftFloat library by John R. Hauser, which can be found at: ", ". \r\nThe test pattern generator is included with the distribution. \r\n\n        ", "\n            - Single cycle execution \r\n", "- 4 stage pipeline\n        ", "\n            It is very difficult to partition such a complex piece of hardware for optimal pipe lining. Therefore you will need a synthesis tool that has a \"retiring\" feature to obtain best results. \r\n", "\r\n", "Actual Add/Sub, Multiply and Divide cores must be replaced in the primitives.v file, or your synthesis tool must be able to synthesize them for you. I might fix this in the future. \r\n        ", "\n            - Second version of the core is released. Included with the release is also a  test bench and a test pattern generator. \r\n", "- I won't be doing any more work on the core in the near future, except for bug fixes. \r\n", "- The core can be downloaded from OpenCores CVS via cvsweb or via cvsget (use fpu for module name) \r\n", "  \n        ", "\n            - Add a remainder function \r\n", "- Predict leading zeros to improve performance of post normalize unit \n        ", "\n            - 9/16/00 RU Added FP compare unit \r\n", "- 9/15/00 RU Added int to float and float to int conversion \r\n", "- 9/15/00 RU Fixed documentation \r\n", "- 9/13/200 RU Initial release \r\n        ", "\n            "]},
{"details": ["\n    Name: cf_rca", "\n    Created: Aug 20, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nSeveral cores are provided in Verilog, Vhdl, and C.  If you don't see the configuration you need, chances are we can easily generate it for you.\r\n\r\nThe Reconfigurable Computing Array (RCA) is a platform for dynamic reconfigurable computing.  RCA consists of a fine-grained array of reconfigurable \"square\" logic tiles.  Similar to an FPGA CLB, a tile can be programmed to perform a wide variety of functions.\n        ", "\n            ", "\r\n\r\nUnlike FPGAs, RCA has no routing fabric.  Rather, all tiles\r\ncommunicate directly with their nearest neighbor, i.e., north, south, west, east.\r\nBecause a tile's inputs are registered, the lack of routing fabric\r\nprevents end-to-end combinatorial logic design that is possible with general\r\npurpose FPGAs.\r\n\r\nHowever, the advantage of \"hard-wiring\" tiles is 2 fold: greater logic density\r\nand improved speed.  FPGAs consume 80-90% of their area on routing; only 10%\r\nyields useful logic in the form of CLBs.  Without the routing fabric, it is possible RCA\r\ncan increase logic density by a factor of 10.\r\n\r\nSecondly, because signals are registered across tile boundaries, timing is\r\ndeterministic and constant.  Further more, since tiles are fine-grained, clocks rates\r\ninto the GHz should be possible.\r\n\r\nThe goal of this project is to develop an understanding of optimal tile architecture\r\ntrade-offs and RCA compiler technology.\r\n\r\n\r\n", "\r\n\r\nA tile is square, having four 1-bit inputs and four 1-bit outputs named\r\nnorth, south, west, and east.  An array is a collection of tiles organized\r\nlike a checkerboard, each side connecting to an adjacent tile.  For instance, the east output of\r\na tile of the left plugs into the west input of a tile on the right.\r\n\r\nIn terms of tile architecture, there are several possibilities.\r\nThe initial architecture is based on 3-to-1 look-up tables (LUTs).\r\nThere are four LUTs per tile -- one for each direction -- each LUT with three\r\n8-to-1 multiplexers for input data selection.\r\n\r\nThe following illustrates the tile architecture (only the north datapath shown):\r\n\r\n", "\r\n\r\n", "\r\n\r\nAt the top level, RCA has 4 input data buses and 4 output data buses;\r\nand input and output bus for each side of the array (N, S, W, E).\r\nBit 0 of \"north_i\", \"north_o\", \"south_i,\" and \"south_o\" corresponds to the western most tile.\r\nLikewise, bit 0 of \"west_i\", \"west_o\", \"east_i\", and \"east_o\" corresponds to\r\nthe northern most tile.  All tile interconnection registers are synchronized\r\non the \"clock_main_c\" clock.\r\n\r\nIn addition to the data busses, the configuration bus handles the programming and\r\nreconfiguration of the array.  Configuration is synchronized on the \"clock_config_c\" clock.\r\nEach data path within each tile is addressable.\r\nConfiguration addressing is as follows (msb on the left):\r\n\r\n- ConfigAddr = {RowSelect, ColSelect, DirSelect}\r\n  - RowSelect of 0 corresponds to the northern most row.\r\n  - ColSelect of 0 corresponds to the wester most column.\r\n  - DirSelect: 00=north, 01=south, 10=west, 11=east.\r\n\r\nThe configuration data is 18-bits.  It defines the LUT function,\r\nthe input MUX selection, and the output MUX selection, for a specify tile\r\ndatapath.  The follow defines the configuration data format:\r\n\r\n- ConfigData[17]    : Output Select (0=direct, 1=registered)\r\n- ConfigData[16:14] : Input Select 2\r\n- ConfigData[13:11] : Input Select 1\r\n- ConfigData[10:8]  : Input Select 0\r\n  - 000=north_in\r\n  - 001=south_in\r\n  - 010=west_in\r\n  - 011=east_in\r\n  - 100=north_state\r\n  - 101=south_state\r\n  - 110=west_state\r\n  - 111=east_state\r\n- ConfigData[7:0]   : LUT data  {f(7), f(6), f(5), f(4), f(3), f(2), f(1), f(0)}\r\n\r\n", "\r\n\r\nWith the lack of routing fabric, data routing is performed in the configuration of each tile.\r\nBecause every tile input is registered, designs on RCA are micro-pipelined.\r\nTo simplify pipeline data aliment, each tile output can come directly from the LUT\r\nor delayed 1 cycle though an output register.\r\n\r\nWith each tile having 4 independent datapaths (N, S, W, E), function and routing can be\r\ngrouped onto the same tile.  For instance, a function can be performed from West and South to East,\r\nwhile at the same time data is routed from North to South.  Note the South input and South output are\r\nseparate datapaths.\r\n\r\n", "\r\n\r\nAs with platform FPGAs, RCA can benefit from specialized embedded components,\r\nsuch as block ram, hardware multipliers, and processors.  Implementing embedded\r\ncomponents is possible by replacing internal tiles groups with hard IP.\r\n        "]},
{"details": ["\n    Name: aes_core", "\n    Created: Nov  8, 2002", "\n    Updated: Sep 15, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Simple AES (Rijndael) IP Core.\r\n\r\nI have tried to balance this implementation and to trade off size and performance. The goal was to be able to fit in to a low cost Xilinx Spartan series FPGA and still be as fast as possible.\r\nAs one can see from the implementation results below, this goal has been achieved !\r\n\r\nOther Implementations of this standard with different key sizes (192 & 256 bit) and performance attributes (like a fully pipelined ultra-high-speed version) are commercially available from ", ".\r\n\r\nEven though no official testing has been performed we believe that this core is fully complies to ", ".\r\n\r\nFor more information see the core documentation.\r\n        ", "\n            ", "\n            - Nov 12, 2002 Found a bunch of test vectors on the NIST site, added them today to the testbench. Added missing timescale.v file.\r\n", "- I could use some \"official\" testvectors. If you know were to get them or have any, please contact the author.\r\n", "- This core is done. Initial Release: Nov. 9, 2002\r\n        ", "\n            "]},
{"details": ["\n    Name: jt51", "\n    Created: Oct 18, 2016", "\n    Updated: Oct 26, 2016", "\n        SVN Updated: Oct 29, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The JT51 is an 8-channel FM sound synthesiser. Each channel is composed of four operators that can be arranged in eight different connections. Vibratto, ADSR envelope and noise are also featured. JT51 is software compatible with the YM2151 (\u00a9 Yamaha) and can be embedded in an FPGA as part of a complete music system with special focus in video games and hobby computers.\n        "]},
{"details": ["\n    Name: wb_lpc", "\n    Created: Mar  1, 2008", "\n    Updated: Jan 31, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 13 reported / 5 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Wishbone to LPC (Low-Pin Count) Bridge, includes master and slave modules.  Supports 8-bit I/O Read and Write cycles, 8-bit Memory Read/Write cycles, DMA cycles, and up to 32-bit Firmware memory read/write cycles.  Serial IRQ support is also provided.\r\n", "\r\n", "None of this has been tested (yet) with a third-party LPC Peripheral or Host.\n        ", "\n            - Compliant to Intel(r) Low Pin Count (LPC) Interface Specification Revision 1.1\r\n", "- Wishbone Slave to LPC Host Module\r\n", "  - Memory Read and Write (1-byte)\r\n", "  - I/O Read and Write (1-byte)\r\n", "  - Firmware Memory Read and Write (1-, 2- and 4-byte)\r\n", "  - DMA support\r\n", "- Wishbone Master to LPC Peripheral Module\r\n", "  - Memory Read and Write (1-byte)\r\n", "  - I/O Read and Write (1-byte)\r\n", "  - Firmware Memory Read and Write (1-, 2- and 4-byte)\r\n", "  - DMA support\r\n", "- Serial IRQ Host and Slave Controllers\r\n", "  - Supports \"Serialized IRQ Support for PCI Systems\" Rev 6.0 Specification.\r\n", "  - Continuous and Quiet modes.\r\n", "  - 32 interrupts supported.\r\n", "- Test bench and project file for Xilinx ISE 10.1 included.\r\n", "- Example applications (Uses the Enterpoint Raggedstone1 PCI Card) ", "\r\n", "  - PCI to LPC Host Controller, with Interrupt support  (uses pci32tlite core on OpenCores)\r\n", "  - LPC to 7-segment display.\r\n", "- Fully static synchronous design with one clock domain \r\n", "- Technology independent Verilog \r\n", "- Fully synthesizable\r\n", "\n        ", "\n            - Tested in simulation\r\n", "- Tested in Spartan3 FPGA\r\n", "- LPC Host has only tested with LPC Peripheral bridge, not with actual LPC devices.\r\n", "- 2008-07-22: Fixed bug: Spec violation for multi-byte firmware accesses\r\n", "- Tested with LPC eVC written by Daniel Preda, which found all of the bugs in Tracker: ", "\r\n", "\n        ", "\n            - Intel LPC Bus Specificaton, Revision 1.1: ", "\r\n", "- Serialized IRQ Support for PCI Systems, Revision 6.0: ", "\r\n", "- Implementing Industry Standard Architecture (ISA) with Intel(r) Express Chipsets (White Paper): ", "\r\n", "- LPC Bus Information from Wikipedia: ", "\r\n", "- Raggedstone1 Spartan3 PCI Card details: ", "\n        "]},
{"details": ["\n    Name: vspi", "\n    Created: Mar 22, 2012", "\n    Updated: Mar 26, 2012", "\n        SVN Updated: Mar 23, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            === What's \"vSPI\"? ===\r\n", "\r\n", "vSPI is a Verilog implementation of an SPI slave. Think of it as a very fast serial port. It can reliably transfer data at 27.9 mbps on an Atlys FPGA devkit (a Spartan-6 with a 100 MHz system clock).\r\n", "\r\n", "You can use it to send data between your FPGA/ASIC project and other devices, such as a desktop computer I'm using it to send data between a self-flying RC-helicopter and my PC. If all goes according to plan, I'll be able to see live video from the helicopter's camera on my PC. I'll also be able to inject test data and make sure my logic works with known test vectors.\r\n", "\r\n", "=== What's included? ===\r\n", "\r\n", "So far, vSPI consists of three parts:\r\n", "\r\n", "- spiifc: The minimal logic that implements the SPI slave. spiifc takes the usual four SPI lines (MOSI, MISO, SS, SCLK) and has interfaces for input and output buffer memories as well as a register bank (more on what they do is below). If you work directly with spiifc, you'll need to figure out how to get this stuff to interface with the rest of your project. This is a good place to start if you have a project without a system bus or a non-PLB bus.\r\n", "\r\n", "- PLB interface: vSPI includes also includes a PLB interface if desired. PLB is one of the system bus protocols supported by the Microblaze processor provided in Xilinx's EDK (sometimes known as XPS). I may also add support for one of ARM's AMBA bus protocols later (AXI, etc.), but there is zero support for thst right now.\r\n", "\r\n", "- spilib python library: spilib is a python library that is used on your PC to make talking with spiifc easier. It is currently built on TotalPhase's Cheetah SPI USB/SPI adapter API. It makes interactions between a PC (master) and spiifc (slave) simple.\r\n", "\r\n", "The full documentation is available in the Downloads section or directly using this link: ", "\r\n", "\r\n", "=== Development Notice ===\r\n", "\r\n", "Day-to-day development is managed on github at ", " If you would like cutting edge updates or would like to contribute, please use github.\r\n", "\r\n", "This opencores project will be updated after the completion of any stable releases. If you just want to use stable releases, feel free to use the opencores project. You won't miss out on anything.\r\n", "\r\n", "=== License ===\r\n", "\r\n", "If you use vSPI, whether for free or commercial purposes, I only ask that you let me know so that I can publicly keep track of who is using it. I don't care if you use it as is or modify it, so long as it isn't used in technologies to physically hurt or kill anyone (missile guidance systems, etc.).\r\n", "\r\n", "If you want to use vSPI for any reason but wish to do so without publicly stating so, we can work out an alternative licensing agreement.\r\n", "\r\n", "The vSPI project retains all ownership of code published here. Meaning, don't take the code, claim ownership, and then somehow sue the vSPI project.\r\n", "\r\n", "=== Contact Info ===\r\n", "\r\n", "You can reach me at buzz.vspi@clearhive.com.\n        "]},
{"details": ["\n    Name: usb_host_core", "\n    Created: Jul 12, 2015", "\n    Updated: Jul 26, 2015", "\n        SVN Updated: Jul 26, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This IP core is a cutdown USB host controller which allows communications with full-speed (12mbps) USB devices.\r\n", "\r\n", "The IP is accessed via a Wishbone slave interface (asynchronous read result) for control, status and data.\r\n", "\r\n", "Data to be sent or received is stored in some internal FIFOs (which are configurable in size). The data is accessed through the Wishbone slave port. There is no DMA engine (e.g. a bus mastering interface) associated with this IP.\r\n", "\r\n", "The core functions well, is very small, but is fairly inefficient in terms of CPU cycles required to perform USB transfers.\r\n", "This core is not compliant with any standard USB host interface specification, e.g OHCI or EHCI.\n        ", "\n            Instance usbh and hookup to UTMI PHY interface and a Wishbone master (e.g. from your CPU).\r\n", "The core requires a 48MHz clock input.\n        ", "\n            Verified under simulation and on FPGA with various USB devices attached (hubs, mass storage, network devices).\n        ", "\n            TX_FIFO_DEPTH  - Transmit FIFO size\r\n", "TX_FIFO_ADDR_W - Transmit FIFO size (width of size field)\r\n", "RX_FIFO_DEPTH  - Receive FIFO size\r\n", "RX_FIFO_ADDR_W - Receive FIFO size (width of size field)\n        ", "\n            With the default configuration...\r\n", "\r\n", "* the design contains 214 flops, 2 RAM cells (RX and TX FIFOs)\r\n", "* synthesizes to more than the required 48MHz on a Xilinx Spartan 6 LX9 (speed -3)\n        "]},
{"details": ["\n    Name: usb11_phy_translation", "\n    Created: Feb 10, 2011", "\n    Updated: Jun  5, 2016", "\n        SVN Updated: Jun  5, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a Verilog to VHDL translation of Rudolf Usselmanns USB 1.1 PHY. \r\n", "Since the original design operates with a 48 MHz clock and I required a 60 MHz version I added also a modified version with a 60 MHz clock section - the changes are only in file usb_rx_phy_60MHz.vhdl (the unmodified version usb_rx_phy.vhdl is also provided).\r\n", "The design has been simulated using the USB 1.1 Simulation model.\r\n", "\r\n", "An update to the usb_tx_phy.vhdl source corrects the recently reported bit-stuffing issue (USB spec:\"If required by the bit stuffing rules, a zero bit will be inserted even if it is the last bit before the end-of-packet (EOP) signal.\"). \r\n", "This issue caused very rare (but hard to find) problems.\r\n", "This correction applies only the VHDL code (the original verilog code is not in this focus).\r\n", "\n        "]},
{"details": ["\n    Name: usb_ft232h_avalon-mm_interface", "\n    Created: May 31, 2016", "\n    Updated: Jun 20, 2017", "\n        SVN Updated: Jun 20, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This core implements the Altera Avalon-MM interface for FTDI FT232H device in FT245 Synchronous FIFO mode. \r\n", "The core has internal FIFOs on the receive and transmit.\r\n", "Tested with Scatter-Gather DMA and DMA Controller cores.\r\n", "For more information about FT232H and FT245 Synchronous FIFO Mode visit ", "\r\n", "Included: Verilog core, NIOS2 header file, NIOS2 test application, PC test application.\r\n", "Upd: \r\n", "* IP completely rewritten. \r\n", "* Code divided into configurable parts.\r\n", "* Improved stability.\r\n", "* Add testbench \n        "]},
{"details": ["\n    Name: usb", "\n    Created: Sep 25, 2001", "\n    Updated: Jul 27, 2013", "\n        SVN Updated: May  5, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a USB 2.0 compliant core. USB 2.0 allows data transfers of 480 Mb/s. Because of the high interface speed, an external PHY will be required with this core. A industry standard PHY interface for USB has been developed. This interface is called USB Transceiver Macrocell Interface or UTMI for short. The host interface of the USB core will be WISHBONE SoC compliant. \r\n\r\nMore information about the USB standard and a full specification can be found at ", " \r\n\r\nMore information about the WISHBONE SoC and a full specification can be found ", ". \r\n\r\nThe UTMI specification (and various other useful USB papers) can be downloaded from ", ". \r\n\r\nFor further information, questions and general discussions related to the USB core, please visit the ", ". \r\n\n        ", "\n            - 8/2/2001 New Directory Structure ! We have agreed on a common directory structure at OpenCores.  \r\n- Second release is checked in ! [March 31, 2001]  \r\n  - The Core is now configurable  \r\n  - Moved buffer memory (SSRAM) outside the core  \r\n  - Many small fixes and additions (see usb_doc for more details)  \r\n  - This is still a development version, see the doc/STATUS file for the actual status  \r\n  - Please do not make any modifications on the sources as I'm still actively working on the core  \r\n  - Please submit bugs and comments to the bugtracker\r\n  - PLEASE HELP: I'm still looking for people to help me verify the core  \n        ", "\n            "]},
{"details": ["\n    Name: usb_phy", "\n    Created: Sep 16, 2002", "\n    Updated: Jan 11, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 5 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Very simple USB 1.1 PHY. Includes all the goodies: serial/parallel\r\n", "conversion, bit stuffing/unstuffing, NRZI encoding decoding. Uses a\r\n", "simplified UTMI interface. Currently doesn't do any error checking in\r\n", "the RX section (should probably check for bit unstuffing errors).\r\n", "Otherwise complete and fully functional.\r\n", "\r\n", "There is currently no test bench available. This core is very simple\r\n", "and is proven in hardware. I see no point of writing a test bench at\r\n", "this time. \r\n", "\r\n", "I expect the users of this core to have some fundamental USB\r\n", "knowledge and be familiar with the UTMI specification and with the\r\n", "general USB transceivers (e.g. from philips). If you are not familiar\r\n", "with these two you should check out www.usb.org and read up on\r\n", "this subject ...\r\n", "\r\n", "\n        ", "\n            - FPGA or ASIC implementation possible\r\n", "- 8 bit wide unidirectional UTMI interface\r\n", "- serial   parallel conversion\r\n", "- bit stuffing/unstuffing\r\n", "- NRZI encoding/Decoding\r\n", "- DPLL\r\n", "- Implemented in Verilog\r\n", "- Fully synthesizable (runs well over the required 48MHz in a Spartan II)\r\n", "- Very small: 111 LUTs (7%) of Spartan II XC2S50\r\n        ", "\n            This core is fully functional and completed.\r\n", "It was verified in hardware in an XESS XVC800 FPGA prototype\r\n", "board with an USB 1.1 IP core I have written.\r\n", "\r\n        ", "\n            "]},
{"details": ["\n    Name: usb1_funct", "\n    Created: Sep 19, 2002", "\n    Updated: Sep 27, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            USB 1.1 slave/device IP core. Default configuration is 6 endpoints:\r\n", "1 Control, 1 Isochronous IN, 1, Isochronous Out, 1 Bulk IN, 1 Bulk\r\n", "Out, 1 Interrupt IN. Includes control engine, providing full enumeration\r\n", "process in hardware - no external micro-controller necessary.\r\n", "Derived from my USB 2.0 Function IP core, except all the high speed\r\n", "support logic has been ripped out and the interface was changed from\r\n", "shared memory to FIFO based.\r\n", "\r\n", "A basic test bench is now included as well.  It should be viewed\r\n", "as a starting point to write a more comprehensive and complete\r\n", "test bench.\r\n", "\r\n", "I expect the users of this core to have some fundamental USB knowledge\r\n", "and be familiar with the UTMI specification and with the general USB\r\n", "transceivers (e.g. from philips). If you are not familiar with these two\r\n", "you should check out www.usb.org and read up on this subject ... \n        ", "\n            - USB 1.1 Compliant Function\r\n", "- Hardware enumeration support\r\n", "- No micro controller/CPU required\r\n", "- FIFO based interface\r\n", "- Written In Verilog\r\n", "- Fully Synthesisable\r\n", "- Tested in Hardware \n        ", "\n            This core is fully functional and completed.\r\n", "It was verified in hardware in an XESS XCV800 FPGA prototype board.\r\n", "- Sept. 25 2002\r\n", "  - Added a basic test bench\r\n", "  - Changed Top Level\r\n", "\r\n        ", "\n            To use this IP core, you must also download the ", " , ", " and the ", " models.\r\n\n        ", "\n            "]},
{"details": ["\n    Name: usbhostslave", "\n    Created: Sep 30, 2004", "\n    Updated: Aug  8, 2013", "\n        SVN Updated: Mar 18, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Version 2.0 is now available. \r\n", "\r\n", "Design has been tested in simulation and hardware.\r\n", "\r\n", "To do. Still need to test isochronous mode, pre-amble mode, and all host mode features related to accessing a low speed device via a hub. \r\n", "Synthesizable under Quartus 7.2 SP3. Uses approximately 2700 logic cells in an Altera Cyclone EP2C20.\r\n", "\r\n", "\"Works like a champ for me.  Thank you. I did a PHY card for a Digilent Nexys2 board using a MAX8586 switch and a Philips SP1301 OTG PHY. I've used it in both Host and Device mode with no problems whatsoever.\" \r\n", "- Mike Kentley ", "\r\n", "\n        ", "\n            USBHostSlave is a USB 1.1 Host and Function IP core. It  supports full speed (12Mbps) and low speed (1.5Mbps) operation, and supports the four types of USB data transfer; control, bulk, interrupt, and isochronous transfers. USB Function has four endpoints, each with their own independent FIFO. All FIFO depths configurable via parameters. It has a 8-bit Wishbone slave bus interface.\r\n", "\r\n", "All the state machines have been designed using ActiveHDL FSM2HDL, so they are easily readable and understandable, but it is still possible to edit the Verilog RTL if so desired. Graphical state diagrams are used because they are much easier to understand than just RTL source code. Graphical state diagrams ease creation, maintenance, documentation, and re-use, of FSMs. Aldec ActiveHDL is an excellent tool for creating graphical state diagrams, only requiring a single .asf file per state machine module. This makes it easy to maintain the FSMs and incorporate them into your existing text based module hierarchy.\r\n", "\r\n", "For those who are targeting Altera FPGAS, there is a complete Quartus project for usbDevice. The project has been tested on an Altera development board, and requires a custom Santa Cruz daughter card. See downloads section for full schamatics and bill of materials.\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\n        ", "\n            - USB 1.1 Host and Function\r\n", "- Full and low speed.\r\n", "- Control, bulk, interrupt, and isochronous transfers\r\n", "- FIFO interface\r\n", "- FIFO depth configurable.\r\n", "- Automatic SOF generation\r\n", "- 8-bit Wishbone interface\r\n", "\n        ", "\n            Bus-turn-around time is compliant with low speed, but not full speed USB 1.1 specification. The USB 1.1 spec requires host or device to provide a response within 6.5 bit times in both full and low speed modes. Operating with a system clock of 48Mhz, usbhostslave currently provides a response within 1uS (12 full speed bit periods, 1.5 low speed bit times).  \r\n", "\r\n", "The USB 1.1 specification takes into account the worst case system configuration of 5 cascaded hubs, and 6 maximum length cables (see figure 7-31 in USB 1.1 spec), resulting in a worst case system bus-turn-around time of 16 full speed bits. So, operating with a system clock of 48MHz, usbhostslave will be within full speed system spec for 2 cascaded hubs, and 3 maximum length cables. Increasing clock speed to 96MHz would make the core USB 1.1 compliant.\n        ", "\n            A USB PHY daughter card compatible with usbhostslave is available;\r\n", "\r\n", "Santa Cruz format daughter card that supports many development kits from Altera and Microtronix.\n        ", "\n            Now available, Linux driver patch files for Linux 2.6.22 and 2.6.28. Thanks to Mario Becroft and Julian Vetter.\n        "]},
{"details": ["\n    Name: udp_ipv4_for_10g_ethernet", "\n    Created: May 12, 2017", "\n    Updated: May 22, 2017", "\n        SVN Updated: May 22, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The UDP/IPv4 for 10 G Ethernet IP core, implements mandatory parts of UDP, IPv4 and Ethernet (MAC) protocols. It is minimal implementation of complete RFC compliant UDP/IP stack.", "\r\n\r\nIt doesn\u2019t implement supporting protocols as Address Resolution Protocol (ARP \u2013 translating IP addresses to MAC addresses), Dynamic Host Configuration Protocol (DHCP \u2013 often use to assign IP addresses dynamically) or Internet Control Message Protocol (ICMP \u2013 services like ping). Services that are commonly provided by these protocols must be replaced by user defined mechanisms.", "\r\n\r\nThe main field for deployment of this core are high-speed data transfer applications mainly in controlled environment of local networks or simple peer-to-peer connections, but it is not limited to it.", "\r\n\r\nThe core is aimed to be used for 10 G Ethernet in both optic and metallic version (64bit XGMII internal interface). It is also ready to be used with PHYs that support up to six speeds \u2013 10 Gbps, 5 Gbps, 2.5 Gbps, 1 Gbps, 100 Mbps, 10 Mbps.", "\r\n\r\nThe core was released as part of ", " project. Xenie module is a HW platform equipped with six speed metallic 10GBASE-T Ethernet PHY that can be used for optical 10 G Ethernet too. Example design demonstrating usage of this UDP/IPv4 core can be found under Xenie project.", "\r\n\n        "]},
{"details": ["\n    Name: udp_ip__core", "\n    Created: Feb  9, 2010", "\n    Updated: Mar  7, 2014", "\n        SVN Updated: Dec 21, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of a UDP/IP core! Area-optimized for direct PC-FPGA communication!\r\n", "\r\n", "An advanced/versatile version of the core is included in the PC-FPGA Communication Platform project!\n        "]},
{"details": ["\n    Name: uart16550", "\n    Created: Sep 25, 2001", "\n    Updated: Aug 31, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 14 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            uart16550 is a 16550 compatible (mostly) UART core. \r\n", "\r\n", "The bus interface is WISHBONE SoC bus Rev. B.\r\n", "\r\n", "Features all the standard options of the 16550 UART: FIFO based operation, interrupt requests and other. \r\n", "\r\n", "The datasheet can be downloaded from the CVS tree along with the source code. \n        ", "\n            "]},
{"details": ["\n    Name: tdm", "\n    Created: Sep 25, 2001", "\n    Updated: Dec  5, 2001", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            - 8 bit parallel backend interface\r\n", "- Needs external Framer\r\n", "- Supports E1 bit rate and time slots (32 time slots or 32 DS0 channels at bit rate 2.048Mbps)\r\n", "- Supports ST-Bus (Serial Telecom bus) interface.\r\n", "- Routes time slots to/from HDLC controller via the backend interface and software support or to/from memory.\r\n", "- Supports read for all or partial TDM slots from the ST-bus.\r\n", "- Supports write for all or partial TDM slots to ST-bus.\r\n", "- Supports two serial lines one input and one output.Mli>9. It supports N\u00d764 mode (i.e. it supports sampling (or writing) to N consecutive time slots)\r\n", "- Supports two serial lines one input and one output.\r\n", "- Can be connected to other ST-Bus compatible devices via serial or star configurations.\r\n", "- If no data is available for transmission it sends all ones.\r\n", "- Backend interface uses the Wishbone bus interface which can be connected directly to the system or via FIFO buffer.\r\n", "- Optional External FIFO buffer, configuration and status registers.\r\n", "- The core will be made of two levels of hierarchies, the basic functionality and the Optional interfaces and buffers which makes it easy to add extra serial lines by duplicating the TDM controllers in parallel. \r\n", "- ISDN (2B+D) support can be supported by adding three parallel HDLC controllers on the first three time slots. \r\n", "- For complete specifications refer to spec document\n        ", "\n            FILE: tdm_top.jpg\n", "DESCRIPTION: Core top block diagram\n", "\n        ", "\n            - Code is ready for both TDM and ISDN controllers in the OpenCores CVS (see Download section). \r\n", "- Need help in verfying the design. \r\n        ", "\n            ", ": which includes ST-Bus interface that inserts/samples 32 channels and does the conversion between serial and parallel representation.\r\n"]},
{"details": ["\n    Name: uart_plb", "\n    Created: Jun  2, 2011", "\n    Updated: Jun  3, 2011", "\n        SVN Updated: Jun  3, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: uart16750", "\n    Created: Jan 14, 2009", "\n    Updated: May  6, 2013", "\n        SVN Updated: Aug  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 11 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Implements a 16550/16750 UART core.\n        ", "\n            - Full synchronous design\r\n", "- Pin compatible to 16550/16750\r\n", "- Register compatible to 16550/16750\r\n", "- Baudrate generator with clock enable\r\n", "- Supports 5/6/7/8 bit characters\r\n", "- None/Even/Odd parity bit generation and detection\r\n", "- Supports 1/1.5/2 stop bit generation\r\n", "- None or 16/64 byte FIFO mode\r\n", "- Receiver FIFO trigger levels 1/4/8/14/16/32/56\r\n", "- Control lines RTS/CTS/DTR/DSR/DCD/RI/OUT1/OUT2\r\n", "- Automatic flow control with RTS/CTS\r\n", "- All interrupt sources/modes\r\n", "\n        ", "\n            - Test script creation done, should cover most functions\r\n", "- Test log file available\r\n", "\r\n", "The core was synthesized on a Altera Cyclone II, connected to x86\r\n", "standard hardware and than tested with standard OS drivers from:\r\n", "\r\n", "- Linux 2.2/2.4/2.6\r\n", "- Windows 2000/XP/Vista\r\n", "- *BSD\r\n", "- *DOS\r\n", "\n        ", "\n            It's possible to simulate and test the design with GHDL.\r\n", "A Makefile is available for starting the simulation. The testbench\r\n", "creates a log file (uart_log.txt).\r\n", "\r\n", "\n        ", "\n            - Altera Cyclone II\r\n", " - 440 LE\r\n", " - 1216 memory bits\r\n", " - Frequency: 130 MHz\r\n", "\r\n", "- Xilinx Spartan 3E\r\n", " - 378 Slices\r\n", " - 1 RAMB\r\n", " - Frequency: 100 MHz\n        "]},
{"details": ["\n    Name: usb11", "\n    Created: May 10, 2004", "\n    Updated: Jul  9, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This project consists of the translation of the ", " Verilog code and dependencies, maintained by ", ", into a Synopsys CoCentric SystemC Compiler compatible SystemC code.", "\r\nThis project is part of the ", ".\n        ", "\n            - Written In SystemC\r\n", "  - Synopsys CoCentric SystemC Compiler Compatibility\r\n", "  - Fully Synthesisable\r\n", "- 8051 Interface\r\n", "- OCP Interface\r\n", "-  Test bench is included\r\n", "  - SystemC code: simulation through binary generated by the gcc\r\n", "  - Verilog code: simulation through tools like ModelSim or Icarus (the IP Core Verilog files may be generated by CoCentric SystemC Compiler)\r\n", " \n        ", "\n            - The translation is done.\r\n", "- It was verified by simulation with OCP Interface (SystemC and Verilog.)\r\n", "- It was verified by simulation with 8051 Interface (Verilog.)\r\n", "- OCP Interface Protocol under verification.\r\n", "- The hardware verification will be made (XILINX XC2V2000.)\r\n", "  - The XILINX TIMED SIMULATION (Verilog code generated by ISE) in ModelSim is done.\r\n", "\u00a0\n        ", "\n            - ", "\r\n- g++ or Visual C++ Compilers\r\n- Synopsys CoCentric SystemC Compiler (optional)\n        "]},
{"details": ["\n    Name: tdm_switch", "\n    Created: May  3, 2003", "\n    Updated: Dec 19, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The TDM_Switch core is a non-blocking digital switch that has a capacity of 256 x 256 channels at 2.048 Mb/s. Some of the main features are: Processor Mode and input offset delay.\n        ", "\n            - 256 x 256 channel non-blocking switching at 2.048 Mb/s\r\n", "- Accept 8 serial data streams of 2.048 Mb/s\r\n", "- Per-stream frame delay offset programming\r\n", "- Connection memory block programming\r\n", "- Microprocessor Interface\r\n        ", "\n            This IP core is synthesized for Xilinx SPARTAN-II series FPGA\u2019s, fit at xc2s50-6tq144 device and the post place & route simulation model simulate with Cadence NC-Sim simulator.\n        "]},
{"details": ["\n    Name: spislave", "\n    Created: Dec  7, 2009", "\n    Updated: Mar  3, 2010", "\n        SVN Updated: Dec 19, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            spislave is a minimalist spislave IP core that provides the basic framework for the implementation of custom spislave devices. The core provides a means to write up to 256 8-bit registers. These registers can be connected to the users custom logic, thus implementing a simple control and status interface. A full Icarus Verilog test bench is available. ", "Test it for yourself, using the free Icarus Verilog simulator and the free GTKWave wave form viewer.Download and install Icarus Verilog. - ", " Download and install GTKWave.", " - Download the project files. - For executing the testbench just run the Makefile on the bench folder.", "In GTKWave, use \"Search >> Signal Search Tree\" to view more waves.\n        ", "\n            - Standalone. No microprocessor required. For master side we need an microntroller\r\n", "- Create your own custom spislave peripheral.\r\n", "- Easily configurable for different input clock frequencies.\r\n", "- Full Icarus Verilog test bench.\r\n", "- This is to be tested with Our Zkit-51( 8 bit microcon board),a lcd(16x2) and Xilinx Spartan 3A FPGA board\r\n", "\n        ", "\n            - Tested in Zkit - 51 (8 bit microcontroller board) with Xilinx Spartan 3A FPGA board. \r\n", "- Tested in simulation.\r\n", "- Tested waveform in GTK wave. \n        "]},
{"details": ["\n    Name: steppermotordrive", "\n    Created: Apr 23, 2004", "\n    Updated: Dec 16, 2005", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            A very simple project for controlling any standard 4 or 6 wire stepper motor.  Only difference between 4 and 6 wire mode is the MOSFET driver circuit (6 wire steppers are considerably simpler...)\n        ", "\n            - Simple VHDL for beginners; well documented\r\n", "- NPL project file for immediate evaluation in Xilinx ISE/Webpack tools\r\n", "- Quickly get a stepper motor running for testing or prototyping\r\n", "- Questions/Comments: ", "\r\n", "\n        ", "\n            - StepperMotor.npl, project file for Xilinx ISE/Webpack\r\n", "- StepperMotorDrive.vhd, source code\r\n", "- StepperMotorDrive.ucf, constraints file for pin assignments, etc.\r\n", "- StepperMotorWiring.bmp, schematic for connecting motors. Given MOSFETS with sufficiently low Vgs-on, can be driven directly from logic.\n        "]},
{"details": ["\n    Name: spi_master_slave", "\n    Created: May 16, 2011", "\n    Updated: Dec 20, 2017", "\n        SVN Updated: Sep 19, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 19 reported / 8 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\r\n", "\n            The following OpenCores projects are related to this:", "\r\n- Multiple Switch Debouncer in VHDL: ", " , used in the FPGA verification project.\r\n", "\r\n", "\r\nTo get the latest version: ", "\r\nTo see the scope screenshots: ", "\r\nSee all scope photos in the 'trunk/syn' folder at the SVN: ", "\r\n", "\r\n", "\r\n", "\r\nIf you have issues you like to be addressed, place a request in the bugtracker: ", " , or send me an e-mail at ", "\r\n\n        ", "\n            This project started from the need to have robust yet simple SPI interface cores written in VHDL to use in generic FPGA-to-device interfacing.\r\n", "The resulting cores generate small and efficient circuits, that operate from very slow SPI clocks up to over 50MHz SPI clocks.\r\n", "\r\n", "The project contains 2 independent cores: SPI_MASTER and SPI_SLAVE.\r\n", "Both cores are written in VHDL, with fully pipelined RTL architecture and separate clock domains for the SPI bus clock and parallel I/O interface.\r\n", "\r\n", "The design is originally targeted to a Spartan-6 device, but is written in fully synthesizable, technology-independent VHDL.\r\n", "The circuits preserve FPGA clock resources by directly using the system high speed clock for all flops, with clock enables (CE) to clock registers.\r\n", "The master and slave cores were verified in hardware using the Digilent Atlys board (Spartan-6 @100MHz) with spi clocks from 500kHz to 50MHz SPI clock, with perfect phasing and very robust operation.\r\n", "\r\n", "If you find these cores useful, please let me know: jdoin@opencores.org\r\n", "\r\n", "If you find the LGPL license to be unfit for your purposes, please let me know and we can change the license for another open-source hardware license that can be integrated in your application.\r\n", "\r\n", "\n        ", "\n            - VHDL core, fully synchronous, designed with classic RTL pipelined architecture, with a single high-speed global clock\r\n", "- Very small and efficient SPI interface\r\n", "- Parameterizable at instantiation by generics: (N, CPOL, CPHA, PREFETCH, SPI_2X_CLK_DIV)\r\n", "-> SPI modes (CPOL, CPHA): supports modes 0,1,2,3\r\n", "-> Word width (N): from 8 bits to synthesis limit (accepts any word length)\r\n", "-> Lookahead input data request (PREFETCH): pipelined data request for back-to-back data transmission\r\n", "-> SPI 2x clock divider value from the high-speed system clock\r\n", "- Very economic: no FIFO, just a registered parallel output buffer for received data\r\n", "- Parallel read/write similar to synchronous RAM ports\r\n", "- Independent clock domains for the serial bus and parallel read/write ports with async domain transfer pipelines\r\n", "- Can be used to control generic SPI devices (master), or as interface to MCUs (slave)\r\n", "- Vendor-independent, fully LUT/FF design, uses no Xilinx-specific structures, IOBs or shift registers\r\n", "- Synthesizes to +210MHz in a Spartan-6 lowest grade, using only CLB logic\r\n", "- Verified in silicon, with a 100MHz clock, using SPI frequencies from 500kHz up to 50MHz in a Spartan-6 XC6SLX45-2\r\n", "- Very small: 41 slices for 2 ports (a master interface + a slave interface) with 32bits of word length\n        "]},
{"details": ["\n    Name: spiadc", "\n    Created: Jun 14, 2009", "\n    Updated: Jun 23, 2009", "\n        SVN Updated: Jun 15, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            this core represents an minimalistic SPI receiver for ADC like AD747x.\r\n", "one have:\r\n", "   - tunable sequence len, loaded data slice of sequence, \r\n", "   - shut-down short sequense generation\r\n", "   - ability continued sequence mode - without frame entry/completing\r\n", "   - ready output for locking received data\r\n", "   - shifht clock output provide ability to build parallel vector receivers by\r\n", "     adding needed shift registers\r\n", "Syntesis on QuartusII 8.1 Web for EP1C3 16bit sequense with 10 loaded bit ocupies 31 cells\r\n", "\n        "]},
{"details": ["\n    Name: spdif_interface", "\n    Created: Apr 12, 2004", "\n    Updated: Apr 21, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The SPDIF interface (Standard IEC958 \"Digital audio interface\") allows transmission of digital audio signals between devices in a digital format. The goal of this project is to allow a controller/cpu with Wishbone interface to transmit and receive digital audio.\n        ", "\n            - Separate transmitter and receiver\r\n", "- Dual sample buffer architecture with configurable buffer size\r\n", "- Access to channel status and subframe bits\r\n", "- Supports both 16bit and 32bit data bus\r\n", "\r\n", "\n        ", "\n            - SPDIF Interface V1.1 has been released.  \n        "]},
{"details": ["\n    Name: spidac", "\n    Created: Aug  5, 2010", "\n    Updated: Aug  6, 2010", "\n        SVN Updated: Aug  6, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            An implementation of serial Linear Technologies LTC2624 Quad 12bit DAC using SPI 32bit data transfer method. The core is FPGA proven, works on Spartan-3E Starter Kit.\r\n", "\r\n", "If someone would like to improve the project (i.e. add WishBone support, etc), please contact project maintainers.\n        "]},
{"details": ["\n    Name: spi", "\n    Created: Jun 12, 2002", "\n    Updated: Apr 22, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            SPI (Serial Peripheral Interface) is serial, synchronous, full duplex communication protocol. It is widely used as a board-level interface between different devices such as microcontrollers, DACs, ADCs and others.\r\n", "This core is SPI/Microwire compliant master serial communication controller with additional functionality.\n        ", "\n            - Full duplex synchronous serial data transfer\r\n", "- Variable length of transfer word up to 32 bits\r\n", "- MSB or LSB first data transfer\r\n", "- Rx and Tx on both rising or falling edge of serial clock independently\r\n", "- 8 slave select lines\r\n", "- Fully static synchronous design with one clock domain\r\n", "- Technology independent Verilog \r\n", "- Fully synthesizable\r\n        ", "\n            - Tested in FPGA\n        "]},
{"details": ["\n    Name: ss_pcm", "\n    Created: Sep 17, 2002", "\n    Updated: Feb 10, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Simple PCM Interface. Allows to interface to such popular devices\r\n", "like TI DSPs (via McBSP bus) in PCM mode. Of course many more\r\n", "applications. Very small and simple core.\n        ", "\n            - Implemented in Verilog\r\n", "- Frame Start position adjustable\r\n", "- full 16 bit frames\r\n", "- 1 Receive holding register\r\n", "- 1 Transmit holding Register\r\n", "- Fully Synthesisable\r\n", "- Can handle PCM streams at any rate, 128KHz to 100MHz.\r\n", "- 38 LUTs in a Spartan II\r\n        ", "\n            This core is fully functional and completed. It was tested on\r\n", "a XESS XCV800 board interfacing to a proprietary device with\r\n", "a TI DSP, exchanging PCM streams in both directions.\r\n        ", "\n            "]},
{"details": ["\n    Name: simple_spi", "\n    Created: Dec 15, 2002", "\n    Updated: Jul 15, 2014", "\n        SVN Updated: Mar 13, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Enhanced version of the Serial Peripheral Interface available on Motorola's MC68HC11 family of CPUs.Enhancements include a wider supported operating frequency range, 4deep read and write fifos, and programmable transfer count dependent interrupt generation.\r\n", "As with the SPI found in MC68HC11 processors the core features programmable clock phase (CPHA) and clock polarity (CPOL). The core features an 8bit wishbone interface.\r\n", "Very simple, very small.\n        ", "\n            - Compatible with Motorola's SPI specifications\r\n", "- Enhanced Motorola MC68HC11 Serial Peripheral Interface\r\n", "- 4 entries deep read FIFO\r\n", "- 4 entries deep write FIFO\r\n", "- Interrupt generation after 1, 2, 3, or 4 transfered bytes\r\n", "- 8 bit WISHBONE RevB.3 Classic interface\r\n", "- Operates from a wide range of input clock frequencies\r\n", "- Static synchronous design\r\n", "- Fully synthesizable\r\n", "- 130LUTs in a Spartan-II, 230 LCELLs in an ACEX\n        ", "\n            Design is finished and available in Verilog from OpenCores CVS.\n        "]},
{"details": ["\n    Name: sockit_owm", "\n    Created: Jul 13, 2010", "\n    Updated: Feb 16, 2011", "\n        SVN Updated: Jun 26, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This IP implements the 1-wire communication protocol (", "\r\n", "A more detailed documentation is provided in \"doc/sockit_owm.odt\".\r\n", "\r\n", "RTL features:\r\n", "- small RTL, should fit into a CPLD\r\n", "- Avalon MM bus, Wishbone compatible with a simple adapter\r\n", "- timed reset, presence, write/read bit transfers\r\n", "- overdrive\r\n", "- power supply (strong pull-up)\r\n", "\r\n", "SOPC Builder integration\r\n", "\r\n", "Nios II EDS integration:\r\n", "- port of the 1-wire open domain kit version 3.10b\r\n", "- interrup driven or polling driver\r\n", "- uCOS-II support (only partialy tested)\r\n", "\r\n", "\r\n", "The source code and documentation are available on github:\r\n", "\n        "]},
{"details": ["\n    Name: simple_uart_for_fpga", "\n    Created: Jun  1, 2016", "\n    Updated: Jun  2, 2016", "\n        SVN Updated: Jun  2, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            Simple UART for FPGA is UART (Universal Asynchronous Receiver & Transmitter) controller for serial communication with an FPGA. The UART controller was implemented using VHDL 93 and is applicable to any FPGA. Simple UART for FPGA requires: 1 start bit, 8 data bits, 1 stop bit! The UART controller was simulated and tested in hardware.\n        "]},
{"details": ["\n    Name: uart", "\n    Created: Sep 25, 2001", "\n    Updated: Apr 14, 2010", "\n        SVN Updated: May  5, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            - as small as possible to fit in a Xilinx CPLD \r\n", "- fixed 9600 baudrate for this version \r\n", "- 1 start bit, 8 data bits, 1 stop bit data stream format \r\n", "- both interrupt-based and polling user interface\r\n        ", "\n            Serial UART open source core. The design is engineered for use as a stand alone chip or for use with other of our cores. The reason for developing the Serial UART core is the fact, that asynchronous serial communication is very common that almost every machine understands it.Also, for OCRP-1, we needed a way of communication with a host computer, to make it available over the net. \n        ", "\n            Synthesized with Xilinx Foundation 2.1i (Synopsys Express FPGA compiler, Xilinx P&R tools) for:\r\n", "- Xilinx Virtex FPGA family takes 14% of XCV50 slices (110 out of 768) \r\n", "- Xilinx 9500 CPLD family takes 43% of XC95288 macrocells(125 out of 288)\r\n", "\r\n        ", "\n            - design is available in VHDL from OpenCores CVS (see Download section)\r\n", "- documentation will be available in short time\r\n", "- a new module, UART16550 family compatible could be developed if enough interest\n        "]},
{"details": ["\n    Name: sasc", "\n    Created: Sep 17, 2002", "\n    Updated: Mar 30, 2006", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Simple asynchronous serial controller (aka UART). Includes 4\r\n", "byte receive and a 4 byte  transmit FIFO (FIFO size can be easily\r\n", "adjusted). External baud rate  generator (included). Very small.\r\n        ", "\n            - Implemented in Verilog\r\n", "- Flow Control (CTS/RTS)\r\n", "- 1 start bit, 1 stop bit, NO parity\r\n", "- 4 byte receive FIFO\r\n", "- 4 byte transmit FIFO\r\n", "- Fully Synthesisable\r\n", "- 102 LUTs in a Spartan II\r\n        ", "\n            This core is fully functional and completed.\r\n", "It was verified in hardware in an XESS XVC800 FPGA prototype\r\n", "board with a Maxim RS232 line driver.\n        ", "\n            "]},
{"details": ["\n    Name: aes3rx", "\n    Created: Apr 19, 2009", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Aug 31, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n            ", "\n            AES3 / SPDIF receiver is simple, minimalistic but powerful core which decodes biphase mark coded AES3 compatible signal and retransmitts it in I2S-like format. Audio words are coded in 2's complement format, however, in contrast to I2S, they are LSb and not MSb aligned and all auxiliary bits of AES3 are left unchanged and transmitted together with audio word. There is even some mess in first four bits of each word as result of preamble detection. Nevertheless, this core can be implemented on XC9572XL-5 with only 43 macrocells utilization and fmax around 100MHz while capable of receiving AES3 at fs = 96kHz with clk at 50MHz.\n        "]},
{"details": ["\n    Name: spi_boot", "\n    Created: Feb  8, 2005", "\n    Updated: Aug 19, 2009", "\n        SVN Updated: Apr  1, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "The SD/MMC Bootloader is a CPLD design that manages configuration and bootstrapping of FPGAs. It is able to retrieve the required data from SecureDigital (SD) cards or MultiMediaCards (MMC) and manages the FPGA configuration process. SD cards as well as MMCs are operated in SPI mode which is part of both standards thus eliminating the need for dedicated implementations. The SD/MMC Bootloader fits both. Beyond configuration, this core supports a bootstrapping strategy where multiple images are stored on one single memory card.", "For example consider a system completely based on SRAM. The bootloader provides the initial configuration data from the first image to the FPGA. This image contains a design which pulls the next image from the memory card and transfers this data to SRAM. In the third step the final FPGA design is loaded from the third image.", "These images are clustered in sets which can be selected by external switches for example. Several configuration sets can be stored on one memory card allowing you to provide a number of applications which are downloaded quickly to the FPGA.", "The ", " shows how the core can be used with an FPGA board. I use it to configure/boot the Xilinx Spartan IIe on BurchED's B5-X300 board. SV2 fits the \"SERIAL MODE\" connector on this board but you will have to add a separate wire from R6 to attach INIT. Please check the proper use of the pull-up resistors for your specific board.", "\n            ", "\n            ", "The SD/MMC Bootloader has been successfully implemented in an Altera MAX3064 device. Configuration target in a three stage process was a Xilinx Spartan-IIE XC2S300E. The CPLD design requires 50 out of 64 macro cells.", "\n            ", "The following tools are integrated and are required for this project:", "Downloading the configuration data to the card is a straight forward process. The images have to be written starting at dedicated locations. For the provided toplevel designs, these locations are multiples of 256 K. I.e. 0, 0x40000, 0x80000 and so forth.", "dd (part of the GNU coreutils) serves this purpose:", "The name of the device node depends on how the card reader is attached to the kernel. For Linux systems this is most often something like /dev/sdX with X ranging from a-z. Please note that it is essential to use the device without any trailing numbers as they refer to partitions  leading to wrong offsets for data written to the card.", "All this works perfectly for my Spartan IIe device as this FPGA expects the configuration data as it is delivered from the card: Consecutive bytes each with its most significant bit first. Altera devices like the FLEX family are different here. They expect the bytes with least significant bit first. Therefore, the configuration data has to be swapped bitwise before it is written to the card.", "\n            ", "The latest release of the SD/MMC Bootloader project is version 3.2, rev. C.", "Get this and all previous versions of the design files from SVN: ", ".", "Please keep in mind that trunk/ is work in progress and might contain smaller or bigger problems.", "You should also check the ", " for known bugs and see if they affect your work.", "\n            ", "\n            ", "These cards have been tested with the SD/MMC Bootloader:", "Some MMC might fail with this core as not all cards support CMD18 (READ_MULTIPLE_BLOCK). Please consult the data sheet of your specific model. In case your MMC does not implement CMD18 you might want to have a look at the ", "."]},
{"details": ["\n    Name: mmuart", "\n    Created: Aug  6, 2010", "\n    Updated: Aug  7, 2010", "\n        SVN Updated: Aug 24, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", "\r\n", "\r\n", "\n            "]},
{"details": ["\n    Name: spimaster", "\n    Created: Apr 11, 2008", "\n    Updated: Nov 24, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            SD (Secure Digital) and MMC memory card controller with Wishbone slave interface. Handles all aspects of card initialization, 512 byte block read, and block write. Hides the complicated SD/MMC memory interface, and presents the user with a simple Fifo interface. Provides transfer speeds up to 24Mbps.\r\n", "If combined with the fpgaConfig project: ", "\r\n", "then it is possible to configure an FPGA from SD memory. If the FPGA configuration includes this core (spiMaster) and a softcore processor, then the processor can copy a software image from SD memory into RAM, and then execute from RAM. Thus a complete FPGA softcore processor can be implemented with just an FPGA, DRAM, and SD card.\r\n", "See fpgaConfig used in a complete project at:\r\n", "\n        ", "\n            - Simple interface to SD cards up to 2GB\r\n", "- SD Initialization\r\n", "- SD 512 byte block write\r\n", "- SD 512 byte block read\r\n", "- Data access up to 24Mbps\r\n", "- 8-bit Wishbone slave interface\r\n", "- Separate Wishbone and core logic clocks\r\n", "- Simulation files\r\n", "- 900 logic cells in Altera Cyclone2\r\n", "\n        ", "\n            Tested in FPGA.\r\n", "The following mods and additions could be useful:\r\n", "- Interrupt line.\r\n", "- Card detect.\r\n", "- Master wishbone interface would be nice, so that DMA transfers to memory could be performed.\r\n", "- SD/MMC memory card simulation model needs improvement. The model does not parse the commands from the core, and does not provide any storage.\r\n", "- Multiple SPI chip select support.\r\n", "- Larger Fifos to allow simultaneous processor and core Fifo access.\n        ", "\n            Release 1.2 now available. New version modifies read timing which was marginal for some SD cards.\n        "]},
{"details": ["\n    Name: sdcard_mass_storage_controller", "\n    Created: Mar 27, 2009", "\n    Updated: Feb 11, 2017", "\n        SVN Updated: Oct 15, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 15 reported / 7 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The \"sd card controller\" is a Secure Digital Card Host Controller, which main focus is to provide fast and simple interface to SD/SDHC cards. One of the main goal with this project is that the controller should be usable as a system disk contain a file system. Therefore the core has been developed with features a system with operative system will benefit from.  \r\nThe design also include a simplified model of a SD-card to test against.\r\n", " \r\n", "\r\n\r\n\r\n\r\nhttp://www.opencores.org/?do=project&who=sdcard_mass_storage_controller&page=overview\r\n2009-05-20\r\n\n        ", "\n            The core is a combined SD/SDHC controller, for Secure Digital-card.  \r\n\r\nTwo designs is available, one full-feature core utilizing DMA and one smaller for PIO.\r\n", "\r\nThe idea with the full-feature design is that it should provide as much performance as possible. Therefore it's build to stall the CPU as little as possible and offload it some computations, this is archived by:\r\n", "\n            ", "\n            Data block length fixed to 512 Byte\r\n", "No SD 1-bit mode\r\n", "No SPI mode\r\n", "No Hot Insertion (i.e. inserting a card when the bus is operating)\r\n", "No multiple block operations/pre erase\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: scan_based_serial_communication", "\n    Created: Jul 19, 2010", "\n    Updated: Jul 22, 2010", "\n        SVN Updated: Apr  8, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            "]},
{"details": ["\n    Name: sata_phy", "\n    Created: Jul 12, 2012", "\n    Updated: Mar 10, 2014", "\n        SVN Updated: Jul 12, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            SATA PHY layer which can be implemented as either a host or device for Xilinx 6 series devices. \r\n", "\r\n", "A host controller core with AXI interface is available, contact me for more information.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: saturn", "\n    Created: May 30, 2017", "\n    Updated: Jun  5, 2017", "\n        SVN Updated: Jul 20, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This SATURN protocol stack constitutes the low level communication layers necessary to implement a SATURN compatible network.\r\n", "The project is split in 5 directories:\r\n", "- SIL2 gateway\r\n", "- SIL4 gateway\r\n", "- SIL2 IOM\r\n", "- SIL4 IOM\r\n", "- IP Communication (generic modules used as IP by the different components)\n        "]},
{"details": ["\n    Name: spi_slave", "\n    Created: Nov 19, 2007", "\n    Updated: May 15, 2008", "\n        SVN Updated: Mar 12, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The OPB SPI Core connects a FPGA to a DSP or Microprocessor as Slave-Device. This means all transfers are initiated by the Master an the FPGA-System only responds to read or write request.\n        ", "\n            - OPB-Clock and SPI-Clock are complete independent\r\n", "- SPI can run faster than OPB if guaranteed that no TX-FIFO Underrunn or RX- FIFO Overrunn occure.\r\n", "- variable transfer length 2..32\r\n", "- Automatic CRC-Generation for Transmit and Receive Data (only 8,32Bit Shift-Register Width)\n        ", "\n            - simulation tests done\r\n", "- Hardware tests on a Virtex-4 ML401 Board (LX25) done \r\n", "- CRC-Code Real World Test in progress\r\n", "\n        "]},
{"details": ["\n    Name: pc_fpga_com", "\n    Created: Mar 12, 2011", "\n    Updated: Mar  7, 2014", "\n        SVN Updated: May 10, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Open-source implementation of a versatile UDP/IP core for FPGAs.\r\n", "\r\n", "C/C++ Software library for configuring the core and transmitting standard C types like characters, integers, floats and doubles.\r\n", "\r\n", "Hardware interface for transmitting standard C types like characters, integers, floats and doubles.\r\n", "\r\n", "The UDP/IP core can transmit and receive data to and from any PC. The only requirement is the use of the configuration function provided by the software library in order to initialize an internal lookup table.\n        "]},
{"details": ["\n    Name: rs232_interface", "\n    Created: Aug 29, 2010", "\n    Updated: Apr 29, 2015", "\n        SVN Updated: Jul  3, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 8 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a small UART to byte uPC interface (compliant with RS232 and RS3232 CI's).\r\n", "Ideal to use with soft/hard processors in a FPGA project.\r\n", "\r\n", "Designed to sync internal clock of RX path. Independent clock sources (TX/RX).\n        ", "\n            TX:\r\n", "- TX data;\r\n", "- TX request;\r\n", "- TX end of send;\r\n", "\r\n", "RX:\r\n", "- RX data;\r\n", "- RX data ready (data valid);\n        "]},
{"details": ["\n    Name: quadraturecount", "\n    Created: Dec 23, 2003", "\n    Updated: Apr 22, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a very simple project for reading a quadrature device, such as an optical encoder.  The counter is initialized to zero, and then counts up and down when valid quadrature is present at the inputs\n        ", "\n            - Simple VHDL for beginners; well documented; shows use of hierarchical design.\r\n", "- Count limited only by bit length of counter vector; simple to count very large values\r\n", "- VHDL Implementation of Xilinx application note #012 (xapp012.pdf)\r\n", "- NPL project file for immediate evaluation in Xilinx ISE/Webpack tools\r\n", "- Questions/Comments: ", "\n        ", "\n            - QuadratureCounter.vhd, top-level VHDL\r\n", "- QuadratureDecoder.vhd, sub-level file\r\n", "- Quadrature.npl, Xilinx project file for ISE/Webpack\r\n", "- Quadrature.ucf, optional constraints file for pin assignment\n        "]},
{"details": ["\n    Name: cxd9731", "\n    Created: Aug 12, 2017", "\n    Updated: Aug 13, 2017", "\n        SVN Updated: Aug 15, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: man2uart", "\n    Created: Nov 22, 2004", "\n    Updated: Nov 16, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Bosch control keyboard and Bosch DVR/VCR send bi-phase Manchester signal in their own format to control Bosch speed doom. This converter get the data and change to UART format for the MCU to process it.\r\n", "\r\n", "This is the signal converter on data link layer. \r\n", "About how to convert signal in phyical layer , there have some circuit to do it , if interest please email to me at kenneth@opencores.org to get schematic.\n        ", "\n            separate manchester signal \r\n", "\r\n", "- guard_time\r\n", "- preamble\r\n", "- sync_start\r\n", "- data\r\n", "- stop\r\n", "\r\n", "-- example : Pan Left Manchester signal on philips protocol\r\n", "-- 0000001010101010111000101010100101010110100100001111000000 \"87\"\r\n", "-- 0000001010101010111000100101010101010101100100001111000000 \"00\"\r\n", "-- 0000001010101010111000100101010101010101100100001111000000 \"00\"\r\n", "-- 0000001010101010111000100101011001010101010100001111000000 \"08\"\r\n", "-- 0000001010101010111000100101010101010101100100001111000000 \"00\"\r\n", "-- 0000001010101010111000100101011010101001100100001111000000 \"78\"\r\n", "-- 0000001010101010111000100110010101010101010100001111000000 \"02\"\r\n", "-- 0000001010101010111000101001011001010101100100001111000000 \"09\"\n        ", "\n            The project was finished and working so far so good.\n        "]},
{"details": ["\n    Name: madi_receiver", "\n    Created: Feb 14, 2009", "\n    Updated: May  5, 2015", "\n        SVN Updated: May  2, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a receiver for a Multichannel Audio Digital Interface (MADI), also known as AES-10. This type of fibreoptical or electrical connection is used in professional audio where a greater number of digital audio channel has to be transported.\r\n", "\r\n", "The link speed of MADI is 125Mbit/s, while the data transfer rate used is 100Mbit/s. The diffrence between the two is explained by the use of a link encoding scheme. The encoding scheme used is known as 4B5B, which turns a 4 bit nibble into a 5 bit symbol. The data is NRZI encoded for a nearly DC-free link.\r\n", "\r\n", "Clocking of this design is synchonous, a 25MHz clock signal has to be provided in order to receive the datastream. For synchronisation, a unique 2-symbol bit pattern is used, that can never occur in the payload of the data. The extra bandwidth between the payload speed and the data speed is filled with this bit pattern: 11000 10001 or symbols \"JK\" in 4B5B.\r\n", "\r\n", "All of this seems very similar to a 100Mbit Ethernet connection. Therefore, an Ethernet PHY is used to receive the MADI datastream. The PHY must be able to output codegroups instead of 4 bit nibbles. A good example is the Cirrus Logic CS8952-CQZ. At the first stages of the development of MADI, AMD's TAXIchip transmitters ans receivers were used to establish the link. Nowadays, TAXIchips are outdated and nearly impossible to get, let alone use it in production. Cypress supposedly has some transceivers which also support the TAXIchip protocol.\r\n", "\r\n", "The MADI protocol supports 56 or 64 channels of 48/44.1/32KHz digital audio, or half the number in double the sample clock. To achive an even higher sample rate, two or more channels can be combined for consecutive samples.\r\n", "\r\n", "The design uses a wordclock output for MADI, and wordclock and bitclock input for ADAT. Thus, the design needs an external PLL block, which has a 48kHz input and is multiplied by 256 to get a bitclock. Take a look at the Cirrus Logic CS2100 for example. A PLL of such must be supplied externally in order for the design to work. If you try the make a clock multiplier in software, the ADAT signal would have too much jitter. The internal PLL in the Cyclone is not designed to use a 48kHz signal for an input (frequency is too low).\r\n", "\r\n", "This design is now FPGA proven as I have developed a prototype board for this purpose. Interfacing to an RME HDSPe MADI soundcard, this prototype board accepts 8 ADAT inputs and turns them into a MADI signal, and converts a MADI steam into 8 ADAT outputs.\r\n", "\n        ", "\n            ", "\r\n", "\r\n\r\nThis is the prototype board\r\n", "\r\n", "\r\n\r\nA closeup, always great to manually solder those QFP's\r\n", "\r\n\r\n", "\r\n\r\nThe board in action on the logictap\r\n", "\r\n\n        ", "\n            - Slim design\r\n", "- interface to readily available 100Mbit LAN PHY\r\n", "- 25MHz clock input required\r\n", "- Outputs appoximate wordclock\r\n", "- Interfaces to 8x ADAT optical\r\n", "- Supports frames of 20,4 us as well as 10,2 us\r\n", "- Maximum of 64 digital audio channels\r\n", "- Adapts to speed changes\n        ", "\n            - VHDL design done\r\n", "- preliminary testbench created. This does not create a valid MADI signal, because the frame length is not according to specification. For now it will do the job.\r\n", "- FPGA proven\r\n", "- Minor adjustments may be neccesary\n        "]},
{"details": ["\n    Name: i2s_interface", "\n    Created: Jul 28, 2004", "\n    Updated: Jul 30, 2016", "\n        SVN Updated: Jul 30, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 2 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            - Separate transmitter and receiver.\r\n", "- Operates in either slave or master mode.\r\n", "- Configurable sample buffer size.\r\n", "- Supports 16bit to 32bit resolution.\r\n", "- Supports 16bit and 32bit Wishbone data bus.\r\n", "- Interrupt capability.\r\n", "\n        ", "\n            I2S is an industry standard (invented by Philips) 3-wire interface for streaming stereo audio between devices. Typical applications include digital audio transfer between a CPU/DSP and a DAC/ADC. The I2S core allows a Wishbone master to stream stereo audio to and from I2S capable devices.\n        ", "\n            - Core is complete and released.\r\n", "\n        "]},
{"details": ["\n    Name: openlzs", "\n    Created: Feb 13, 2013", "\n    Updated: Feb 18, 2013", "\n        SVN: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please download source code from:\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: 802154phycore", "\n    Created: Jul 25, 2013", "\n    Updated: Jan 11, 2015", "\n        SVN Updated: Jan 11, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the physical layer of the IEEE 802.15.4 standard (TX, RX). \r\nThe doc/ directory of the repository contains the thesis related to this implementation (ES).\r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: crc802154", "\n    Created: Sep 28, 2013", "\n    Updated: Sep 29, 2013", "\n        SVN Updated: Sep 29, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of the CRC check in IEEE 802.15.4 (MAC layer).\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: ipv4_packet_transmitter", "\n    Created: Jan  5, 2010", "\n    Updated: Mar  7, 2014", "\n        SVN Updated: Dec 21, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            VHDL implementation of a component that can be connected to the input port of the Virtex-5 Ethernet MAC Local Link Wrapper and that allows for transmission of IPv4 ethernet packets. \r\n", "\r\n", "The complete UDP/IP core that uses this component is the UDP/IP Core project.\n        "]},
{"details": ["\n    Name: usb_dongle_fpga", "\n    Created: Dec  7, 2006", "\n    Updated: Jan 27, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Main features of latest v5 HW are:\r\n", "\r\n", "-LPC memory read (can be disabled),LPC Firmware Hub memory read\r\n", "and IO write for POST Code capture (and display on LED segments)\r\n", "-POST code peek mode (LPC reads from dongle are disabled)\r\n", "-POST code logger (sends all postcodes to USB serial port as hexadecimal bytes in ASCII)\r\n", "\r\n", "This is hardware project for existing USB dongle\r\n", "board (costing about 150 EUR you should check from sales(at)artecgroup.com). Using it for LPC dongle.\n        ", "\n            - LPC slave (supporting IO write, Memory read and LPC Firmware Hub read from device ID 0x0000)\r\n", "- Flash Waveform generator\r\n", "- FTDI parallel interface to onboard flash (supports 32 byte block write and 64K block read)\r\n", "- FTDI parallel interface to convert and send bytes as hex codes in ASCII\r\n", "- Scanning LED segment display coder\n        ", "\n            - HW cvs tag HWVersion_1_0 released (HW code 3)\r\n", "\r\n", "- Software cvs tag SoftVersion_1_1 released (dongle.py script version 1.1)\r\n", "\r\n", "- HW/Software bundle cvs tag version_1_4 released (bug fixes and added LPC Firmware hub [FWH] read). Contains HW version code 4 and dongle.py script version 2.0\r\n", "\r\n", "- HW/Software bundle cvs tag version_1_5 released (Added Post code logger hardware, fast block read hardware and fast read flow control hardware. Updated software to support all the new hardware and older HW in legacy mode). Contains HW version code 5 and dongle.py script version 2.5\r\n", "\n        ", "\n            FILE: mini_LR_DSC_0016.jpg\r\n", "DESCRIPTION: LPC USB dongle\r\n", "\n        ", "\n            http://www.artecgroup.com/products/hardware-products/programmable-lpc-dongle.html\r\n", "\r\n", "Can buy at:\r\n", "\r\n", "\r\n", "- Cyclone FPGA EP1C6T144C8N\r\n", "- Serial Platform Flash\r\n", "- Intel Strata Flash E28F128 (16MB) in 16 bit mode\r\n", "- FTDI parallel to USB bridge FT245BM\r\n", "- 4 segment LED display\r\n", "\r\n", "Short dongle user guide by coreboot.org:\r\n", "\r\n", "\n        ", "\n            FILE: block_diagram.png\n", "DESCRIPTION: Block diagram\n", "\n        ", "\n            Hardware, software and Quartus project bundle for v5 hardware\r\n", "\r\n", "\r\n", "Datasheet for v5 hardware\r\n", "\r\n", "\r\n", "Software and datasheet bundle for v5 hardware \r\n", "\r\n", "\r\n", "ALTERA EPCS configuration memory programmer tool (needs python and pyParallel), dongle v5 binary and diagram of ByteBlaster II hardware (older Altera cables like ByteBlaster MV won't work)\r\n", "\r\n", "\r\n", "LPC Dongle AD67441103 PCB schematic\r\n", "\r\n", "\r\n", "LPC Dongle AD67441104 PCB schematic\r\n", "\n        "]},
{"details": ["\n    Name: irda", "\n    Created: Sep 25, 2001", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            IrDA core that utilizes uart16550 core for 115.2Kbit/s IrDA communication. Required bit encoding/decoding is performed.\r\n", "The 115.2 (SIR) mode should work alright.\r\n", "\r\n", "There's also a lot of code for MIR and FIR, much faster communication modes. Yet they are not fully tested and are sure to contain a lot of bugs.\n        ", "\n            \u2022 Designed for all standard IR transceivers.\r\n", "\u2022 Implements WISHBONE bus interface\r\n", "\u2022 Up to 4Mbit communication speed\r\n", "\u2022 Programmable clock selection\r\n", "\u2022 Loopback option for testing\r\n", "\u2022 Works with WISHBONE bus clock\r\n", "\u2022 Can request DMA transfers\r\n        ", "\n            Currently, only 115.2 (SIR) mode is done well. Use irda_top_sir_only.v top-level module.\r\n", "Faster modes (MIR, FIR)  are not tested well but the specs and most of the code for them exist, just not tested and debugged well.\n        "]},
{"details": ["\n    Name: i2cslave", "\n    Created: Nov  7, 2008", "\n    Updated: Jul  2, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            i2cSlave is a minimalist I2C slave IP core that provides the basic framework for the\r\nimplementation of custom I2C slave devices. The core provides a means to read and write\r\nup to 256 8-bit registers. These registers can be connected to the users custom logic,\r\nthus implementing a simple control and status interface. \r\n\r\nA full ", " Verilog test bench is available. \r\n\r\nTest it for yourself, using the free Icarus Verilog simulator and the free GTKWave wave form viewer. Only 6 simple steps!\r\n- ", " and install Icarus Verilog.\r\n- ", " and install GTKWave.\r\n- ", " the project files. \r\n- Execute sim/build_icarus.bat and sim/run_icarus.bat\r\n- Execute sim/viewWave.bat and check out the results.\r\n- In GTKWave, use \"Search >> Signal Search Tree\" to view more waves.\r\n\r\n\r\n\r\n\n        ", "\n            - Standalone. No microprocessor required.\r\n", "- Create your own custom I2C peripheral.\r\n", "- Only 143 macrocells in CPLD.\r\n", "- I2C bus speeds of 100Kbps and 400Kbps.\r\n", "- Easily configurable for different input clock frequencies.\r\n", "- Full Icarus Verilog test bench.\r\n", "\n        ", "\n            - Tested in FPGA\r\n", "- Tested in simulation\n        ", "\n            Now available, Altera Quartus project for Base2Designs ", " and test  software for the\r\n", " I2C Host Adapter. ", " the latest project files now.\r\n\n        "]},
{"details": ["\n    Name: iicmb", "\n    Created: Apr 29, 2016", "\n    Updated: Oct 19, 2017", "\n        SVN Updated: Jun 30, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 4 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            ", "\r\nThe IICMB core provides low-speed, two-wire, bidirectional serial bus interfaces compliant to industry standard I2C protocol.", "\r\nThe key feature of the core is its ability to control several connected I2C buses effectively reducing complexity of the system.", "\n        ", "\n            - Compatible with Philips' I2C standard\r\n", "- Works with up to 16 distinct I2C buses\r\n", "- Statically configurable system bus clock frequency\r\n", "- Statically configurable desired clock frequencies of I2C buses\r\n", "- Multi-master clock synchronization\r\n", "- Multi-master arbitration\r\n", "- Clock stretching\r\n", "- Digital filtering of SCL and SDA inputs\r\n", "- Standard (up to 100 kHz) and Fast (up to 400 kHz) mode operation\r\n", "- Example connection as 8-bit slave on Wishbone bus\r\n", "- Example connection as 32-bit slave on Avalon-MM bus\r\n", "- Sequencer-based example, working without any system bus\n        ", "\n            Currently supported master mode only.\r\n", "The slave mode is under development. Please, submit desired slave features.\n        "]},
{"details": ["\n    Name: i2c", "\n    Created: Sep 25, 2001", "\n    Updated: Feb 21, 2018", "\n        SVN Updated: Jun  6, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 47 reported / 26 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: B.3", "\n    License: BSD\n", "\n            I2C is a two-wire, bidirectional serial bus that provides a simple, efficient method of data exchange between devices. It is primarily used in the consumer and telecom market sector and as a board level communications protocol.\r\nThe OpenCores I2C Master Core provides an interface between a Wishbone Master and an I2C bus.\r\nIt is an easy path to add I2C capabilities to any Wishbone compatible system.\r\n\r\nYou can find the I2C specifications on ", " Site.  \r\nWork was originally started by Fr\u00e9d\u00e9ric Renet. You can find his webpage ", ". \n        ", "\n            - Compatible with Philips I2C bus standard\r\n", "- Multi-Master Operation\r\n", "- Software programmable timing\r\n", "- Clock stretching and wait state generation\r\n", "- Interrupt or bit-polling driven byte-by-byte data-transfers\r\n", "- Arbitration lost interrupt, with automatic transfer cancelation\r\n", "- (Repeated)Start/Stop signal generation/detection\r\n", "- Bus busy detection\r\n", "- Supports 7 and 10bit addressing\r\n", "- Fully static and synchronous design\r\n", "- Fully synthesisable\n        ", "\n            - Revision 0.8 of the WISHBONE I2C Master Core specifications are available ", ".\r\n- Also see the ", " page.\n        ", "\n            Check the FAQ page for information regarding Philips I2C/SMBus licensing information.\n        ", "\n            - Design is available in VHDL and Verilog from OpenCores SVN via ", "\r\n\n        ", "\n            Push-button synthesis results for various targets.\r\n", "\r\n", "Actel:\r\n", "- A54SX16ATQ100-std: 352Modules@58MHz\r\n", "\r\n", "Altera:\r\n", "- FLEX: EPF10K50ETC144-3: 294LCELLs@82MHz\r\n", "- ACEX: EPF20K30ETC144-3: 257ATOMs@74MHz\r\n", "\r\n", "Xilinx:\r\n", "- Spartan-II: 2S15CS144-5: 229LUTs@82MHz\r\n", "- Virtex-E: XCV50ECS144-8: 230LUTs@118MHz\n        ", "\n            - CATC ", "\n        "]},
{"details": ["\n    Name: hdbn", "\n    Created: Apr 27, 2003", "\n    Updated: Oct 29, 2014", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            This \u201ccore\u201d is actually two cores \u2013 an HDB3/HDB2/B3ZS Encoder that converts NRZ data into P and N pulses according to ITU-T G.703, and a HDB3/HDB2/B3ZS Decoder that converts P and N pulses into NRZ data according to ITU-T G.703.\r\n", "\r\n", "Note: HDB2 and B3ZS are different names for the same encoding.\r\n", "\r\n", "HDB3 is typically used to encode data at 2.048 (E1), 8.448 (E2) and 34.368Mb/s (E3)\r\n", "B3ZS is typically used to encode data at 44.736Mb/s (T3)\n        ", "\n            - HDB3 / HDB2 selected by a generic.\r\n", "- Code Error output on decoder.\r\n", "- P and N outputs (on encoder) or inputs (on decoder) may be active high or active low, selected by a generic.\r\n", "- P and N outputs on encoder may be controlled to be \u201cfull width\u201d (NRZ) or \u201chalf width\u201d (RZ) to suit the external LIU.\n        ", "\n            - Alpha tests look good.\r\n", "- Code and documentation available in the HDBN project in CVSWeb\r\n        "]},
{"details": ["\n    Name: uart_fpga_slow_control", "\n    Created: Aug 29, 2011", "\n    Updated: Jul  2, 2017", "\n        SVN Updated: Apr 11, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "\n        ", "\n            ", "\r\n\r\n", "\r\n", "Based on:\r\n", "\r\n"]},
{"details": ["\n    Name: xge_mac", "\n    Created: May 19, 2008", "\n    Updated: Apr 20, 2013", "\n        SVN Updated: Mar 15, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 9 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The 10GE MAC Core implements the Media Access Control functions for 10Gbps operation as defined in IEEE Std 802.3ae.\r\n", "\n        ", "\n            1. Interfaces\r\n", "  - XGMII Interface (64-bit single clock edge)\r\n", "  - POS-L3 like Interface for core logic side\r\n", "  - Wishbone Interface for control\r\n", "2. Inter-Frame GAP\r\n", "  - Deficit Idle Count per Clause 46\r\n", "3. Pause Frames\r\n", "  - Received Pause Frames filtering\r\n", "  - Receive Indication\r\n", "4. LAN mode operation\r\n", "5. Link Status\r\n", "  - Local Fault Detection\r\n", "  - Remote Fault Detection/Indication\r\n", "6. Latency\r\n", "  - Low-latency flow-through mode (120ns TX, 160ns RX)\r\n", "\n        ", "\n            1. Some issues reported with synthesis of FIFO's in Xilinx. Recommend using XIL define.\n        ", "\n            - (05/31/2008) Verilog code completed\r\n", "- (06/06/2008) SystemC and Verilog simulations completed\r\n", "- (03/06/2009) Validated in Altera FPGA running traffic against other MAC\r\n", "- (03/06/2009) Validated interfacing to external 10GE PHY using XAUI links\r\n", "- (12/13/2009) Changed packet interface to big endian\r\n", "- (12/13/2009) Added SERDES examples to tb_xge_mac.v\r\n", "- (2/7/2012) Updates for Xilinx synthesis\r\n", "- (2/15/2012) Core user reported passing traffic in Xilinx FPGA\r\n", "- (11/23/2012) Design improvements for timing\r\n", "- (11/23/2012) Added XIL define option for FIFO synthesis with Xilinx\r\n", "- (11/23/2012) Added a prototype System Verilog testbench (not for general use)\r\n", "- (11/25/2012) Added basic packet statistics. Timing improvements. Reduced FIFO size.\r\n", "\n        ", "\n            - RMON Statistics\r\n", "- Store-and-forward mode\r\n", "\n        "]},
{"details": ["\n    Name: xge_ll_mac", "\n    Created: Nov 15, 2012", "\n    Updated: Feb  1, 2016", "\n        SVN Updated: Dec  1, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a fork of the xge_mac and was released by the Computer Architecture Group (", " of the University of Heidelberg.\r\n", "\r\n", "Main changes in this fork:\r\n", "-Unwanted FIFOs removed\r\n", "-Latency reduced due to the removal of the FIFOs and a new CRC implementation\r\n", "-Interface very similar to the one of the Xilinx MAC\r\n", "\r\n", "This core is in production use.\n        "]},
{"details": ["\n    Name: dqpskmap", "\n    Created: Sep 28, 2013", "\n    Updated: Sep 29, 2013", "\n        SVN Updated: Sep 29, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            DQPSK symbol mapper suitable for TETRA/APCO-25 physical layer.\n        "]},
{"details": ["\n    Name: can", "\n    Created: Feb 11, 2003", "\n    Updated: Dec 30, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 36 reported / 10 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Controller Area Network or CAN is a control network protocol from\r\n", "Bosch that has found wide use in Industrial Automation and the\r\n", "Automotive Industry.\r\n", "\r\n", "Most of the patents of CAN are owned by Bosch and although there\r\n", "are no restictions on developing an opensource CAN IP but for any\r\n", "commercial use the protocol license from Bosch is an indispensable prerequisite. \r\n", "\r\n", "Size is approximately 12k gates (930 flip-flops). \r\n        ", "\n            \n        ", "\n            FILE: CAN.gif\n", "DESCRIPTION: \n", "\n        ", "\n            - Non-Destructive bit-wise arbitration (CSMA/CA)\r\n", "- Message Based Addressing/Filtering\r\n", "- Broadcast Communication\r\n", "- 1 Mbit/Sec Operation\r\n", "- WISHBONE SoC interface\r\n", "- 8051 interface\r\n", "- SJA1000 (Philips) compatible interface.\n        ", "\n            - ", " finished (tested in HW and verified with the Bosch VHDL Reference System) (October, 27, 2004)\r\n\n        ", "\n            - ", "\r\n\n        "]},
{"details": ["\n    Name: bluespec-80211atransmitter", "\n    Created: Jun 26, 2008", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This package implements a parameterized baseband hardware logic for an 802.11a\r\n", "Transmitter. This project has since been subsumed by the OFDM baseband project which can also be found on opencores. \r\n", "\r\n", "\r\n", "\r\n", "\r\n", "\n        ", "\n            Handles Lowest 3 802.11a speeds.\n        ", "\n            - Complete Version Committed\r\n", "\n        "]},
{"details": ["\n    Name: baudgen", "\n    Created: Dec  5, 2007", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Ever needed a pulse at a given frequency ( period ).\r\n", "\r\n", "Well that is what BaudGen gives you.\r\n", "\r\n", "By the use of parameters, you specify the frequency of the clock you wish to divide, the period ( baud rate ) you wish out, and optionally, how fast you want an over sample output.\r\n", "\r\n", "BaudGen works out the required count values, and outputs one clock wide pulses at the required rate.\r\n", "\n        "]},
{"details": ["\n    Name: auto_baud", "\n    Created: Sep 17, 2002", "\n    Updated: Mar 11, 2013", "\n        SVN Updated: Mar 11, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This module scans an incoming stream of rs232 serial characters.  It constantly looks for a new character, which it detects by seeing the \"start\" bit.  When a condition resembling a start bit is detected, the module then begins a measurement window, to try and determine the BAUD rate of the incoming character.  Since many different characters have different bit transitions because of their different data content, this module actually only \"targets\" a single character -- in this case the \"carriage return\" character (0x0d).  How can it tell if the character is the carriage return?\r\n", "\r\n", "Well, once it finishes the measurement interval (first 2 bits of the received character) then it uses the measurement to produce a BAUD rate clock.  The module uses this BAUD rate clock internally to verify the remaining 8 bits in the serial character (total of 10 bits per received character, including start/stop bits.  Parity is supported, but has never been tested.)\r\n", "\r\n", "If the remainder of the character verifies correctly to be a carriage return character, the measurement is accepted as valid, and the module then produces the BAUD rate clock externally, and flags that it has \"locked\" onto the BAUD rate of the incoming characters.\r\n", "There are two versions of this module:  One for a single lock at the beginning of the session, which is then maintained for the entire duration of the session (this one is called \"auto_baud.v\").  And another version constantly tracks the incoming characters, which allows for changes in the clock rate and/or BAUD rate of incoming characters to happen at any time, and the BAUD rate will adjust as soon as the carriage return character is detected (this one is called \"auto_baud_with_tracking.v\")  Because of the extra logic needed to produce a BAUD rate while checking a possible new BAUD rate at the same time, the tracking version is slightly larger than the \"single lock\" version, and it will work with faster clock speeds.\r\n", "\r\n", "The auto_baud generator is intended for use in \"human interface\" rs232 serial applications.  It has also been tested with \"text file transfer\" in hyperterm and SecureCRT terminal programs, to see if it would function during higher speed character transfer, and it worked just fine.\n        ", "\n            - Tested in Xilinx XC2V200 hardware, no simulation available.\r\n", "- Test results, and documentation given in code header comments.\r\n", "- A PC using \"hyperterm\" and \"SecureCRT\" was used for testing.\r\n", "- \"auto_baud.v\" consumes 59 slices and works up to 87 MHz (no constraints.)\r\n", "- \"auto_baud_with_tracking.v\" consumes 93 slices, operates up to 102 MHz (no constraints.)\r\n", "- Code is written in Verilog and VHDL.  Both versions have been tested.\r\n", "- Default parameter settings work from 300 BAUD up to 115200 BAUD with any FPGA board clock between 30 MHz and 100 MHz.\r\n", "- Clock speeds lower than 30 MHz support lower BAUD rates, like 9600.  See code for details.\r\n", "- The new VHDL version is a package file in the SVN repository trunk.\r\n", "- Fully parameterized module.\r\n", "- Will operate just fine with \"non standard\" BAUD rates -- such as MIDI (musical instrument digital interface.)  No calculations required.\r\n", "- Works with \"rs232_syscon\" for an easier bring up of debugging sessions.\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: wbuart32", "\n    Created: Aug 25, 2016", "\n    Updated: Feb 20, 2017", "\n        SVN Updated: Nov 15, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            ", " a UART core, ... ", " (a good) ", " ... my own UART core.\r\n", "At one time, the biggest drawback to the files in these directories was that there wasn't a version of this UART interface containing a FIFO.  Well, no more.  Now there is a wbuart.v file that can be integrated into a wishbone/B4/pipeline bus.  As mentioned above, this module\r\ncontains a FIFO with a parameterized length that can extend up to 1023 entries.  Indeed, recent changes have even added in optional hardware flow control, should you wish to use it.\r\n\r\n", "Thus this is a very simple and easy to use controller.\n        "]},
{"details": ["\n    Name: spi_master_controller", "\n    Created: Mar 12, 2015", "\n    Updated: Jun 20, 2017", "\n        SVN: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This is a simple SPI Master Core with a FIFO buffer. It was created following this timing diagram\r\n", "\r\n\n        ", "\n            Until I figure out how to upload the file to the OpenCores SVN Server, the files will be available to download on my github repository here ", "\n        "]},
{"details": ["\n    Name: line_codes", "\n    Created: Nov 22, 2007", "\n    Updated: Nov 25, 2007", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            - Everything was tested and is believed to be bug-free, but no warranties. \n        ", "\n            VHDL implementation of the AMI --- Alternate Mark Inversion --- and HDB1 --- High Density Bipolar of order 1 line codes. \r\n", "\r\n", "For other line code refer to: ", "\n        ", "\n            - AMI\r\n", "  - encoder\r\n", "  - decoder\r\n", "  - simulation files for both encoder and decoder\r\n", "- HDB1\r\n", "  - encoder\r\n", "  - decoder\r\n", "  - simulation files for both encoder and decoder\n        "]},
{"details": ["\n    Name: ahci_sata", "\n    Created: Feb 13, 2013", "\n    Updated: May 19, 2017", "\n        SVN: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            please check the source code from:\r\n", "\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: adat_optical_feed_forward_receiver", "\n    Created: Jul 25, 2008", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a feed forward receiver for an ADAT lightpipe optical datastream. This type of multichannel audio connection is widely used in professional digital recording studios. It consists of eight 24 bit wide audio words, at a sample rate (wordclock) of 32kHz, 44,1kHz or 48kHz. It can double the sample rate at the cost of half the number of channels, this is called S-MUX (not supported yet). There are 4 user bits to carry extra data (MIDI, S-MUX indicator, timecode and spare). ADAT streams are encoded with NRZI coding, meaning a change in the ADAT stream is a \"1\", with no change a \"0\" is sent.\r\n", "\r\n", "The receiver needs one extra input besides the ADAT stream: Any stable clock (m_clk) between 80MHz and 160MHz should work.\r\n", "\r\n", "One instance is used: a 12x8 multiplier with the 12 MSB's output. Compiled for an Altera Cyclone II the design uses 682LE's and 2 embedded 9 bit multipliers.\r\n", "\r\n", "I'm glad to announce that I finally had the opportunity to test and optimize this design, and it's now FPGA proven. I also slimmed down the design to 682LE's. If you are using this design in a larger project, and have no use for a bus-like interface, the registers can be implemented in M4K blocks in the Altera Cyclone II, and it uses even less LE's (I think in the 250-300 range).\n        ", "\n            - feed forward: other than a non-related clock signal, only the ADAT data stream is required.\r\n", "- outputs the 8 audio words on a databus.\r\n", "- regenerates the wordclock from the received stream.\r\n", "- outputs the user bits as seperate pins.\r\n", "- adapts to speed changes.\r\n", "- should (!) lock on to the stream in a matter of seconds.\n        ", "\n            - VHDL code written\r\n", "- testbench completed\r\n", "- simulation of design\r\n", "- Tried the design in an FPGA.\r\n", "\r\n", "Todo:\r\n", "- comment the code.\n        ", "\n            FILE: thumb_waves1.jpg\n", "DESCRIPTION: Some ADAT frames in simulation\n", "\n        ", "\n            FILE: thumb_waves2.jpg\n", "DESCRIPTION: Frame delimiter closeup\n", "\n        "]},
{"details": ["\n    Name: hdlc", "\n    Created: Sep 25, 2001", "\n    Updated: Dec 24, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            - 8 bit parallel backend interface\r\n", "- use external RX and TX clocks\r\n", "- Start and end of frame pattern generation\r\n", "- Start and end of frame pattern checking\r\n", "- Idle pattern generation and detection (all ones)\r\n", "- Idle pattern is assumed only after the end of a frame which is signaled by an abort signal\r\n", "- Zero insertion \r\n", "- Abort pattern generation and checking\r\n", "- Address insertion and detection by software\r\n", "- CRC generation and checking (Optional, external, since CRC-16 or CRC-32 can be used)\r\n", "- FIFO buffers and synchronization (External)\r\n", "- Byte aligned data (if data is not aligned to 8-bits extra random bits are inserted)\r\n", "- Q.921, LAPB and LAPD compliant.\r\n", "- For complete specifications refer to spec document\n        ", "\n            FILE: HDLC_top.jpg\n", "DESCRIPTION: Core top block diagram\n", "\n        ", "\n            The VHDL code is ready in the opencores CVS. The code needs verification contact me if you are intrested in helping me. \r\n", "\r\n", "- also see Download section\r\n", "\r\n        ", "\n            ", "\r\n", ": which includes HDLC Framing extraction, zero removal and conversion from serial to parallel.\r\n", "\n            "]},
{"details": ["\n    Name: i2c_master_slave_core", "\n    Created: May 22, 2008", "\n    Updated: Dec 16, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            Description of project..\r\n", "\r\n", "This design is Wishbone compatible I2C core. This core can work as I2C master as well as slave.\r\n", "VMM Test-bench is also available.\r\n", "\n        ", "\n             Both Master and slave operation\r\n", "\r\n", "  Both Interrupt and non interrupt data-transfers\r\n", "\r\n", "  Start/Stop/Repeated Start generation\r\n", "\r\n", "  Fully supports arbitration process\r\n", "\r\n", "  Software programmable acknowledge bit\r\n", "\r\n", "  Software programmable time out feature\r\n", "\r\n", "  programmable address register\r\n", "\r\n", "  Programmable SCL frequency\r\n", "\r\n", "  Soft reset of I2C Master/Salve\r\n", "\r\n", "  Programmable maximum SCL low period\r\n", "\r\n", "  synthesis core\r\n", "\r\n", "\n        ", "\n            Design: Done\r\n", "VMM based verification Environment Creation: Done \n        "]},
{"details": ["\n    Name: i2c_master_slave", "\n    Created: Oct 29, 2008", "\n    Updated: Jun 10, 2012", "\n        SVN Updated: Jun  5, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 4 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Since lots of people ask me questions about my core, i want to clarify some things:\r\n", "1) the master works, the slave is not entirely thought-through, i used it in simulation only.\r\n", "2) i'm adding a diagram, that explains how to control the core.\r\n", "3) adding a file name i2c_master_v01.vhd, that containes the master only.\r\n", "4) since i have some time now, i will try to work on the slave.\r\n", "\r\n", "have fun!\r\n", "Eli.\r\n", "\r\n", "The file name is V02 because V01 contained only an unwilling to work master.\r\n", "it will not be posted here.\r\n", "Master:\r\n", "  *supports burst writes and reads\r\n", "  *fully controlled by interface\r\n", "for now i build a different interface for each use of the core.\r\n", "in he future i plan to build a generic controller, that will act as a bridge from the PCI PLB to I2c.  \n        "]},
{"details": ["\n    Name: gpio", "\n    Created: Sep 25, 2001", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            The GPIO IP core is user-programmable general-purpose I/O controller. Its use is to implement functions that are not implemented with the dedicated controllers in a system and require simple input and/or output software controlled signals. \n        ", "\n            The following lists the main features of GPIO IP core: \r\n\r\n- Number of general-purpose I/O signals is user selectable and can be in range from 1 to 32. For more I/Os several GPIO cores can be used in parallel. \r\n- All general-purpose I/O signals can be bi-directional (external bi-directional I/O cells are required in this case). \r\n- All general-purpose I/O signals can be three-stated or open-drain enabled (external three-state or open-drain I/O cells are required in this case). \r\n- General-purpose I/O signals programmed as inputs can cause interrupt to the CPU. \r\n- General-purpose I/O signals programmed as inputs can be registered at raising edge of system clock or at user programmed edge of external clock. \r\n- All general-purpose I/O signals are programmed as inputs at hardware reset. \r\n- Auxiliary inputs to GPIO core to bypass outputs from RGPIO_OUT register. \r\n- Alternative input reference clock signal from external interface. \r\n- WISHBONE SoC Interconnection Rev. B compliant interface \r\n\r\nMore information about the WISHBONE SoC and a full specification can be found ", ".\r\n\r\nFor further information, questions and general discussions related to the GPIO core, please visit the Cores Mailing list.\r\n\n        ", "\n            - verilog RTL and verification suite are finished (see Downloads section)\r\n", "- specification document is finished (see Downloads section)\r\n        "]},
{"details": ["\n    Name: ftdi_wb_bridge", "\n    Created: Jul 12, 2015", "\n    Updated: Jul 13, 2015", "\n        SVN Updated: Jul 13, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This component provides a bridge from a FTDI asynchronous FIFO interface (such as found on the FT245R or FT2232) to a Wishbone master interface & GPIO interface.\r\n", "\r\n", "Devices such as the FT2232 must be switched into asynchronous FIFO mode using the FT_PROG EEPROM programming tool from FTDI.\r\n", "\r\n", "The component supports writes down to byte level granularity, and reads down to a 32-bit word level.\n        ", "\n            Verified on FPGA on the miniSpartan6+ board which uses the FTDI FT2232HL. Many megabytes of self checking transfers to and from SDRAM using this component.\r\n", "\r\n", "The supplied smoke test works with the free version Modelsim.\r\n", "\r\n", "Test project for the miniSpartan6+: \r\n", "\r\n", "\n        ", "\n            CLK_DIV - Clock divider (minimum is 2)\r\n", "LITTLE_ENDIAN - System is little endian (1) or big endian (0)\r\n", "ADDR_W - Width of Wishbone address bus\r\n", "GP_OUTPUTS - Number of GPIO outputs (1 - 8)\r\n", "GP_INPUTS - Number of GPIO inputs (1 - 8)\r\n", "GP_IN_EVENT_MASK - Bit mask of inputs which are events that are registered and cleared on read\n        ", "\n            With the default configuration...\r\n", "\r\n", "- the design contains 122 flops.\r\n", "- synthesizes to > 160MHz on Xilinx Spartan 6 LX9 (speed -3)\r\n", "- write performance: 5.4MB/s (block size of 2KB)\r\n", "- read performance: 2MB/s (block size of 2KB)\n        "]},
{"details": ["\n    Name: ft245r_interface", "\n    Created: May 17, 2015", "\n    Updated: Jun 23, 2016", "\n        SVN Updated: Jun 23, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n"]},
{"details": ["\n    Name: ft2232hcore", "\n    Created: Jul  7, 2010", "\n    Updated: Mar  8, 2014", "\n        SVN Updated: Jul  7, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            The FT2232H is a USB2.0 Hi-Speed USB Device to FIFO IC.\r\n", "This core allows the use of this chip with an FGPA design in high speed FT245 style synchronous FIFO mode.\r\n", "Data rates up to 25 mbytes/s can be achieved. The core has internal FIFOs on the receive and transmit for improved throughput.\r\n", "\r\n", "For more information see FTDI's appnote \"AN_130_FT2232H_Used_In_FT245 Synchronous FIFO Mode.pdf\"\r\n", "\r\n", "Included: VHDL core, NIOS test application, PC test application\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: ezusb_io", "\n    Created: Jul 23, 2014", "\n    Updated: Jul 29, 2014", "\n        SVN Updated: Jul 29, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            It's a general purpose Cypress EZUSB communication core which was developed for ", " and supports the following features:\r\n\r\n", "\n            The usage of this core is best described by a commented port definition:\r\n", "\n            This is an example instantiation in Verilog:\r\n\r\n", "\n            A component declaration of the module can be found in file ", "\r\nThis is the VHDL variant of the instantiation from above.\r\n\r\n"]},
{"details": ["\n    Name: ethmac", "\n    Created: Sep 25, 2001", "\n    Updated: Jan 10, 2016", "\n        SVN Updated: Feb 14, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 11 reported / 3 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Ethernet MAC (Media Access Control), sublevel within the Data Link Layer of the OSI reference model. This core is designed for implementation of CSMA/CD LAN in accordance with the IEEE 802.3 standards. \r\n", "\r\n", "The MAC is the portion of ethernet core that handles the CSMA/CD protocol for transmission and reception of frames. It peforms Frame Data Encapsulation and Decapsulation, Frame Transmission, and Frame Reception.\r\n", "\r\n", "Size is approximately 28k gates (2400 flip-flops).\r\n        ", "\n            ", "\n            ", "\r\nThe  IP core has been chosen by ", ", proven in FPGA technology and integrated into a Flextronics' design. Flextronics can offer commercial design services to companies that want to use this IP in their products - for more information fill out this ", ".\r\n"]},
{"details": ["\n    Name: ethernet_tri_mode", "\n    Created: Nov 25, 2005", "\n    Updated: Mar  5, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 26 reported / 7 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            mail group is added to track all the Q&A from the author. \r\n", "If you have any question about the design, please send your question to mail group. The answer will be recorded as reference for other people. \r\n", "Homepage:   ", " \r\n", "Group email:   opencores-tri-mode-eth-mac@googlegroups.com \r\n", "\r\n", "\r\n", "10_100_1000 Mbps tri-mode ethernet MAC implements a MAC controller conforming to IEEE 802.3 specification. It is designed using less than 2000 LCs/LEs to implement full function. It will use inferred PADs to reduce technology dependancies. The whole project will be finished in TEN weeks inluding verilog coding,RTL level verification.\r\n", "A GUI configuration interface,created by tcl/tk script language,is convenient for configuring optional modules,FiFo depth and verifcation parameters. Furthermore,a verifcation system was designed with tcl/tk user interface,by which the stimulus can be generated automatically and the output packets can be verified with CRC-32 checksum.\r\n", "\n        ", "\n            \u00d8\tImplements the full 802.3 specifiction.\r\n", "\u00d8\thalf-duplex support for 10 100 Mbps mode\r\n", "\u00d8\tFIFO insterface to user application\r\n", "\u00d8\tsupport pause frame generation and termination\r\n", "\u00d8\ttransmitting frames souce MAC address insertion\r\n", "\u00d8\treceiving frames destination MAC address filter\r\n", "\u00d8\treceiving broadcast frames throughout constraint\r\n", "\u00d8\tsupport Jumbo frame 9.6K\r\n", "\u00d8\tRMON MIB statistic counter\r\n", "\n        ", "\n            - collect some documents about tri-mode ethernet MAC controller(done)\r\n", "- coding in verilog(done)\r\n", "- coding verification scripts(done)\r\n", "- starting verification(done)\r\n", "- writing specification(done)\r\n", "- FPGA proven(done) 2006-06-20\r\n", "- Supporting modelsim simulator. I also changed the default simulator from NC-sim to modelsim which is much populor than NC-sim :->. As well, the new version \"dll\" files for modelsim are ready. (done) 2008-7-26\r\n", "- My next task is to connect this IP core to xilinx Microblaze processor.(done)2008-8-17\r\n", "A new directory EDK was created in project root. All needed driver and EDF for EDK are available there.  \r\n", "\n        ", "\n            ##### START OF AREA REPORT #####\r\n", "I/O ATOMs:       321\r\n", "\r\n", "Total LUTs:  1839 of 10570 (17%)\r\n", "Logic resources:  1839 ATOMs of 10570 (17%)\r\n", "ATOM count by mode:\r\n", "  normal:       1555\r\n", "  arithmetic:   284\r\n", "\r\n", "DSP Blocks:     0  (0 nine-bit DSP elements).\r\n", "DSP Utilization: 0.00% of available 6 blocks (48 nine-bit).\r\n", "ShiftTap:       0  (0 registers)\r\n", "MRAM:           0  (0% of 1)\r\n", "M4Ks:           0  (0% of 60)\r\n", "M512s:          0  (0% of 94)\r\n", "Total ESB:      0 bits \r\n", "##### END OF AREA REPORT #####]\r\n", "\n        ", "\n            1. 1G mode ,46-1500 length packet sending and receiving was tested\r\n", "2. 100M mode,  46-1500 length packet sending and receiving was tested\r\n", "3. 10M mode ,  46-1500 length packet sending and receiving was tested\n        ", "\n            Logic Utilization:\r\n", "  Number of Slice Flip Flops:        1,198 out of  21,504    5%\r\n", "  Number of 4 input LUTs:           1,526 out of  21,504    7%\r\n", "Logic Distribution:\r\n", "  Number of occupied Slices:                            1,206 out of  10,752   11%\r\n", "  Number of Slices containing only related logic:   1,206 out of   1,206  100%\r\n", "  Number of Slices containing unrelated logic:            0 out of   1,206    0%\r\n", "      *See NOTES below for an explanation of the effects of unrelated logic\r\n", "Total Number 4 input LUTs:          1,555 out of  21,504    7%\r\n", "  Number used as logic:              1,526\r\n", "  Number used as a route-thru:          29\r\n", "  Number of bonded IOBs:               78 out of     448   17%\r\n", "  Number of BUFG/BUFGCTRLs:             5 out of      32   15%\r\n", "    Number used as BUFGs:                2\r\n", "    Number used as BUFGCTRLs:            3\r\n", "  Number of FIFO16/RAMB16s:             4 out of      72    5%\r\n", "    Number used as FIFO16s:              0\r\n", "    Number used as RAMB16s:              4\r\n", "\r\n", "Total equivalent gate count for design:  20,650\r\n", "Additional JTAG gate count for IOBs:  3,744\r\n", "Peak Memory Usage:  220 MB\r\n", "\n        "]},
{"details": ["\n    Name: 16_qam_qadm", "\n    Created: Apr  4, 2016", "\n    Updated: Apr 12, 2016", "\n        SVN Updated: Apr  5, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a complete 16 Quadrature amplitude modulator and demodulator with output precision of 10 bits (can be increased/decreased by changing the LUT).\r\n", "The o/p of QAM is 1 sample/clkpulse with 1024 samples per period of o/p(sent to DAC or your application to be further processed), with input as expected is 4 bit digital.\r\n", "The i/p of QADM is again 1 sample/clkpulse with 1024 samples per period taken from ADC, with o/p as the digital 4bit data.\r\n", "There is no error tolerance in the QADM so you might get jibberish when input is incorrect(you can just consider majority of the demodulated wave as the i/p in your main program).\r\n", "(Added features new rev available on request)\n        "]},
{"details": ["\n    Name: 1g_ethernet_dpi", "\n    Created: Oct  8, 2016", "\n    Updated: Oct 12, 2016", "\n        SVN Updated: Mar  8, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Current project provides idea of complex network design verification via [{Linux-tunnel interface} + SystemVerilog DPI-C}].\n        "]},
{"details": ["\n    Name: udp_ip_stack", "\n    Created: Oct 11, 2011", "\n    Updated: Jun 30, 2017", "\n        SVN Updated: Apr 30, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 16 reported / 12 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            Implements UDP, IPv4, ARP protocols\r\n", "Zero latency between UDP and MAC layer (combinatorial transfer during user data phase)\r\n", "Allows full control of UDP src & dst ports on TX.\r\n", "Provides access to UDP src & dst ports on RX (user filtering)\r\n", "Couples directly to Xilinx Tri-Mode eth Mac via AXI interface\r\n", "choice of ARPV2 layer with multislot cache, or smaller single slot ARP for point to point implementations\r\n", "Separate building blocks to create custom stacks\r\n", "Easy to tap into the IP layer directly\r\n", "Separate clock domains for tx & rx paths\r\n", "Tested for 1Gbit Ethernet, but applicable to 100M and 10M\r\n", "More detail in doco under Downloads\r\n", "- provided by Peter Fall and the FIXQRL project\r\n", "- Applicable license is the \"BSD 3-Clause License\"\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: a_vhd_16550_uart", "\n    Created: Feb 17, 2006", "\n    Updated: Dec  8, 2010", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 11 reported / 10 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            A UART that is compatible with the industry standard 16550D\r\n", "\r\n", "Includes wrappers for the Wishbone and AMBA APB busses\r\n", "\n        ", "\n            Uses parts from the project (3.17 or later)\r\n", "\r\n", "Sticky parity is not supported \r\n", "FIFO's are always enabled\r\n", "\n        ", "\n            Design is finished \r\n", "\r\n", "18 Jun 2007\r\n", "P. Azkarate's addition of range for integers in Rx, Tx modules\r\n", "this helps when using the Altera tools\r\n", "\r\n", "12 July 2007\r\n", "fix a couple problems found by Matthias Klemm with 5, 6, and 7 bit transfers\r\n", "\r\n", "14 July 2007\r\n", "Correct FCR bit 3 information (DMA Mode control)\r\n", "\r\n", "4 Aug 2007\r\n", "fix some TOI problems\r\n", "\r\n", "18 Aug 2007\r\n", "add stopB to sensitivity list in TX module (works the same, but removes warning)\r\n", "\r\n", "12 Oct 2007\r\n", "fixed the bug reports (dated 10/11 Oct 2007)\r\n", "THRE Interrupt will now be generated when trans FIFO is empty and interrupt enable bit changes from disabled to enabled.  (note on THRE operation added par 3.3)\r\n", "\r\n", "The Receiver Line Status Interrupt is cleared as suggested by Matthias Klemm (note to bug report dated 10/12/07) (mod to this fix 13 oct 2007)\r\n", "\r\n", "21 July 2008\r\n", "mod equ for iBreak_ITR, as suggested by Nathan Z.\r\n", "\n        "]},
{"details": ["\n    Name: 10_100m_ethernet-fifo_convertor", "\n    Created: Sep 17, 2009", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Feb 14, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            +-------------------------------------------------------------------------------+\r\n", "; Flow Summary                                                                  ;\r\n", "+------------------------------------+------------------------------------------+\r\n", "; Flow Status                        ; Successful - Sun Dec 13 21:49:10 2009    ;\r\n", "; Quartus II Version                 ; 9.0 Build 132 02/25/2009 SJ Full Version ;\r\n", "; Revision Name                      ; Ethernet                                 ;\r\n", "; Top-level Entity Name              ; test_feedback                            ;\r\n", "; Family                             ; Cyclone III                              ;\r\n", "; Device                             ; EP3C40Q240C8                             ;\r\n", "; Timing Models                      ; Final                                    ;\r\n", "; Met timing requirements            ; N/A                                      ;\r\n", "; Total logic elements               ; 1,026 / 39,600 ( 3 % )                   ;\r\n", ";     Total combinational functions  ; 879 / 39,600 ( 2 % )                     ;\r\n", ";     Dedicated logic registers      ; 622 / 39,600 ( 2 % )                     ;\r\n", "; Total registers                    ; 622                                      ;\r\n", "; Total pins                         ; 24 / 129 ( 19 % )                        ;\r\n", "; Total virtual pins                 ; 0                                        ;\r\n", "; Total memory bits                  ; 11,992 / 1,161,216 ( 1 % )               ;\r\n", "; Embedded Multiplier 9-bit elements ; 0 / 252 ( 0 % )                          ;\r\n", "; Total PLLs                         ; 1 / 4 ( 25 % )                           ;\r\n", "+------------------------------------+------------------------------------------+\n        "]},
{"details": ["\n    Name: 8b10b_encdec", "\n    Created: Sep 11, 2006", "\n    Updated: Mar 15, 2016", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This project, written in generic synthesizable VHDL, provides two separate cores for encoding and decoding byte data according to the 8b/10b protocol. 8b/10b is widely used in high speed serial communication standards that need a run-length limited, DC balanced data stream for reliable data transmission and clock recovery. The encoder accepts a parallel 8-bit raw input and generates a parallel 10-bit encoded value based on the data along with a running disparity value. The decoder does the reverse, providing a decoded 8-bit value from the 10-bit encoded input. These cores can be easily incorporated into serializer/deserializer (serdes) communications applications.\n        ", "\n            The two main modules provide a complete VHDL implementation that closely follows the original IBM article \"A DC-Balanced, Partitioned-Block, 8B/10B Transmission Code\" published by A.X. Widmer and P.A. Franaszek and the resulting US patent #4,486,739.  For clarity, the VHDL code references the figures and tables of the patent document.  Please note that the patent has now expired.\r\n", "\r\n", "Encoder:\r\n", "+ 8b/10b Encoder (file: 8b10b_enc.vhd)\r\n", "  + Synchronous clocked inputs (latched on each clock rising edge)\r\n", "    + 8-bit parallel unencoded data input\r\n", "    + KI input selects data or control encoding\r\n", "  + Asynchronous active high reset initializes all logic\r\n", "  + Encoded data output\r\n", "    + 10-bit parallel encoded output valid 1 clock later\r\n", " \r\n", "Decoder:\r\n", "+ 8b/10b Decoder (file: 8b10b_dec.vhd)\r\n", "  + Synchronous clocked inputs (latched on each clock rising edge)\r\n", "     + 10-bit parallel encoded data input\r\n", "  + Asynchronous active high reset initializes all logic\r\n", "  + Decoded data, disparity and KO outputs\r\n", "    + 8-bit parallel unencoded output valid 1 clock later\r\n", "\r\n", "There are two Testbench files; one that tests the encoder and a second that drives the decoder with the latched output from the encoder.  All 256 data characters, \"D\", and all 12 control characters , \"K\", are sequenced.\r\n", "\r\n", "- Encoder Testbench (file: enc_8b10b_TB.vhd)\r\n", "\r\n", "- Combined Testbench (file: endec_8b10b_TB.vhd)\n        ", "\n            The two source files and the two testbench files are now complete and have been functionally simulated. The files, and a  brief usage document have been uploaded to CVS\r\n", "\n        "]},
{"details": ["\n    Name: a_vhdl_can_controller", "\n    Created: Aug 23, 2007", "\n    Updated: May  5, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            A (as far as I know) untested VHDL translation of the Verilog Can protocol Controller\r\n", "\r\n", "To Download, click at the \"Downloads\" button upper right part of this page\r\n", "\r\n", "This project is a translation Igor Mohor's Verilog ", " (CAN Protocol Controller)\n        ", "\n            The modules have \"_vhdl_\" added to their names, to ease compare simulation with Verilog version (for those with mixed a language simulator)\n        ", "\n            use at own risk - have no had time to test/simulate\r\n", "\r\n", "check the Philips SJA1000 data sheet and the ", " (Verilog project page) for more information\n        "]},
{"details": ["\n    Name: usb_fpga_1_11", "\n    Created: Jul 14, 2010", "\n    Updated: Nov  3, 2011", "\n        SVN Updated: Apr  9, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The ZTEX USB-FPGA-Module 1.11 is a Spartan 6 FPGA board with USB 2.0 interface, 64 MB DDR-SDRAM and Flash memory.\n        ", "\n            ", "\n            ", "\r\n", "\r\nSpartan 6 USB-FPGA-Module 1.11 from ZTEX. Click on the image for a larger version.\r\n  ", "\r\nBlock diagram of Spartan 6 USB-FPGA-Module 1.11 from ZTEX\r\n  ", "\n            "]},
{"details": ["\n    Name: usb_fpga_2_13", "\n    Created: Apr 10, 2014", "\n    Updated: Jul 31, 2014", "\n        SVN Updated: Apr 11, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            USB-FPGA Module 2.13 is an Artix 7 FPGA Board with USB 2.0 controller, 256 MB DDR3 SDRAM, Flash, many GPIO's and on-board voltage regulators. It's available in 4 variants with different FPGA types: XC7A35T, XC7A50T, XC7A75T and XC7A100T\r\n", "\n        ", "\n            ", "\n            ", "\r\n\n        ", "\n            Click on the images for larger versions.\r\n", "\r\n", "\r\n\tTop side of USB-FPGA Module 2.13d with Artix 7 XC7A100T FPGA, 256 MB DDR3 SDRAM and USB 2.0 interface.\r\n  ", "\r\n\tUSB-FPGA Module 2.13 with heat sink as delivered with XC7A50T to XC7A100T variants.\r\n  ", "\n            "]},
{"details": ["\n    Name: xenie", "\n    Created: May 10, 2017", "\n    Updated: May 29, 2017", "\n        SVN Updated: May 29, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Xenie is a product family of highly integrated FPGA modules that includes the Xilinx\u00ae Kintex7\u00ae FPGA and 10Gbit Ethernet Marvell Alaska X 88X3310P PHY on a single board. The module is fully programmable to provide \u201cAny to Ethernet\u201d high performance connectivity. On the line side, the PHY supports the following protocols 10GBASE-T, 5GBASE-T, 2.5GBASE-T, 1000BASE-T, 100BASE-TX and 10BASE-Te.\r\nThe PHY is compatible with the IEEE 802.3an, IEEE 802.3bz standards, NBASE-T\u2122 Specification and supports IEEE802.1ae MACsec protocol and PTP functionality with IEEE 1588 v2. PTP time-stamp processing.", "\r\n\r\n", "\r\n\r\n", "The FPGA's MGT lines support rates up to 12.5Gbit. The module is equipped with 1 GByte of DDR3L SDRAM and 32 MByte of Flash memory as a storage for configuration bitstream. Six GTX multi-gigabit transceivers and three full FPGA I/O banks (in total 150 single-ended I/O or up to 72 differential pairs) with configurable IO voltage are available via two high-speed, high-pin-count, board-to-board connectors. All other necessary supporting circuitry, like clock oscillators and voltage regulators are placed on module, requiring the user to attach literally only connectors and a single DC power supply.\r\n \r\n", "Key Features", "Applications"]},
{"details": ["\n    Name: usb_fpga_1_15", "\n    Created: Jul 28, 2011", "\n    Updated: Nov 28, 2012", "\n        SVN Updated: Apr 11, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The ZTEX USB-FPGA-Module 1.15 is a Spartan 6 FPGA LX45 to LX150 board with USB 2.0 interface, 128 MB DDR2-SDRAM and Flash memory. \n        ", "\n            ", "\n            ", "\r\n", "\r\nUSB-FPGA Module 1.15d with Spartan 6 LX150 (XC6SLX150). Also available with LX45 (1.15a, XC6SLX45), LX75 (1.15b, XC6SLX75) and LX100 (1.15d, XC6SLX100). Click on the image for a larger version.\r\n  ", "\r\nBlock diagram of Spartan 6 LX45 to LX150 USB-FPGA-Module 1.15 from ZTEX\r\n  ", "\n            "]},
{"details": ["\n    Name: ts7300_opencore", "\n    Created: Jun 12, 2006", "\n    Updated: Aug 16, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Boilerplate Verilog for use in Technologic Systems TS-7300 FPGA computer at ", "  Implements bus cycle demultiplexing to an internal 16 and 32 bit WISHBONE bus and 10/100 ethernet interface.   Provided as a ready-to-compile Altera Quartus II project complete with pinlocks, compiler assignments, PLL setting, and timing constraints.  A simple stub module implements a 32 bit register in the address space of the 200Mhz ARM9 CPU that toggles onboard LEDs as an easily extendable example of creating a WISHBONE slave.  Once compiled, simply upload the ts7300_top.rbf bitstream file to the Linux filesystem on the SD card.  The 200Mhz ARM9 processor runs Debian Linux out-of-the-box and includes a \"load_ts7300\" Linux command to configure the FPGA.  No JTAG/ISP cables are required and FPGA configuration takes all of 0.2 seconds.  The Quartus II tools required to compile the project are available free of charge (Quartus II 6.0 web-edition or later) from ", "\r\n", "\r\n", "Intended use of this project is both as a educational tool for evaluating and prototyping other open cores using the WISHBONE bus and as a jump start for Technologic Systems customers creating embedded products on the TS-7300 platform  (or TS-7300 based custom designs).   The inclusion of a 200Mhz GPP (general purpose processor) running Linux provides a powerful platform to study RC (reconfigurable computing) and combined hardware/software embedded design flows.   The ethernet core included is the open source ethernet core project from ", "\r\n", "\r\n", "Things on the TS-7300 the FPGA (Cylone2 2C8) is connected to:\r\n", "- 8Mbyte SDRAM\r\n", "- 16 bpp video DAC on DB15 VGA connector\r\n", "- 10/100 Ethernet PHY #2\r\n", "- 2nd SD card slot\r\n", "- 8 RS232 serial ports\r\n", "- 40 pin GPIO header (includes 2 LEDs)\r\n", "- 224 megabytes address space to the 200Mhz EP9302 ARM9 CPU running Linux 2.4\r\n", "\r\n", "The ARM9 CPU (Cirrus Logic EP9302) running Linux 2.4 is connected to:\r\n", "- 32 to 128 MB SDRAM\r\n", "- 32 to 128 MB NAND flash\r\n", "- PC/104 expansion bus\r\n", "- 1st SD card slot\r\n", "- battery backed RTC\r\n", "- 2 USB 2.0 high-speed host ports\r\n", "- 10/100 Ethernet PHY #1\r\n", "- 2 RS232/RS485 serial ports\r\n", "- 6 user jumpers (JP1-JP6)\r\n", "- 20 GPIO pins (for HD44780 LCD or matrix keypad)\r\n", "- EP2C8 Cyclone2 FPGA\r\n", "\r\n", "The default TS supplied bitstream includes support for all the above while the included project source only includes support for the ARM9 bus interface, GPIO, and ethernet.  These other cores as well as a non-GPL'ed version of the included Verilog bus interface are available from Technologic Systems directly.\r\n", "\r\n", "\r\n", "\n        ", "\n            FILE: 7300stclwp.jpg\n", "DESCRIPTION: Technologic Systems TS-7300 FPGA Computer\n", "\n        ", "\n            - Technologic Systems homepage: ", "\r\n", "- TS-7xxx SBC general support forum: ", "\r\n", "- TS-7300 datasheet: ", "\r\n", "- TS-7300 pricing/order information: ", "\n        "]},
{"details": ["\n    Name: usb_fpga_1_2", "\n    Created: May 11, 2009", "\n    Updated: Jul 15, 2010", "\n        SVN Updated: Aug 11, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The ZTEX USB-FPGA-Module 1.2 is a Spartan 3 FPGA board with USB 2.0 interface.\n        ", "\n            ", "\n            ", "\r\n", "\r\nTop side of the Spartan 3 USB-FPGA-Module 1.2 from ZTEX. Click on the image for a larger version.\r\n  ", "\r\n  Block diagram of Spartan 3 USB-FPGA-Module 1.2 from ZTEX.\r\n  ", "\n            "]},
{"details": ["\n    Name: usb_fpga_2_14", "\n    Created: Feb 20, 2017", "\n    Updated: Jul  2, 2017", "\n        SVN Updated: Dec 13, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            USB-FPGA Module 2.14 is an Artix 7 FPGA Board with an USB 3.0 interface, 256 MB DDR3 SDRAM and Flash memory. Its available in 5 variants from XC7A15T to XC7A100T.\n        ", "\n            ", "\n            ", "\r\n\n        ", "\n            Click on the images for larger versions.\r\n", "\r\n", "\r\n        Top side of the ZTEX> USB-FPGA Module 2.14 with Artix 7, DDR3 SDRAM and EZ-USB FX3 USB 3.0 controller\r\n  ", "\r\nZTEX USB-FPGA Module 2.14 with heat sink and battery option on a ", "\r\n", "\n            "]},
{"details": ["\n    Name: usb_fpga_2_16", "\n    Created: Nov 25, 2013", "\n    Updated: Jul 31, 2014", "\n        SVN Updated: Feb  5, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            An FPGA Board with the largest Artix 7 XC7A200T FPGA, USB 2.0 controller, Flash memory, 100 GPIO's and on-board voltage regulators. \n        ", "\n            ", "\n            ", "\r\n\n        ", "\n            Click on the images for larger versions.\r\n", "\r\n", "\r\n\tTop side of USB-FPGA Module 2.16b with Artix 7 FPGA XC7A200T.\r\n  ", "\r\n\tUSB-FPGA Module 2.16 with active cooler. A heat sink kit containing an active and a passive cooler belongs to the contents of delivery of the FPGA Board.\r\n  ", "\n            "]},
{"details": ["\n    Name: openriscdevboard", "\n    Created: Apr 11, 2008", "\n    Updated: Dec 29, 2008", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Opensource OpenRisc Development Board. All CADsoft Eagle design files available to recreate the board using EagleLite, a freeware PCB design tool. Uses the largest Cyclone 2 device available in a QFP package, thus allowing larger RTL designs to be ported, and at the same time allowing easier PCB design and board assembly. Board design is double sided, and can be manufactured using low cost batch PCB services. But despite only being double layer, it has an almost continuous bottom side ground plane.\r\nA complete system consists of two separate boards;\r\n- Main FPGA board that contains the FPGA, SDRAM, regulators, Santa Cruz expansion header, and Support board expansion header. \r\n- Support board containing SD card slot, SPI flash, C8051, fpgaConfig header, JTAG header, OpenRisc debug header and RS-232 DB9 connector.\r\nA complete FPGA project is available for the board set. This includes a minimal ", "\r\n, ", ", ", ", and ", ". Simulation is possible using Icarus Verilog simulator, and the design can be compiled under Altera Quartus.\r\nSoftware is available to demonstrate copying a software image file from SD flash memory to SDRAM, and then executing the copied image.\r\nSee ", " project for details of configuring FPGA from SD flash memory:\r\n\r\nYou can use this project as a basis for a compact OpenRisc implementation. A complete OpenRisc implementation requires just an FPGA, SDRAM, microSD card, and a tiny C8051.\r\n\r\n\r\n\r\n\n        ", "\n            - Eagle design files compatible with free ", "  \r\n- Simple PCBs can be manufactured using batch PCB services.\r\n- No BGA devices\r\n- Large FPGA (20,000 logic cell Altera Cyclone 2)\r\n- Single 16MByte x32 SDRAM\r\n- Santa Cruz expansion header.\r\n- Support for ", "  \r\n- Support for ", " \n        ", "\n            - OR1K running on board, and able to copy software image from SD flash TO SDRAM, and execute.\r\n- Support for USB and SD/SPI flash Santa Cruz daughter cards.\r\n- Software projects for SDRAM memory test, SD memory test, USB loop back test, and USB mouse emulation.\r\n- Full ", " simulation of complete OpenRISC system, including software\r\n\n        ", "\n            FILE: dscn1315.jpg\n", "DESCRIPTION: \n", "\n        ", "\n            Complete ", " available.\r\nContents:\r\n\r\n- FPGA Main Board\r\n- FPGA Support Board\r\n- USB2Flash programming adapter and USB cable\r\n- Connecting ribbon cables\r\n- Wall wart 5V power supply\r\n- RS-232 cable\r\n- CD-ROM \r\n\r\nEverything is included to allow you to start running right out of the box. And it's all open source! The CD-ROM includes several tools such as Icarus Verilog, GTKwave, Cygwin, OpenRISC tool chain, and of course example projects which you can compile into hardware using Altera Quartus, or simulate using the Icarus simulator. \n        ", "\n            Now supports ", ". Everything you need to test the i2cSlave IP core. An on board connector supports the ", " I2C Host Adapter. Complete Altera hardware project files, documentation, and Aardvark scripts and test software are available.\r\n\n        "]},
{"details": ["\n    Name: mfpga", "\n    Created: Sep 25, 2001", "\n    Updated: Mar 10, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Micro FPGA board is a stand alone, low cost, do-it-yourself board. All components are possible to get from a local electronics shop (with possible exception of Virtex part). Board includes one Xilinx Virtex XCV100 chip.\r\n", "\r\nFPGA is loaded from PC via Xilinx XChecker cable and external power supply must be provided. It is designed for debugging and verification process of small units or cores. See a block diagram for details.\r\n", "\r\n", "\r\n", "\r\n", "\r\n\r\n        ", "\n            - board is finished and it is fully functional\n        ", "\n            ", "\n            ", "Mailing-list:\r\n"]},
{"details": ["\n    Name: ocrp-1", "\n    Created: Sep 25, 2001", "\n    Updated: Jan 22, 2004", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            - small form factor (1dm2) \r\n", "- inexpensive surface mount technology (no Ball Grid Array (BGA) chips) \r\n", "- fast 50k gates or bigger FPGA \r\n", "- basic I/O capabilities like RS232 and IRDA \r\n", "- FLASH memory for FPGA configuration and microprocessor code \r\n", "- fast SDRAM for main memory \r\n", "- direct access to important signals through Logic Analyzer connectors\n        ", "\n            OpenCores Reference Platform 1 (OCRP-1) standalone board was designed as a common prototype platform for testing our IP cores. It has a central FPGA for evaluating and testing IP cores, I/O capabilities, DRAM and FLASH memory. It also has several I/O, JTAG and expansion connectors. It even has real-time clock and a battery. Current PCBs have four layers. \n        ", "\n            FILE: block.gif\n", "DESCRIPTION: Block diagram of a OCRP-1 standalone prototype board\n", "\n        ", "\n            ", "\n            ", "\n            It is a 4 layer multilayer with solder mask, hot air leveling finish and\r\ncomponent print on both sides. All boards have been electronicly tested\r\nagainst the Gerber data (", ").\r\n", "\r\nShipping is done by normal air mail in an envelope protected by sealed air.\r\nEach letter will contain an official invoice calling the product \"printed\r\ncarrier board for education and evaluation purpose\". \r\nWilhelm Mikroelektronik is not responsible for any problems with customs and they do not give any\r\nwarranty on the board. They don't take responsibility for any problems that\r\nmight occur when assembling the board and they can\u00b4t provide any support for\r\nthe board. \r\n", "\r\nWe would like to stress that the fine pitch SMD parts are not intended for\r\nthe unexperienced people. You should be sure that you can assemble it.\r\nIf there is actually a problem with any of the boards (this should not\r\nhappen because of electronic testing) Wilhelm Mikroelektronik will of course provide a free replacement of the PCB.\r\n", "\r\nIf anybody need the stencils for solder cream. They can provide that, too.\r\nThe price per pair (top/bottom) is USD 100 including shipping. Just add to\r\nthe order sheet manually.\r\nFor manual soldering the stencils are not required.\r\n", "\r\n        ", "\n            Due to low demand we have decided not to offer assembled boards. \n        ", "\n            Just completly fill in ", " and it fax back to the Wilhelm Mikroelektronik. They will immediatly process the order. There should be sufficient number of boards on stock. Worldwide registered and insured shipping is now per piece. Payment options are credit card or prepayment to their account (if you can't do credit card payment).", "\r\nIf you need to get in contact with Wilhelm Mikroelektronik, you can send e-mail message to ocrp1@wilhelm.de.\r\n", "\r\nThe following options are available:", "\r\nThere won\u00b4t be any component kits to avoid warranty problems.\n        ", "\n            Special thanks to Matija Golar and ", " for providing layout services.\r\n", "Special thanks to Janez Smid, Tomaz Stare, Matija Milostnik and Brane Lipar from ", " for help with design, organizing PCB manufacturing and layout services. Special thanks to Franc Dolenc and\r\n", " for sponsoring prototype development.\r\n", "\r\nSpecial thanks to Igor Mohor and ", " for assembling the first prototype.\r\n", "\r\nSpecial thanks to info@wilhelm.de and ", " for manufacturing and providing OCRP-1 boards to the OpenCores community.\n        ", "\n            "]},
{"details": ["\n    Name: maxii-evalboard", "\n    Created: Jun 14, 2005", "\n    Updated: Jun 26, 2005", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            The MAXII-Evalboard is a small and simple board for learning VHDL und testing the own VHDL-codes on a real CPLD-hardware.\r\n", "For the first steps the beginner has 4 switches and a 2 digit LED-display to create and test simple functions.\r\n", "Later the advancer can realize a small graphical display with 10x7 LED-pixel with a time multiplex control and a communication link via a USB-UART-Connection to a PC.\r\n", "To expand the MAXII-Evalboard with a additionally hardware all pins of the CPLD are routed to pin contact strip.\r\n", "The MAXII-Evalboard based on the Altera EPM570T100 CPLD and includes the JTAG-programming cable to program the CPLD via the LPT-Port.\r\n", "The board is powered by the USB-port of the PC.\r\n", "\n        ", "\n            * Altera EPM570T100 CPLD\r\n", "* 2-digit LED-matrix display\r\n", "* 4 user-switches + reset\r\n", "* Data-connection to PC via USB-UART FTDI FT232BM-chip\r\n", "* Integrated JTAG-programming cable to LPT-port\r\n", "* Wire-wrap connector to expand with additionally own hardware\r\n", "* Power-supply via USB\r\n", "* 6 MHz quarz clock\r\n", "* 1 kHz RC-oscillator\r\n", "* 2-layer PCB 83,2 x 61 mm \r\n", "\n        ", "\n            The board is in a final state V1.0 and is mostly tested\r\n", "\r\n", "Following design files are available:\r\n", "* Protel-design-files\r\n", "* Gerber-files to order PCBs\r\n", "* Schematics, PCB-Prints in PDF-format\r\n", "* Bill of materials\r\n", "\r\n", "Quartus II design-samples to test the board are coming sonn\r\n", "\n        ", "\n            FILE: MAXII-Evalboard_V1.0_a.jpg\n", "DESCRIPTION: MAXII-Evalboard with cables\n", "\n        ", "\n            FILE: MAXII-Evalboard_V1.0_b.jpg\n", "DESCRIPTION: MAXII-Evalboard\n", "\n        "]},
{"details": ["\n    Name: eus100lx", "\n    Created: Jan 23, 2006", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            EUS 100LX is an \"open\" system board conforming to the PC104 format (90,2mm x 95,9mm) designed for industrial control and data acquisition applications. It is equipped with CPU, gate array and support electronics and comes with Linux operating system version 2.4 or 2.6, driver for communication with FPGA and peripheral devices, Allegro graphics library. Example FPGA cores are available in source form, as well as full board documentation - schematics, layout (available at ", "\n        ", "\n                - ETRAX 100LX / MCM4+16 CPU\r\n", "    - 32 MB SDRAM, 8 - 64 MB Flash\r\n", "    - FPGA Spartan 3-XC3S400 - 1500, connected directly on CPU bus\r\n", "    - support for partial reconfiguration without readback\r\n", "    - dedicated independent SDRAM for FPGA - 16MB\r\n", "    - power management, watchdog, temperature and voltage sensors implemented in MSP430 microcontroller\r\n", "    - 10/100Mb Ethernet port\r\n", "    - 2 x USB 1.1 port\r\n", "    - 1 x RS232 port for ETRAX and MSP (may be extended upto 4 ports)\r\n", "    - JTAG interface for FPGA (Parallel Cable IV connector) and MSP\r\n", "    - character LCD display supported including programmable backlight and contrast control\r\n", "    - TFT LCD supported via linear framebuffer core, VGA support planned\r\n", "    - 14 LVDS pairs or 28 LVTTL IOs\r\n", "    - 90 separate input/output signals from FPGA, 5V tolerant\r\n", "    - 94 general IO from ETRAX, MSP and FPGA\r\n", "    - single power suplly voltage: 5V @ 600mA (depends on configuration and USB device consumption)\r\n", "    - port of Allegro graphics library\r\n", "    - boot over ethernet\r\n", "    - FPGA initialization and communication tools\r\n", "    - OS Linux, ftp, web, telnet\r\n", "    - all source code licensed under GPL or OHGPL\r\n", "    - royalty free application development software\n        ", "\n            - Schematic: done\r\n", "- PCB Layout: done\r\n", "- PCB Assembly & Testing: done\r\n", "- Linux 2.4: done\r\n", "- MCU Software: done\r\n", "- FPGA Boot & Communication utility: done\r\n", "- FPGA Codes adn Examples: starting - available soon\n        ", "\n            http://opencores.org/project,eus100lx,EUS100LX_BD.gif\n        ", "\n            http://opencores.org/project,eus100lx,180px-EUS_T_N.jpg (Top Side)\r\n", " (Bottom Side)\n        "]},
{"details": ["\n    Name: artec_dongle_ii_fpga", "\n    Created: Nov  4, 2008", "\n    Updated: Mar  5, 2012", "\n        SVN Updated: Mar  5, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            - LPC ROM(RAM?)\r\n", " - Flash regions Memory read, Firmware hub read, (IO read and write)\r\n", " - PSRAM regions Memory read and write, Firmware hub read, (IO read and write)\r\n", "- SPI ROM\r\n", " - Flash regions read\r\n", " - PSRAM regions read\r\n", "- 8 bit ROM\r\n", " - read (with standard CS, OE, WE, DATA, ADDR interface on the 32 extension pins)\r\n", "- Post code trace\r\n", "- Boot trace (list all memory cycles possible at least on LPC)\r\n", "- Simple Logic Analyzer with 32 pins and 32 pin GPIO python module support\r\n", "- VHDL Firmware update trough USB data cable\r\n", "\n        ", "\n            FILE: Dongle_II_board_small.JPG\n", "DESCRIPTION: board image\n", "\n        ", "\n            DONE\r\n", "\r\n", "- code transfer from Dongle I\r\n", "- PSRAM support added to memory interface and USB interface (4MB write time is 4 sec under Linux read is 10 sec)\r\n", "- New jumper block with LED indicators\r\n", "- dongle.py updated for initial features\r\n", "- dev_present signal switching from PC by default is low (has strong pull down 330 ohm for backward compatibility)\r\n", "- removed the need for reset after programming to free memory bus lock (lock is now controlled by the dongle.py software) \r\n", "- Added UART 16550 support over LPC with selectable base addresses\r\n", "\r\n", "TODO\r\n", "\r\n", "- Write multi-clock domain scalable memory bus arbiter (firmware)\r\n", "- SPI boot support (firmware)\r\n", "- 8 bit parallel ROM support code (firmware)\r\n", "- write GPIO support (firmware) and supporting Python module (software)\r\n", "- boot trace feature (save all accessed addresses and data and send to PC) (firmware)\r\n", "- write new update.py to work trough FTDI D2xx bit bang feature (software)\r\n", "- write 16 bit to 8 bit FIFO bridge to further speed up USB transfer on PSRAM regions (firmware)\r\n", "- try to rewrite Uspp read() in linux implementation to support more than word read at a time from OS (software)\r\n", "- write EPROM support code (firmware)\r\n", "- write software jumper support with settings stored/restored from EPROM (firmware)\r\n", "- write or port Analyzer code (firmware) \n        ", "\n            Project to create generic emulator/debugger/analyzer with\r\n", "on-the-fly reprogrammable firmware on Artec Dongle II board (containing Altera Cyclone III, Flash 16MB, PSRAM 16MB (UltraCap for image retention), FTDI usb, 32 GPIO pins, 4 segment LED, 8 green LEDs, 1 green/red LED, 8 pins for LPC/SPI bus, 6 pin extension header, EPROM 1024 bytes).\n        "]},
{"details": ["\n    Name: kiss-board", "\n    Created: May 28, 2006", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: Yes", "\n    WishBone version: n/a", "\n    License: \n", "\n            ", "\n            ", "\n            ", "\n            ", "\n            ", "\n            ", "\n            ", "\n            "]},
{"details": ["\n    Name: iiepci", "\n    Created: Jul  1, 2005", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The IIE-PCI Development Platform board is a low cost PCI device card with a programmable logic chip (Altera ACEX), dynamic ram, and expansion capabilities.\r\n", "\r\n", "The main purpose of the IIE-PCI board is to test PCI designs in a educational environment. Cost was a primary concern. The fabrication cost for the prototype board was U$S 330, if 10 boards are made, the cost will drop to U$S 230 per unit.\r\n", "\r\n", "More information is available at the project website:\r\n", " - ", " (mondueri.com/iiepci) (original site in spanish)\r\n", " - ", " (english version) (google autotranslation)\r\n", "\r\n", "The IIE-PCI Development Platform is part of a final degree project in Electrical Engineering in the Universidad del la Rep\u00fablica - Facultad de Ingenier\u00eda - Uruguay.\r\n", "The whole project contains the following parts:\r\n", " - IEE-PCI board.\r\n", " - Target PCI Core toolkit (written in VHDL).\r\n", " - Linux device driver toolkit for the core and the device card.\r\n", "\n        ", "\n             - PCI 32 bit, 3.3V and 5V compatible\r\n", " - 128Mbit SDRAM memory on-board\r\n", " - ALTERA FPGA ACEX EP1K100PQ208\r\n", " - Expansion header\r\n", " - 31 general propouse signals\r\n", " - Clock source: on-board crystal, PCI conector. Jumper selectable.\r\n", " - PLL for clock regeneration and frequency multiplication. Jumper selectable.\r\n", " - FPGA configuration using (jumper selectable):\r\n", "   - on-board ALTERA EPC2 EPROM\r\n", "   - JTAG header through ALTERA ByteBlasterMV\r\n", " - External power connector\n        ", "\n             - two prototype assembled and fully functional\r\n", " - boards are being used at under-graduate ", " (courses) in our University.\r\n", " - schematics, gerber, bill of materials available at ", " (Downloads) section\r\n", " - documentation, user manual and other information available at ", " (Links) section\r\n", "\n        ", "\n             - Sebasti\u00e1n Fern\u00e1ndez | sebfer at opencores.org\r\n", " - Ciro Mondueri | ciro at opencores.org\n        ", "\n            FILE: iie_pci_front.jpg\n", "DESCRIPTION: IIE-PCI board (front)\n", "\n        ", "\n            FILE: iie_pci_back.jpg\n", "DESCRIPTION: IIE-PCI board (back)\n", "\n        ", "\n            FILE: iie_pci_diagram.jpg\n", "DESCRIPTION: IIE-PCI board (diagram)\n", "\n        "]},
{"details": ["\n    Name: eusfs", "\n    Created: Apr 28, 2008", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            EUS FS is an \"open\" system board designed for industrial control and data acquisition applications. It is equipped with a 32-bit CPU working @ 200MHz (Etrax FS), Xilinx's gate array (Spartan 3E) and support electronics. A BSP package contains Linux operating system version 2.6, driver for communication with FPGA and peripheral devices. Example FPGA cores are available in source form, along with full board documentation and schematics.\r\n", "  ", "  \r\n\r\n", "\r\n\r\n", "\n        ", "\n            \r\n- Board dimensions 85 x 55 mm (3.35 x 2.175\" )", "\r\n- 200MHz, 32bit Etrax FS processor", "\r\n- Up to 256MB SDRAM", "\r\n- 8 - 64 MB Flash", "\r\n- FPGA Spartan 3E - XC3S500-1600E connected directly on the CPU bus", "\r\n- Up to 64MB dedicated independent DDR SDRAM", "\r\n- Temperature, voltage and current consumption sensors implemented in MSP430 microcontroller", "\r\n- Unique board serial number", "\r\n- 10/100Mb Ethernet port", "\r\n- 1 x USB port", "\r\n- 1 x RS232 port (could be extended up to 4 ports)", "\r\n- JTAG interface for FPGA (Parallel Cable IV connector)", "\r\n- 91 separate input/output signals from FPGA", "\r\n- IO processor, peripheral or 72 general IOs from ETRAX processor", "\r\n- Single power supply voltage: 5V @ 700mA (depends on configuration and USB device consumption)", "\r\n- Boot over Ethernet", "\r\n- Opensource bootloader", "\r\n- FPGA initialization and communication tools", "\r\n- OS Linux 2.6, ftp, web server, telnet", "\r\n- All source code licensed under GPL or OHGPL", "\r\n- Three basic configurations:", "\r\n- Full system: Etrax FS + FPGA", "\r\n- Only Etrax processor", "\r\n- Only FPGA with Microblaze support", "\r\n- Evaluation Board is available", "\r\n- Board dimensions 160 x 100 mm (6.3 x 3.94\") - Eurocard compatible", "\r\n- 2 x IO connector 96 pin, DIN41612 Class 3 compatible, IO signals +5V compatible and protected", "\r\n- 1 x 10/100Mb Ethernet connector", "\r\n- 2 x RS232 Serial connectors", "\r\n- 2 x JTAG interface for FPGA and ETRAX FS (Paralel Cable IV connector)", "\r\n- 1 x JTAG interface for MCU MSP430", "\r\n- 1 x VGA analog video connector", "\r\n- 1 x USB host connector and 1 x USB peripheral connector", "\r\n- 1F high capacitance for RTC back-up", "\r\n- 8kB FRAM I2C memory", "\r\n- Keyboard with 5 buttons inclusive with LEDs + Reset button", "\r\n- Single power supply voltage 5V, socket for EIAJ standard power plug", "\r\n- SW Tool chain available", "\r\n", "\r\n\r\n\r\n", "\n        ", "\n            - Schematic: done\r\n", "- PCB Layout: done\r\n", "- PCB Assembly & Testing: done\r\n", "- U boot loader: done\r\n", "- Linux 2.6 kernel: done\r\n", "- PTXDist tool chain: done \r\n", "- FPGA Boot & Communication utility: done\r\n", "- FPGA Codes adn Examples: available\n        ", "\n            ", " ", "\r\n", "\r\n", "\n        ", "\n            ", " ", "\r\n", " ", "\r\n", " ", "\r\n", " ", "\r\n", " ", "\r\n", " ", "\n        "]},
{"details": ["\n    Name: butterflylight", "\n    Created: Oct 22, 2009", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Oct 22, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: Others\n", "\n            ", "The ", " is an open source, modular FPGA development board. It is comprised of the ", " and the ", " which paired together create the Butterfly Light FPGA development board. The Butterfly Light is best suited for developers who prefer to create their own daughterboards instead of utilizing the \"", "\" peripheral system. The Butterfly Light exposes the maximum amount of I/O of all available Butterflies. It is also well suited for use with the ", " software which implements a 100Mhz, 32 channel ", ".", " The Butterfly Platform USB Cocoon and S3E Cocoon are released under the Creative Commons Attribution license. The goal is to support commercial and noncommercial scenarios such as the following:", " ", "\r\nThis work is licensed under a ", ".", " "]},
{"details": ["\n    Name: griva", "\n    Created: Feb 14, 2011", "\n    Updated: Feb 26, 2011", "\n        SVN Updated: Feb 26, 2011", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            "]},
{"details": ["\n    Name: aes220", "\n    Created: Aug  1, 2013", "\n    Updated: Feb 23, 2014", "\n        SVN: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The aes220 is a High-Speed USB 2.0 FPGA based on the Cypress FX2 micro-controller and Xilinx Spartan3AN (XC3S200AN or XC3S400AN) FPGA. The 'N' denomination of the Spartan device means it includes 4Mb of flash memory to retain 2 configuration bit streams or user data. The board also offers 16MB of SDRAM and 72 GPIOs. Power is provided by the USB cable or by an external 5V supply. The mini-module is only 42x61mm making it way smaller than a credit card.\r\n", "\r\n", "The device is programmed through the USB port and does not require any external programmer, although a JTAG port is available. Once programmed communication with the FPGA happens through the USB port and is rendered easy thanks to the open-source libraries provided in C/C++ and C# on the PC side and in VHDL on the FPGA side. The API works on Windows and Linux platforms (including the Beaglebone Black) and does not require any prior knowledge of USB communication. Source code is available in the git repository (see link below). The board is also compatible with the FPGALink library.\n        ", "\n            \r\n", "\n            ", "\r\n", " aes220 High-Speed USB FPGA mini-module shown here on top of a credit card\r\n", " \r\n", " \r\n", "\r\n", " aes220 with aes2200 ADC/DAC daughter board\n        ", "\n            ", "\n            "]},
{"details": ["\n    Name: hcsa_adder", "\n    Created: Apr  7, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Hierarchical Carry Save Algorithm (HCSA) is a modification of well known adder algorithm. Comes as VHDL IP core, shows good timing and small area requirements. \r\nThe Generic HCSA ALU VHDL IP Core presents an example of HCSA methodology.\r\n\r\nHCSA adder and ALU with HCSA implemented as VHDL soft IP cores. Algorithm implemetation bases on recursion method.\r\n\r\nBasic Idea: Every Bit of the Result is calculated twice simultaneously :\r\n\r\n   1. As if there IS NO carry from LSB ( less significant bit )\r\n      ", "\r\n   2. As if these IS a carry from LSB\r\n      ", " \r\n\r\nReal Carry ", "  used as a Selector for these intermediate sums and precalculated Carry for the next stage (which ones to output). The iteration applies for every bit of the sum. Generic ALU implemented on HCSA method has very good performance/area characteristics due to all Athithmetic operations are made within HCSA module. Logic operations and Command decoder are light weight modules. \n        ", "\n            - small area requirements for HCSA Adder  - 1965 cells ( conditions:   128 bit operands, 0.35u Std Cell Library, typical conditions) \r\n", "- good performance 6.64ns ( same conditions ).\r\n", "- flexibility and reusability ( written completely in VHDL,  no hardcoded macros used )\r\n        ", "\n            This core is provided by ASIC reseach department members of DeverSYS Corp., Visit this ", ". There are more usefull fundamental (and not only) ", " IP Cores at ", ".\n        "]},
{"details": ["\n    Name: hierarch_unit", "\n    Created: Jul 10, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            ", "\r\nThis is a brief overview of  the article about the series of multiplication algorithms. For comparison and estimation of proposed algorithms please refer to the full article... ", "\r\n\r\n", "\r\nOperation of multiplication is very important in microelectronics. Each modern microprocessor has this operation within its instruction set, and advanced microprocessors have special multiplication units, that perform multiplication during 1 synchronization period(cycle). Especially valuable multiplication is in DSP processors, where it is practically main operation. Performance of any DSP processor is defined with delays in it MAC (multiply and accumulate) unit. So efficiency of multiplication is very important.\r\n\r\n", "\r\n", "\r\nThe idea of algorithms is as follows. Unsigned multiplicands A and D may be represented in following form: A*D = (B * 2", " + \u00f3) * (E * 2", "  + F), where n \u2013 any number that is satisfied with following conditions:\r\n", "\r\n", "\r\nAs it follows from theory of algorithms maximum of timing efficiency should be expected when dimensions of operands B, C, E and F (see basic formula) are equal at every algorithm call, i.e. n=m/2. In this case number of recursions will be minimal and number of sums that take part in final result also will be minimal.\r\n\r\n", "\r\n", "\r\nThis algorithm is an attempt to improve \u201chierarchical\u201d algorithm for long-dimensional operands by substitution of one multiplication with some of addition operations. But for dimensions commonly used (8 - 64 bit) the result was not as expected.  Algorithm advantages supposed to appear on m \u2192 [128..\u221e) where possibly the algorithm may be preferable than the prototype. \r\n        ", "\n            ", "\r\nThe algorithm was written in VHDL, synthesized within Synopsys Design Compiler on 0.35u CMOS library. The data of the allocation areas are given only for a combinational part of algorithm.", "\r\n", "\r\n", "\r\nThe algorithm was written in VHDL, synthesized within Synopsys Design Compiler on 0.35u CMOS library. The data of the allocation areas are given only for a combinational part of algorithms.", "\r\n", "\n            These cores are developed and provided by ASIC reseach department member of DeverSYS Corp., Vladimir V.Erokhin. More usefull fundamental (and not only) ", " IP Cores can be found at DeverSYS web ", ".\n        "]},
{"details": ["\n    Name: acxbrd", "\n    Created: Sep 11, 2004", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            This is a small board with the low-cost ACEX FPGA with some SRAM and Flash. It is designed as a module for soft-core CPU development. I've used this board as basis for JOP - the Java processor. JOP still fits into the ACEX 1K50.\r\n", "\r\n", "See some pictures of the board at: ", "\r\n", "\r\n", "The schematic and the PCB layout is provided under GPL.\n        ", "\n            - Altera ACEX 1K50TC144-3 FPGA\r\n", "- Voltage regulators (3V3, 2V5)\r\n", "- Crystal clock (20 MHz)\r\n", "- 512KB Flash (for FPGA configuration and program)\r\n", "- 128KB Ram\r\n", "- Byteblaster port\r\n", "- Watchdog with LED\r\n", "- EPM7032 PLD to load FPGA from flash (on watchdog reset)\r\n", "- Serial interface (MAX323A)\r\n", "- 56 general IO pins\n        ", "\n            - Board is final\r\n", "- Used in several projects\r\n", "- Single page schematic can be used with the free version of Eagle: ", "\n        ", "\n            FILE: jopcore.pdf\r\n", "DESCRIPTION: Schematic\r\n", "- abc\r\n", "\n        "]},
{"details": ["\n    Name: 802154crc", "\n    Created: Mar  6, 2013", "\n    Updated: Apr 16, 2013", "\n        SVN Updated: Apr 16, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            \n        ", "\n            \n        "]},
{"details": ["\n    Name: divider", "\n    Created: Oct 28, 2002", "\n    Updated: Sep 28, 2011", "\n        SVN Updated: May  5, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a collection of synthesizeable hardware dividers. Different types of dividers are available. All dividers are fully pipelined and provide a 2N by N division every clock cycle. All designs are fully parameteriseable and synthesizeable.\r\n", "The dividers take two inputs Z(2N-bit divident) and D(N-bit divisor), and return Q(N-bit quotient), S(N-bit remainder), div0(division by zero), and ovf(overflow).\r\n", "A sample implementation of a 32/16 bit divider with a remainder output runs at about 82MHz in a Spartan2e100 -6 device and occupies 1132 LUTs (about 47%) and 1736 registers (about 72%) of the device.\n        ", "\n            - Fully synthesiseable\r\n", "- Fully parameteriseable\r\n", "- Pipelined design (one pipeline stage per bit) provides a result every clock cycle.\r\n", "- Includes testbench\n        ", "\n            The following division units are ready and available for download:\r\n", "- Non-restoring unsigned by unsiged divider\r\n", "- Non-restoring signed by unsiged divider\r\n        "]},
{"details": ["\n    Name: dpll-isdn", "\n    Created: Mar 30, 2011", "\n    Updated: Feb 18, 2013", "\n        SVN Updated: Jun  2, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            1.\tYamamoto H., Mori S. Performance of a binary quantized all digital phase-locked loop with a new class of sequential filter//IEEE Trans. \u2013 1978. \u2013 V. Com-26, \u21161. \u2013 P. 35-45.\r\n", "\r\n", "2.\tCessna J.R., Levy D.M. Phase noise and transient times for a binary quantized digital phase-locked loop in which Gaussian noise//IEEE Trans. \u2013 1972. \u2013 V. Com-20, \u21162. \u2013 P. 94-104.\r\n", "\r\n", "3.\tYukawa J., Mori S. A binary quantized digital phase-locked loop//IECE. \u2013 1973. \u2013 Vol. 56-A, \u211612. \u2013 P. 79-85.\n        "]},
{"details": ["\n    Name: galois_lfsr", "\n    Created: Aug  9, 2013", "\n    Updated: Dec  1, 2015", "\n        SVN Updated: Mar  4, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", "This project implements the Galois Linear-feedback Shift Register (LFSR) in VHDL, and can be used for applications such as PRBS generation & synchronisation, CRC computations, scrambling & descrambling, cryptography, etc. This design is very generic / parameterisable, in the sense that it is intelligent enough to be able to \"create\" (or generate) the LFSR structure based on user input (a VHDL generic). In the ", " entity (galois-lfsr.vhdl), there is a generic named ", ", which allows you to input a vector of tap locations for the LFSR.\r\n", "For example, to create an LFSR with a polynomial of x^8 + x^2 + x + 1, all you have to do is specify a tap vector of ", ", i.e. register outputs 0, 1, 2, and 8 are tapped. After specifying the tap vector with the correct tap locations, simply map the vector to the LFSR instance, as follows:\r\n", "Note that the design assumes the largest tap location is fed back to all the previous taps, by means of connecting to the inputs of each XOR gate of previous taps.\r\n", "To simulate the design with Mentor Graphics Questa/ModelSim, simply ", " into the ", " folder, and execute ", " from the Unix prompt:", "\r\n", "\r\n", "If you have ModelSim/QuestaSim installed, the GUI will appear immediately after you run the script.\r\n", "Currently, we provide only the simulation script for Linux/Unix. Contact us if you need help with simulating this project on Windows, and we will send you separate instructions.\r\n", "If you are using any other simulator, do let us know how this core works with your tool. One of the goals of this project is to make this core as vendor independent as possible.\r\n", "This design synthesises in Quartus. In the coming weeks, we will be verifying this core on hardware. We also have plans to verify on Xilinx FPGAs. Stay tuned for updates.\r\n", "\r\nNote that although you set the VHDL-2008 option in Quartus, it ", ". So we need to add these definitions for synthesis. You can find them in a separate file (packages/pkg-types.vhdl):\r\n", "These VHDL-2008 additions are very useful, so request your tool vendor for this support, if they haven't already.", "For comments or feedback relating to this core, or if you wish to contribute to this project in any way, feel free to drop us an email (given below).\r\n", "\n            [29-Jul-2013]: Design completed.\r\n", "[8-Aug-2013]: Basic functional simulations completed; synthesis done (Quartus).\n        ", "\n            - More comprehensive testbench.\r\n", "- Make the design Wishbone-compliant.\r\n", "- Documentation.\n        ", "\n            We offer training, design services, and consultancy in VHDL-based FPGA / ASIC designs.\r\n", "\r\n", "Tauhop Solutions - Penang, Malaysia\r\n", "site: ", "\r\n", "email: info@tauhop.com\r\n", "tel.: +60-16-333-0498 (daniel)\n        "]},
{"details": ["\n    Name: gng", "\n    Created: Aug  7, 2014", "\n    Updated: Feb  1, 2015", "\n        SVN Updated: Jan 29, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Gaussian Noise Generator core generates white Gaussian noise of standard normal distribution, which can be used to measure BER to extremely low BER levels (~10-15). The core uses a 64-bit combined Tausworthe generator and an approximation of the inverse normal cumulative distribution function, which obtains a PDF that is Gaussian to up to 9.1\u03c3.\r\n", "The core was designed using synthesizable Verilog code and can be delivered as a soft-IP targeted for any FPGA device and ASIC technology. C/MATLAB models and corresponding test benches are also available.\n        ", "\n            - Period of generated noise sequence is about 2^176\r\n", "- Random distribution in the range of \u00b19.1\u03c3\r\n", "- Noise is quantized to 16 bits with 5 bits of integer and11 bits of fraction\r\n", "- Internal 64-bit uniform random number generator with configurable initial seeds\r\n", "- Based on a piecewise polynomial approximation of the inverse normal cumulative distribution function\r\n", "- High throughput, over 300 MHz clock rate and output sample rate in advanced FPGA\r\n", "- Fully synchronous design using single clock\r\n", "- Design optimized for Xilinx & Altera FPGA technology\r\n", "\n        ", "\n            - Communication system requiring accurate emulation of an AWGN channel\r\n", "- Bit error rate measurement system\r\n", "\n        ", "\n            Xilinx\r\n", "- Device:                       Virtex-6 XC6VLX240T-2ff1156\r\n", "- Number of occupied Slices:    97\r\n", "- Number of RAMB36E1:\t       1\r\n", "- Number of DSP48E1s:\t       2\r\n", "- Maximum frequency:\t       311.8 MHz\r\n", "\r\n", "Altera\r\n", "- Device:                       Stratix IV GX EP4SGX230KF40C3\r\n", "- Total LABs:                   34\r\n", "- M9K blocks:                   2\r\n", "- DSP block 18-bit elements:    4\r\n", "- Maximum frequency:            376.8 MHz\r\n", "\n        "]},
{"details": ["\n    Name: fp_log", "\n    Created: Jan  5, 2010", "\n    Updated: Dec 21, 2010", "\n        SVN Updated: Dec 21, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            VHDL implementation of a fast space- and resource-efficient logarithm approximation unit for FPGAs.\r\n", "The unit is an implementation of the ICSILog algorithm.\n        "]},
{"details": ["\n    Name: fpuvhdl", "\n    Created: Jun 18, 2004", "\n    Updated: Feb 22, 2012", "\n        SVN Updated: Jun 21, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This Floating Point units were developed as part of the HAVOC project. The Design schematics and related files can be browsed at the FPU repository, or downloaded as a separate file from the FP units home page.\r\n", "\r\n", "The FP Adder is a single-precision, IEEE-754 compilant, signed adder/substractor. It includes both single-cycle and 6-stage pipelined designs. The design is fully synthesizable and has been tested in a Xilinx Virtex-II XC2V3000 FPGA, occupying 385 CLBs and with a theoretical maximum operating frecuency of 6MHz for the single-cycle  design and 87MHz for the pipelined design. The design was tested at 33MHz.\r\n", "\r\n", "The FP Multiplier is a single-precision, IEEE-754 compilant, signed multiplier. It includes both single-cycle and 4-stage pipelined designs. The design is fully synthesizable and has been tested in a Xilinx Virtex-II XC2V3000 FPGA, occupying 119 CLBs and with a theoretical maximum operating frecuency of 8MHz for the single-cycle  design and 90MHz for the pipelined design. The design was tested at 33MHz.\n        ", "\n            - IEEE-754 compilant\r\n", "- 32 bits, single precision\r\n", "- Works with normalized and unnormalized numbers\r\n", "- Simple block design, good for FP arithmetic learning\r\n", "- Adder\r\n", "  - 385 CLBs\r\n", "  - 87 MHz, 6-stage pipelined\r\n", "- Multiplier\r\n", "  - 119 CLBs\r\n", "  - 90 MHz, 4-stage pipelined\r\n", "\r\n", "\n        ", "\n            - Initial Release made available in June, 2004. Uploaded in November 2004.\r\n", "- Updated in July 2006. Removed references to the HAVOC library, now using the default work. Corrected bug handling the underflow in the multiplier (thanks to H. Sakman for reporting the bug).\r\n", "- Updated in June 2010. Fixed a bug in the normalization when the add of two normal numbers produced a denormal, they where not properly represented. Many thanks to Math Verstraelen for reporting this bug.\n        ", "\n            http://speech.mty.itesm.mx/~gmarcus/FPU/FPU.html\n        "]},
{"details": ["\n    Name: fpga-median", "\n    Created: Mar 18, 2014", "\n    Updated: Mar 21, 2014", "\n        SVN Updated: Mar 21, 2014", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This implementation project proposes a practical implementation of a Median Filter architecture focused in low-cost FPGA devices. The architecture is based on the research presented in the following paper: ", "\r\n", "\r\n", "Sorry, but we do not have time to develop a proper architecture document. However the paper presents a brief and at the same time complete description for this implementation design.\n        "]},
{"details": ["\n    Name: fpu100", "\n    Created: Jan 28, 2006", "\n    Updated: Jun 14, 2017", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 7 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            This is a 32-bit floating point unit (FPU), which I developed in a project within the Vienna University of Technology. It can do arithmetic operations on floating point numbers. The FPU complies fully with the IEEE 754 Standard. The FPU was tested and simulated in hardware and software.\n        ", "\n            - FPU supports the following arithmetic operations:\r\n", " -\tAdd\r\n", " -\tSubtract\r\n", " -\tMultiply\r\n", " -\tDivide\r\n", " -\tSquare Root\r\n", "\r\n", "- For each operation the following rounding modes are supported:\r\n", " -\tRound to nearest even\r\n", " -\tRound to zero\r\n", " -\tRound up\r\n", " -\tRound down\r\n", "\r\n", "- Pipelined to achieve high operating frequency (100MHz with Cyclone EP1C6)\r\n", "\r\n", "- Tested with 2 million test cases\r\n", "\r\n", "- Hardware proven: FPU was implemented in a Cyclone I\u2013EP1C6 FPGA chip and was then connected to the Java processor JOP(", " (jopdesign.com)) to do some floating-point calculations.\r\n", "\r\n", "\r\n", "For more details please read the documentation. If that doesn't help, then post your question here:  ", "\n        ", "\n            - 30-Jan-2006: Uploaded project (files will be imported into CVS very soon)\r\n", "- 02-Mar-2006: Added CVS files\r\n", "- 28-Mar-2006: Tested the FPU with 2 million test cases and corrected two bugs. [fpu_v14]\r\n", "- 28-Mai-2006: 1)Intializing bug fixed in testbench; 2)Extended 1 clock cycle more  for multiplication, becasue of an Intializing issue.[fpu_v15]\r\n", "- 14-Jun-2006: 1)Corrected a syntax error in \"tb_fpu.vhd\": start_i - 16-Jul-2006: 1)Corrected bug related to adding two denormalized operands.[fpu_v17]\r\n", "- 22-Jul-2006: 1)post_norm_addsub.vhd: Restructured and fixed a bug; 2)fpu.vhd: Altered add/sub COUNT; 3)tb_fpu.vhd: Added some boundary values. [fpu_v18]\r\n", "- 26-Apr-2007: 1)A minor bug was found and corrected when the serial multiplier is used (thanks to Chris Basson!). [fpu_v19]\n        ", "\n            You can use this code academically, commercially, etc. for free; just acknowledge the author.\n        "]},
{"details": ["\n    Name: fixed_point_arithmetic_parameterized", "\n    Created: Aug 25, 2011", "\n    Updated: Jan 23, 2018", "\n        SVN Updated: Apr 10, 2013", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This project was started in order to create fixed point (Q format) arithmetic modules in verilog.\r\n", "\r\n", "What was created was a parameterized (specify size (N) and number of fractional bits (Q)) implementation to make configuring for different projects simple.\r\n", "\r\n", "This implementation uses the following data structure:\r\n", "\r\n", "| sign (0+/1-) | whole number | fractional bits |\r\n", "| ____1 bit___ | _N-Q-1 bits_ | _____Q bits____ |\r\n", "\r\n", "The following modules were created:\r\n", "-Twos Complement\r\n", "-Addition (Combinational)\r\n", "-Multiplication (Combinational using standard * operator)\r\n", "-Division (Clocked, standard binary division)\r\n", "\r\n", "Each of these modules is accompanied by a testfixture, and each has been tested for minimal functionality\r\n", "\r\n", "NOTE: Division's testfixture (qdiv_tf.v) contains 2 tasks that convert between verilog real and fixed point representations (including checking for numbers too big to represent and loss of precision).\n        ", "\n            The source files in the SVN have been separated into three groups:\r\n", "\r\n", "- src: containing the verilog sources files {qadd.v,qmult.v,qdiv.v,qtwosComp.v}. These are the parameterized verilog modules implementing the fixed point arithmetic\r\n", "\r\n", "- testfixtures: containing the three testfixtures for each of the arithmetic operations (add,mult,div). These testfixtures show how data is being entered into the data structure from real life (giving understanding to the user in how to implement in their own projects).\r\n", "\r\n", "- implementation: containing a sample 'top' module that implements the arithmetic operations in a Q23/32bit scenario\r\n", "\r\n", "\n        "]},
{"details": ["\n    Name: ecg", "\n    Created: Feb 12, 2012", "\n    Updated: Apr 18, 2012", "\n        SVN Updated: Mar  4, 2012", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            The Elliptic Curve Group core is for computing the addition of two elements in the elliptic curve group, and the addition of $c$ identical elements in the elliptic curve group. \r\n", "\r\n", "The elliptic curve is super-singular $E:y^2=x^3-x+1$ in affine coordinates defined over a Galois field $GF(3^m)$, $m=97$, whose irreducible polynomial is $x^97+x^12+2$.\r\n", " \r\n", "The elliptic curve group is the set of solutions $(x,y)$ over $GF(3^m)$ to the equation of $E$, together with an additional point at infinity, denoted $O$. An element in the elliptic curve group is also called \u201ca point\u201d. The elliptic curve group is abelian. The group law is described in the document/specification. \r\n", "\r\n", "The Elliptic Curve Group core consists of two modules, one computing the addition of two elliptic curve group elements ($P_1+P_2$) and the other computing the addition of many identical elliptic curve group elements ($c\u22c5P_1$). The first module is called $point_add$. The second module is called $point_scalar_mult$.\r\n", "\r\n", "The core is written in Verilog 2001, and it is carefully optimized for FPGA. For example, input signals are synchronous and sampled at the rising edge of the clock. Output signals are driven by flip-flops, and not directly connected to input signals by combinational logic. There is no latch, and only one clock domain in entire core. \r\n", "\r\n", "The $point_add$ module runs at 192 MHz on the Xilinx Virtex-4 XC4VLX200-11FF1513 FPGA board. It computes one addition within 2.7 microseconds if with a 100MHz clock. The $point_add$ module uses 12,099 (6%) LUTs, 6,694 (7%) slices, 6,141 (3%) flip-flops of the XC4VLX200-11FF1513 FPGA board. \r\n", "\r\n", "The $point_scalar_mult$ module runs at 148 MHz on the Xilinx Virtex-4 XC4VLX200-11FF1513 FPGA board. It computes one addition within 0.552 milliseconds if with a 100MHz clock. The $point_scalar_mult$ module uses 13,780 (7%) LUTs, 7,272 (8%) slices, 7,451 (4%) flip-flops of the XC4VLX200-11FF1513 FPGA board. \r\n", "\r\n", "The core is open source, under the license of LGPL version 3.\n        ", "\n            ", "\n        ", "\n            - Elliptic Curve Group for hyper-elliptic curve $y^2=x^3-x+1$ \r\n", "- The irreducible polynomial is $x^97+x^12+2$ \r\n", "- Fully synchronous design \r\n", "- Fully synthesize-able \r\n", "- ONLY ONE clock domain in entire core \r\n", "- NO latch \r\n", "- All output signals are buffered \r\n", "- Vendor independent code\n        ", "\n            - The core is ready and available in Verilog from OpenCores svn \n        ", "\n            - using projective coordinates may improve speed\r\n", "- adopting base-3 scalar multiplication value may improve speed, requiring base-2 to base-3 transforming function, and point tripling function\n        ", "\n            If this project has helped you, ", " (Xilinx FPGA is preferred). To donate him will help him develop more valuable project, and is to help you.\n        "]},
{"details": ["\n    Name: quadratic_func", "\n    Created: Feb 16, 2009", "\n    Updated: Jul 26, 2011", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            Quadratic_func is a fully pipelined quadratic polynomial that computes the relation y = ax^2 + bx + c.  On each rising-edge of the clock (when en is high), the coefficients and input x term are sampled at the function inputs. The result has a latency of 3 clock cycles.  All inputs to the function are 8-bit signed fractions, with the generic parameter 'fw' specifying the number of fraction bits.  The output result is a 24-bit signed fraction.  If integer arithmetic is preferred, then the parameter fw should be set to 0.  For larger bit-widths, the design can easily be scaled up to suit the application.\r\n\r\n", "\n            - Computes the relation y = ax^2 + bx + c\r\n", "- Signed 8-bit fixed-point input\r\n", "- Signed 8-bit fixed-point coefficients\r\n", "- Signed 24-bit fixed-point output\r\n", "- Configurable number of fraction bits\r\n", "- Dynamic coefficients updated every clock cycle\r\n", "- No internal loss of precision (no rounding or truncation)\r\n", "- Fully pipelined architecture\r\n", "- Result has a 3 clock-cycle latency\n        ", "\n            - Fully tested and complete\r\n", "- Future versions to support generic input data and coefficient widths as well as fraction width\n        ", "\n            Simon Doherty is a Senior Design Consultant at ", " If you require further assistance regarding the implementation of this core, you may contact me directly via my Opencores email alias at sdoherty@opencores.org. Alternatively you may contact me through customer support at ZIPcores.\r\n", "\n        "]},
{"details": ["\n    Name: mdct", "\n    Created: Apr 14, 2006", "\n    Updated: Apr  9, 2017", "\n        SVN Updated: Mar 17, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 2 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            NEW: 12 bit input MDCT version created by Emrah Yuce has been added to project downloads.\r\n", "\r\n", "\r\n", "Parallel synthesizable implementation of 2D DCT in VHDL. Currently works on 8 bit input data using 12 bit DCT coefficients (12-bit DCT output). Multiplier-less design, parallel distributed arithmetic with butterfly computation used instead. Implementation done as row-column decomposition, two 1D DCT units and transpose matrix between them (double buffered as ping-pong buffer for performance). Latency (time between first 8 bit input data is sampled and first dct data present on output) is 94 clock cycles. \r\n", "\r\n", "Self-veryfing testbench included which takes matlab-converted image as input. Core transforms it to DCT coefficients and behavioral IDCT testbench code reconstructs from it original image. PSNR is computed between original and reconstructed image to find out error introduced by fixed point arithmetic, for sample Lena images PSNR is 48 dB.\r\n", "\r\n", "Matlab scripts are included for computing floating point DCT/IDCT as reference. Scripts for converting 8 bit bitmap to txt format readable by testbench and vice versa are also available.\r\n", "\r\n", "Core was tested on Digilent S3 board with Spartan Xc3S1000 FPGA.\r\n", "\r\n", "\n        ", "\n            \r\n", "+ 8 bit input, 11 bit output\r\n", "+ Throughput 10 MSamples/s with 10 MHz input clock\r\n", "+ Latency 94 clock cycles\r\n", "+ Transforms 8x8 block of 64 samples in 64 cycles when pipeline is full\r\n", "+ FPGA proven\n        ", "\n            FILE: block_diagram.jpg\n", "DESCRIPTION: MDCT block diagram\n", "\n        ", "\n            \n        "]},
{"details": ["\n    Name: cordic", "\n    Created: Sep 25, 2001", "\n    Updated: Jan  8, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            The CORDIC algorithm is an iterative algorithm to evaluate many mathematical functions, such as trigonometrically functions, hyperbolic functions and planar rotations.\r\n", "\r\n        ", "\n            As the name suggests the CORDIC algorithm was developed for rotating coordinates, a piece of hardware for doing real-time navigational computations in the 1950's. The CORDIC uses a sequence like successive approximation to reach its results. The nice part is it does this by adding/subtracting and shifting only.\r\n\r\nSuppose we want to rotate a point(X,Y) by an angle(Z). The coordinates for the new point(Xnew, Ynew) are:\r\n", "\n            See the on-line documentation for the theory behind and information about the available CORDIC cores.\n        ", "\n            - Design is available in VHDL from OpenCores CVS via cvsweb or via cvsget \r\n", "- ToDo: finish documentation\n        "]},
{"details": ["\n    Name: cf_fp_mul", "\n    Created: Mar 13, 2003", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\n        ", "\n            The floating point representation follows the IEEE-754 bit format:\r\n", "\r\n", "{SignBit, Exponent, Mantissa}\r\n", "\r\n", "Each file is stand-alone and represents a specific configuration.\r\n", "The 3 configuration parameters are:\r\n", "- Combinatorial or Pipelined ('c' or 'p')\r\n", "- Exponent Precision\r\n", "- Mantissa Precision\r\n", "\r\n", "Note the total width = 1 + Exponent Precision + Mantissa Precision.\r\n", "For pipeline configurations, pipeline latency is 4 + Mantissa Precision.\r\n", "\r\n", "The configuration parameters are coded in the file name.\r\n", "For example, cf_fp_mul_p_11_52 has the following configuration:\r\n", "- Pipelined\r\n", "- 11-Bit Exponent\r\n", "- 52-Bit Mantissa\r\n", "\r\n", "Current configurations:\r\n", "- cf_fp_mul_c_3_4\r\n", "- cf_fp_mul_p_3_4\r\n", "- cf_fp_mul_c_5_10\r\n", "- cf_fp_mul_p_5_10\r\n", "- cf_fp_mul_c_8_23  (IEEE-754 Single)\r\n", "- cf_fp_mul_p_8_23  (IEEE-754 Single)\r\n", "- cf_fp_mul_c_11_52  (IEEE-754 Double)\r\n", "- cf_fp_mul_p_11_52  (IEEE-754 Double)\r\n", "\r\n        "]},
{"details": ["\n    Name: cf_fft", "\n    Created: Jan  5, 2003", "\n    Updated: May 18, 2012", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nThe Fast Fourier Transform converts time or spacial information into the frequency domain and is one of the most popular DSP algorithms.\n        ", "\n            The FFT architecture is pipelined on a rank basis; each rank has\r\n", "its own butterfly and ranks are isolated from each other using\r\n", "memory interleavers.  This FFT can perform calculations on\r\n", "continuous streaming data (one data set right after another).\r\n", "More over, inputs and outputs are passed in pairs, doubling the\r\n", "bandwidth.  For instance, a 4096 point FFT can perform a transform\r\n", "every 2048 cycles.\r\n", "\r\n", "Each file is stand-alone and represents a specific configuration.\r\n", "The 2 parameters are:\r\n", "  - Number of Points\r\n", "  - Component (Real/Imag) Precision\r\n", "\r\n", "All designs are pipelined with a synchronous enable and reset.\r\n", "\r\n", "The configuration parameters are coded in the file names: cf_fft_4096_18.v\r\n", "  - 4K point FFT.\r\n", "  - 18 bit precision, real and imaginary.  Total is 36 bits.\r\n", "\r\n", "Current configurations:\r\n", "  - cf_fft_256_8\r\n", "  - cf_fft_512_8\r\n", "  - cf_fft_1024_8\r\n", "  - cf_fft_2048_8\r\n", "  - cf_fft_4096_8\r\n", "  - cf_fft_256_16\r\n", "  - cf_fft_512_16\r\n", "  - cf_fft_1024_16\r\n", "  - cf_fft_2048_16\r\n", "  - cf_fft_4096_16\r\n", "  - cf_fft_256_18\r\n", "  - cf_fft_512_18\r\n", "  - cf_fft_1024_18\r\n", "  - cf_fft_2048_18\r\n", "  - cf_fft_4096_18\n        "]},
{"details": ["\n    Name: cf_cordic", "\n    Created: Dec 31, 2002", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            Cores are generated from ", "; a modern logic design language.  Confluence is a simple, yet highly expressive language that compiles into Verilog, VHDL, and C.  See ", " for more info.\r\n\r\nCordics (COordinate Rotation DIgital Computers) perform arbitrary phase rotations of complex vectors and are often used to calculate trigonometric functions and vector magnitudes.\n        ", "\n            Each file is stand-alone and represents a specific configuration.\r\n", "The 4 parameters are:\r\n", "  - Rotation or Vector Mode\r\n", "  - Vector Precision\r\n", "  - Angle Precision\r\n", "  - Number of Cordic Stages\r\n", "\r\n", "All designs are pipelined with a synchronous enable and reset.\r\n", "The pipeline latency equals 2 clock cycles plus the number of cordic stages. \r\n", "\r\n", "The configuration parameters are coded in the file names: cf_cordic_r_32_16_12.v\r\n", "  - r  : Cordic Mode.  'r' = Rotation, 'v' = Vectoring\r\n", "  - 32 : Precision of the individual vector components.\r\n", "  - 16 : Precision of the angle.\r\n", "  - 12 : Number of cordic stages.\r\n", "\r\n", "Current configurations:\r\n", "  - cf_cordic_r_8_8_8\r\n", "  - cf_cordic_v_8_8_8\r\n", "  - cf_cordic_r_16_16_16\r\n", "  - cf_cordic_v_16_16_16\r\n", "  - cf_cordic_r_18_18_18\r\n", "  - cf_cordic_v_18_18_18\r\n", "  - cf_cordic_r_32_32_32\r\n", "  - cf_cordic_v_32_32_32\n        "]},
{"details": ["\n    Name: binary_to_bcd", "\n    Created: Nov 26, 2003", "\n    Updated: Dec 23, 2009", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: \n", "\n            These cores provide a simple means of converting between binary and BCD in hardware.  Written in Verilog, with parameters for the input and output widths, these simple cores illustrate the use of functions in Verilog for performing operations that are not easy to do any other way in a fully parameterized (scalable) block of logic.\r\n", "\r\n", "There are two conversions:  binary_to_bcd and bcd_to_binary.  These operate serially, requiring one clock per binary bit used in the conversion.\r\n", "\r\n", "The method used for the conversion from base 2 to base 10 is what I call a \"binary coded decimal arithmetic shift right\" (bcd_asr) and \"binary coded decimal arithmetic shift left\" (bcd_asl).  It is a special bit shift that involves checking for the magnitude of each 4-bit \"digit\" along the way.  When the magnitude is too great, a subtraction is performed, and a carry is generated for the next digit, which is then propagated down the entire string of digits.  This method seems to work well for arbitrary size input and output words.  Since the subtract/carry is performed during the shifting process, a carry never propagates further than one digit...  so there is no clock speed penalty for longer conversions.\r\n", "\r\n", "The method used in these cores for conversion should easily work for converting between any two numbering systems with EVEN BASES.  So, for example, it could be modified to output octal or base 14 instead of BCD.  But then, on a more practical note, who really uses those number bases in hardware anyway?\r\n", "\r\n", "There is also a 7-segment multiplexed type LED display driver, which was used in testing these modules.\r\n        ", "\n            - Modules completed, debugged and tested in SpartanII hardware.\r\n", "- Hardware test environment source code provided.\r\n", "- Parameterized Verilog, shows use of functions.\r\n", "- Start and End signals used (easily Wishbone compatible.)\r\n", "- Fully registered input and output.\r\n", "- A lengthy commentary at the beginning of each Verilog source file describes how the particular module works, and what the parameters mean.  This suffices for documentation, since no other design documentation is provided.\n        ", "\n            - Project completed, debugged and tested in hardware, modules are considered stable and ready for use.\r\n", "- Binary to BCD conversion, 16-bit binary to 5-digit BCD, consumes 45 slices in Xilinx SpartanII, reported 136MHz maximum operating speed (over 8 Million conversions per second).\r\n", "- BCD to Binary conversion, 5-digit BCD to 16-bit binary, consumes 30 slices in Xilinx SpartanII, reported 116MHz maximum operating speed (over 7 Million conversion per second).\r\n", "- Hardware test environment consumes 532 slices in Xilinx SpartanII, 48MHz clock speed used in testing (includes two converters, 16 registers, auto-baud rate serial hardware debugger, 7-digit multiplexed LED display driver).\r\n        "]},
{"details": ["\n    Name: ca_prng", "\n    Created: Aug 13, 2009", "\n    Updated: Dec 20, 2009", "\n        SVN Updated: Aug 19, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: BSD\n", "\n            A cellular automata (CA) is a discrete model that consists of a grid (1D, 2D, 3D ) with objects called cells. Each cell can be in one of a given set of states (on and off, different colours etc). Each cell has a set of cells in close proximity (neighbours). Given the current internal state of a cell, the states of the neighbour cells and a given set of update rules the next state of a cell can be determined.\r\n", "\r\n\r\nThe ca_prng IP-core implements a 1D binary cellular automata with wrap around at the edges (i.e. a ring). The default update rule used in the ca_prng is rule30 discovered by Stephen Wolfram. Rule30 is an update rule that when applied to the CA will produce a class III, aperiodic, chaotic behaviour.\r\n", "\r\n\r\nThe ca_prng core is a fast, compact pattern generator capable of providing user selectable patterns at GByte/s speed. The ca_prng core is suitable for FPGA-accelerated verification, on-chip testing as well as for applications that needs random patterns or specific sets of patterns generated.\r\n", "\r\n\r\n", " The ca_prng is ", " a cryptographically strong PRNG and should not be used as a key generator or as a stream cipher. \n        "]},
{"details": ["\n    Name: mult_booth_array", "\n    Created: Oct 17, 2017", "\n    Updated: Oct 17, 2017", "\n        SVN Updated: Oct 17, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            This IP core provides a resource efficient implementation of a Booth Array Multiplier for Xilinx FPGAs as proposed in:\r\n", "\r\n", "M. Kumm, S. Abbas, and P. Zipf, An Efficient Softcore Multiplier Architecture for Xilinx FPGAs, IEEE Symposium on Computer Arithmetic (ARITH), 2015, pp. 18\u201325\n        "]},
{"details": ["\n    Name: fast_antilog", "\n    Created: Aug  8, 2010", "\n    Updated: Jan 28, 2011", "\n        SVN Updated: Aug  8, 2010", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", "  reported /  solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            A fast (single-cycle) base-2 antilog function.\r\n", "\r\n", "Need an electronic design solution? Visit ", "\r\n", "\r\n", "Doesn't run quite as fast as my Log code: 166MHz, vs. 250MHz for the log. Registering the input would bring that up. Takes about the same resources as the log.\r\n", "\r\n", "To do a single-cycle square-root, first take the log. Then, divide that result by 2 (shift), and take the antilog. Tada... \r\n", "\r\n", "If you use this, please write and tell me about it! \r\n", "\n        "]},
{"details": ["\n    Name: 8bit_vedic_multiplier", "\n    Created: Dec 15, 2015", "\n    Updated: Aug 25, 2017", "\n        SVN Updated: Jan 23, 2016", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: 4-bit-system", "\n    Created: Mar 26, 2017", "\n    Updated: Aug 25, 2017", "\n        SVN Updated: Mar 27, 2017", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", "\n        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            Please write a description of the project here. It is used as a MetaTag (search engines looks at this).\n        "]},
{"details": ["\n    Name: fast-crc", "\n    Created: Jul 22, 2002", "\n    Updated: Aug  8, 2013", "\n        SVN Updated: Mar 10, 2009", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 1 reported / 1 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: GPL\n", "\n            A 32-bit parallel and highly pipelined Cyclic Redundancy Code (CRC) generator is presented. The design can handle 5 different channels at an input rate of 2Gbps each (the total output throughput is 5x4Gbps.) \r\n", "\r\n", "The generated CRCs are compatible with the 32-bit Ethernet standards. The circuit has been implemented with standard cells in a 0.35Micron standard CMOS process using the properties of Galois Fields and has been conceived as a \"free\" IP. \n        ", "\n            - 5 independent channels @ 4Gbps each\r\n", "- Works (simulations) with a standard AMS 0.35Micron process\r\n        ", "\n            - Ready to use.\n        "]},
{"details": ["\n    Name: apbtoaes128", "\n    Created: Sep  9, 2014", "\n    Updated: Jan 19, 2016", "\n        SVN Updated: Apr  6, 2015", "\n    SVN: ", "\n    Latest version: ", " (might take a bit to start...)", "\n    Statistics: ", "\n        ", " 3 reported / 0 solved\n", "\n    ", "\n\n    ", "\n", "\n    Category: ", "\n    Language: ", "\n    Development status: ", "\n    Additional info:\n        ", ",        ", ",        ", "        ", "\n    WishBone compliant: No", "\n    WishBone version: n/a", "\n    License: LGPL\n", "\n            ", " This is crypto core with AMBA support APB based on datasheet fom  ", "  If you liked our work is want to help contribute to the future progress of others who have seen help us by donating.\r\n\r\n", "\r\n\r\n\r\n", "\r\n\r\n   ", " ", " ", " \r\nGLADIC is a group of people working with integrated circuits in Latin America that have done some work with integrated circuits or participated in training in the part of the digital flow. We hope that our IPs are also vital in any way the proposal for those who want to use it and it goes to silicon. We encourage anyone to make a donation to the OpenCores to offer this opportunity to people to disclose their work and promote the development of microelectronics area.\r\n", " ", "\r\nThis IP was developed in order to:\r\n", "\r\n\r\n", "\r\nThis block consists of an encryption and decryption core that have the ECB mode, CBC, CTR. These modes have different types of jobs that are described in the above referenced manual. Each of these modes possesses other sub modes that are encryption / decryption / key generation / decryption with derivative of the original key. Also possesses configuration modes for switching / errors / DMA which is done through the configuration register. During processing in any way you can tell been reading another register that indicates the current state that the IP.\r\n", " ", " ", "\r\nAs the OpenCores encourages the use of free tools to check RTL so I decided to use the vpi / pli interface with C / C ++ in icarus verilog simulator to perform functional verification AES 128. The preparation of the verification environment was to plan test cases that validate each of the features developed by design. These cases mounted on the environment are individual tasks that enabled individually configure the DUT so that each cycle their outputs meet the rules set out in understanding the verifier.\r\n", "\r\n Finally a monitor to capture information and evaluate the result as the outputs are valid according the values already known. This environment does not have code coverage then there is no way to access how much code has been covered so far. We have the follow test cases:\r\n"]}
]